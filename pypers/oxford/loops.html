<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title>Lecture 1: Loops (i.e. iterators &amp; generators)</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-06-06 15:09:07 +0200 (Mon, 06 Jun 2005) $
:Version: $Revision: 3442 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* "! important" is used here to override other ``margin-top`` and
   ``margin-bottom`` styles that are later in the stylesheet or 
   more specific.  See http://www.w3.org/TR/CSS1#the-cascade */
.first {
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

img.borderless {
  border: 0 }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid thin gray }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid thin black }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="lecture-1-loops-i-e-iterators-generators">
<h1 class="title">Lecture 1: Loops (i.e. iterators &amp; generators)</h1>
<div class="section" id="part-i-iterators">
<h1><a name="part-i-iterators">Part I: iterators</a></h1>
<div class="section" id="iterators-are-everywhere">
<h2><a name="iterators-are-everywhere">Iterators are everywhere</a></h2>
<pre class="doctest-block">
&gt;&gt;&gt; for i in 1, 2, 3:
...     print i
1
2
3
</pre>
<p>The 'for' loop is using <em>iterators</em> internally:</p>
<pre class="literal-block">
it = iter((1,2,3))
while True:
    try:
        print it.next()
    except StopIteration:
        break
</pre>
</div>
<div class="section" id="iterables-and-iterators">
<h2><a name="iterables-and-iterators">Iterables and iterators</a></h2>
<p><em>Iterable</em> = anything you can loop over = any sequence + any object with an __iter__ method;</p>
<p>Not every sequence has an __iter__ method:</p>
<pre class="doctest-block">
&gt;&gt;&gt; &quot;hello&quot;.__iter__()
Traceback (most recent call last):
  ...
AttributeError: 'str' object has no attribute '__iter__'
</pre>
<p><em>Iterator</em> = any object with a .next method and an __iter__ method returning self</p>
</div>
<div class="section" id="simpler-way-to-get-an-iterator">
<h2><a name="simpler-way-to-get-an-iterator">Simpler way to get an iterator</a></h2>
<pre class="doctest-block">
&gt;&gt;&gt; it = iter(&quot;hello&quot;)
&gt;&gt;&gt; it.next()
'h'
&gt;&gt;&gt; it.next()
'e'
&gt;&gt;&gt; it.next()
'l'
&gt;&gt;&gt; it.next()
'l'
&gt;&gt;&gt; it.next()
'o'
&gt;&gt;&gt; it.next()
Traceback (most recent call last):
  ...
StopIteration
</pre>
</div>
<div class="section" id="sentinel-syntax-iter-callable-sentinel">
<h2><a name="sentinel-syntax-iter-callable-sentinel">Sentinel syntax iter(callable, sentinel)</a></h2>
<p>Example:</p>
<pre class="literal-block">
$ echo -e &quot;value1\nvalue2\nEND\n&quot; &gt; data.txt
$ python -c &quot;print list(iter(file('data.txt').readline, 'END\n'))&quot;
['value1\n', 'value2\n']
</pre>
<p>Beware of infinite iterators:</p>
<pre class="doctest-block">
&gt;&gt;&gt; repeat = iter(lambda : &quot;some value&quot;, &quot;&quot;)
&gt;&gt;&gt; repeat.next()
'some value'
</pre>
</div>
<div class="section" id="second-simpler-way-to-get-an-iterator-generator-expressions">
<h2><a name="second-simpler-way-to-get-an-iterator-generator-expressions">Second simpler way to get an iterator: generator-expressions</a></h2>
<pre class="doctest-block">
&gt;&gt;&gt; squares = (i*i for i in range(1,11)) 
&gt;&gt;&gt; list(squares)
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</pre>
<p>Excessive parenthesis can be skipped, so use</p>
<pre class="doctest-block">
&gt;&gt;&gt; dict((i, i*i) for i in range(1,11))
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100}
</pre>
<p>instead of</p>
<pre class="doctest-block">
&gt;&gt;&gt; dict([(i, i*i) for i in range(1,11)])
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100}
</pre>
<p>(as usual, the most elegant version is the most efficient).</p>
</div>
<div class="section" id="iteration-caveats">
<h2><a name="iteration-caveats">Iteration caveats</a></h2>
<pre class="doctest-block">
&gt;&gt;&gt; ls = [i for i in (1,2,3)]
&gt;&gt;&gt; i 
3
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; it = (j for j in (1,2,3))
&gt;&gt;&gt; j 
Traceback (most recent call last):
  ...
NameError: name 'j' is not defined
</pre>
<p>A subtler example:</p>
<pre class="doctest-block">
&gt;&gt;&gt; ls = [lambda :i for i in (1,2,3)]
&gt;&gt;&gt; ls[0]()
3
</pre>
<p>instead</p>
<pre class="doctest-block">
&gt;&gt;&gt; it = (lambda :i for i in (1,2,3))
&gt;&gt;&gt; it.next()()
1
&gt;&gt;&gt; it.next()()
2
&gt;&gt;&gt; it.next()()
3
</pre>
<p><em>seems</em> to be working but it is not really the case:</p>
<pre class="doctest-block">
&gt;&gt;&gt; it = (lambda :i for i in (1,2,3))
&gt;&gt;&gt; f1 = it.next()
&gt;&gt;&gt; f2 = it.next()
&gt;&gt;&gt; f3 = it.next()
&gt;&gt;&gt; f1()
3
</pre>
<p>The reason is that Python does LATE binding <em>always</em>. The solution is ugly:</p>
<pre class="doctest-block">
&gt;&gt;&gt; it = list(lambda i=i:i for i in (1,2,3))
&gt;&gt;&gt; it[0]()
1
&gt;&gt;&gt; it[1]()
2
&gt;&gt;&gt; it[2]()
3
</pre>
</div>
</div>
<div class="section" id="part-ii-generators">
<h1><a name="part-ii-generators">Part II: generators</a></h1>
<p>Trivial example:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def gen123(): # &quot;function&quot; which returns an iterator over the values 1, 2, 3
...     yield 1
...     yield 2
...     yield 3
...
&gt;&gt;&gt; it = gen123()
&gt;&gt;&gt; it.next()
1
&gt;&gt;&gt; it.next()
2
&gt;&gt;&gt; it.next()
3
&gt;&gt;&gt; it.next()
Traceback (most recent call last):
  ...
StopIteration
</pre>
<p>Real life example: using generators to generate HTML tables</p>
<pre class="literal-block">
#&lt;htmltable.py&gt;

def HTMLTablegen(table):
    yield &quot;&lt;table&gt;&quot;
    for row in table:
       yield &quot;&lt;tr&gt;&quot;
       for col in row:
           yield &quot;&lt;td&gt;%s&lt;/td&gt;&quot; % col
       yield &quot;&lt;/tr&gt;&quot;
    yield &quot;&lt;/table&gt;&quot;

def test():
    return &quot;\n&quot;.join(HTMLTablegen([[&quot;Row&quot;, &quot;City&quot;], 
                       [1,'London'], [2, 'Oxford']]))

if __name__ == &quot;__main__&quot;: # example
    print test()

#&lt;/htmltable.py&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from htmltable import test
&gt;&gt;&gt; print test()
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;Row&lt;/td&gt;
&lt;td&gt;City&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;London&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Oxford&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</pre>
<div class="section" id="a-simple-recipe-skip-redundant">
<h2><a name="a-simple-recipe-skip-redundant">A simple recipe: skip redundant</a></h2>
<p>How to remove duplicates by keeping the order:</p>
<pre class="literal-block">
#&lt;skip_redundant.py&gt;

def skip_redundant(iterable, skipset=None):
   &quot;Redundant items are repeated items or items in the original skipset.&quot;
   if skipset is None: skipset = set()
   for item in iterable:
       if item not in skipset:
           skipset.add(item)
           yield item
         
#&lt;/skip_redundant.py&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from skip_redundant import skip_redundant
&gt;&gt;&gt; print list(skip_redundant(&quot;&lt;hello, world&gt;&quot;, skipset=set(&quot;&lt;&gt;&quot;)))
['h', 'e', 'l', 'o', ',', ' ', 'w', 'r', 'd']
</pre>
</div>
<div class="section" id="another-real-life-example-working-with-nested-structures">
<h2><a name="another-real-life-example-working-with-nested-structures">Another real life example: working with nested structures</a></h2>
<pre class="literal-block">
#&lt;walk.py&gt;

def walk(iterable, level=0):
    for obj in iterable:
        if not hasattr(obj, &quot;__iter__&quot;): # atomic object
            yield obj, level
        else: # composed object: iterate again
            for subobj, lvl in walk(obj, level + 1):
                yield subobj, lvl

def flatten(iterable):
    return (obj for obj, level in walk(iterable))
       
def pprint(iterable):
    for obj, level in walk(iterable):
        print &quot; &quot;*level, obj
       
#&lt;/walk.py&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from walk import flatten, pprint
&gt;&gt;&gt; nested_ls = [1,[2,[3,[[[4,5],6]]]],7]
&gt;&gt;&gt; pprint(nested_ls)     
 1
  2
   3
      4
      5
     6
 7
&gt;&gt;&gt; pprint(flatten(nested_ls))
 1
 2
 3
 4
 5
 6
 7
</pre>
</div>
<div class="section" id="another-typical-use-case-for-generators-parsers">
<h2><a name="another-typical-use-case-for-generators-parsers">Another typical use case for generators: parsers</a></h2>
<p>A very stripped down parser for nested expressions</p>
<pre class="literal-block">
#&lt;sexpr2indent.py&gt;
&quot;&quot;&quot;A simple s-expression formatter.&quot;&quot;&quot;

import re

def parse(sexpr):
    position = 0
    nesting_level = 0
    paren = re.compile(r&quot;(?P&lt;paren_beg&gt;\()|(?P&lt;paren_end&gt;\))&quot;)
    while True:
        match = paren.search(sexpr, position)
        if match:
            yield nesting_level, sexpr[position: match.start()]
            if match.lastgroup == &quot;paren_beg&quot;:
                nesting_level += 1
            elif match.lastgroup == &quot;paren_end&quot;:
                nesting_level -= 1
            position = match.end()
        else:
            break

def sexpr_indent(sexpr):
    for nesting, text in parse(sexpr.replace(&quot;\n&quot;, &quot;&quot;)):
        if text.strip():  print &quot; &quot;*nesting, text

#&lt;/sexpr2indent.py&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from sexpr2indent import sexpr_indent
&gt;&gt;&gt; sexpr_indent(&quot;&quot;&quot;\
... (html (head (title Example)) (body (h1 s-expr formatter example)
... (a (&#64; (href http://www.example.com)) A link)))&quot;&quot;&quot;)
... #doctest: +NORMALIZE_WHITESPACE
  html
   head
    title Example
    body
    h1 s-expr formatter example
    a
     &#64;
      href http://www.example.com
     A link
</pre>
</div>
<div class="section" id="other-kinds-of-iterables">
<h2><a name="other-kinds-of-iterables">Other kinds of iterables</a></h2>
<p>The following class generates iterable which are not iterators:</p>
<pre class="literal-block">
#&lt;reiterable.py&gt;

class ReIter(object):
    &quot;A re-iterable object.&quot;
    def __iter__(self):
        yield 1
        yield 2
        yield 3

#&lt;/reiterable.py&gt;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from reiterable import ReIter
&gt;&gt;&gt; rit = ReIter()
&gt;&gt;&gt; list(rit)
[1, 2, 3]
&gt;&gt;&gt; list(rit) # it is reiterable!
[1, 2, 3]
</pre>
</div>
<div class="section" id="the-itertools-module">
<h2><a name="the-itertools-module">The itertools module</a></h2>
<blockquote>
<ul class="simple">
<li>count([n]) --&gt; n, n+1, n+2, ...</li>
<li>cycle(p) --&gt; p0, p1, ... plast, p0, p1, ...</li>
<li>repeat(elem [,n]) --&gt; elem, elem, elem, ... endlessly or up to n times</li>
<li>izip(p, q, ...) --&gt; (p[0], q[0]), (p[1], q[1]), ...</li>
<li>ifilter(pred, seq) --&gt; elements of seq where pred(elem) is True</li>
<li>ifilterfalse(pred, seq) --&gt; elements of seq where pred(elem) is False</li>
<li>islice(seq, [start,] stop [, step]) --&gt; elements from seq[start:stop:step]</li>
<li>imap(fun, p, q, ...) --&gt; fun(p0, q0), fun(p1, q1), ...</li>
<li>starmap(fun, seq) --&gt; fun(*seq[0]), fun(*seq[1]), ...</li>
<li>tee(it, n=2) --&gt; (it1, it2 , ... itn) splits one iterator into n</li>
<li>chain(p, q, ...) --&gt; p0, p1, ... plast, q0, q1, ...</li>
<li>takewhile(pred, seq) --&gt; seq[0], seq[1], until pred fails</li>
<li>dropwhile(pred, seq) --&gt; seq[n], seq[n+1], starting when pred fails</li>
<li>groupby(iterable[, keyfunc]) --&gt; sub-iterators grouped by value of keyfunc(v)</li>
</ul>
</blockquote>
</div>
<div class="section" id="anytrue">
<h2><a name="anytrue">anyTrue</a></h2>
<pre class="doctest-block">
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; def anyTrue(predicate, iterable): 
...     return True in itertools.imap(predicate, iterable)
...
&gt;&gt;&gt; fname = &quot;picture.gif&quot;
&gt;&gt;&gt; anyTrue(fname.endswith, &quot;.jpg .gif .png&quot;.split())
True
</pre>
<p>AnyTrue does <em>short-circuit</em>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def is3(i):
...     print &quot;i=%s&quot; % i
...     return i == 3
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; anyTrue(is3, range(10))
i=0
i=1
i=2
i=3
True
</pre>
</div>
<div class="section" id="chop">
<h2><a name="chop">chop</a></h2>
<p>You want to chop an iterable in batches of a given size:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from chop import chop
&gt;&gt;&gt; list(chop([1, 2, 3, 4], 2))
[[1, 2], [3, 4]]
&gt;&gt;&gt; list(chop([1, 2, 3, 4, 5, 6, 7],3))
[[1, 2, 3], [4, 5, 6], [7]]
</pre>
<p>Here is a possible implementation:</p>
<pre class="literal-block">
#&lt;chop.py&gt;

# see also http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/303279

import itertools

def chop(iterable, batchsize):
    it = iter(iterable)
    while True:
        batch = list(itertools.islice(it, batchsize))
        if batch: yield batch
        else: break

#&lt;/chop.py&gt;
</pre>
<p>For people thinking Python is too readable, here is a one-liner:</p>
<pre class="doctest-block">
&gt;&gt;&gt; chop = lambda it, n : itertools.izip(*(iter(it),)*n)
...
&gt;&gt;&gt; list(chop([1,2,3,4], 2))
[(1, 2), (3, 4)]
</pre>
</div>
<div class="section" id="tee">
<h2><a name="tee">tee</a></h2>
<p>To make copies of iterables; typically used in parsers:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from itertools import tee, chain, izip
&gt;&gt;&gt; chars, prevs = tee(&quot;abc&quot;)
&gt;&gt;&gt; prevs = chain([None], prevs)
&gt;&gt;&gt; for char, prev in izip(chars, prevs):
...     print char, prev
...
a None
b a
c b
</pre>
</div>
<div class="section" id="grouping-and-sorting">
<h2><a name="grouping-and-sorting">Grouping and sorting</a></h2>
<pre class="doctest-block">
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; from operator import itemgetter
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; NAME, AGE = 0, 1
&gt;&gt;&gt; query_result = (&quot;Smith&quot;, 34), (&quot;Donaldson&quot;, 34), (&quot;Lee&quot;, 22), (&quot;Orr&quot;, 22)
</pre>
<p>Grouping together people of the same age:</p>
<pre class="doctest-block">
&gt;&gt;&gt; for k, g in groupby(query_result, key=itemgetter(AGE)):
...     print k, list(g)
...
34 [('Smith', 34), ('Donaldson', 34)]
22 [('Lee', 22), ('Orr', 22)]
</pre>
<p>Sorting by name:</p>
<pre class="doctest-block">
&gt;&gt;&gt; for tup in sorted(query_result, key=itemgetter(NAME)):
...     print tup
('Donaldson', 34)
('Lee', 22)
('Orr', 22)
('Smith', 34)
</pre>
</div>
</div>
</div>
</body>
</html>
