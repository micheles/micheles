<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.1: http://docutils.sourceforge.net/" />
<title>Python gotchas</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="python-gotchas">
<h1 class="title">Python gotchas</h1>
<p>One of the strenghts of Python is its ability to be easy to understand and
unsurprising most of the times. However, easy does not mean trivial and
there actually situations where Python can surprise the new user (and 
sometimes even the old timer). In this rubric we will discuss few of
those Python gotchas.</p>
<p>The choice will be based on questions which are periodically asked on
the Python newsgroup: the fact that those questions are repeated means
that i) they are non-trivial and ii) more than few persons are caught
by those gotchas.</p>
<p>I will start with a gotcha who got me actually, and was the reason
for my first post on comp.lang.python.</p>
<p>The issue has been discussed in many threads on comp.lang.python; the
one where I understood the issue is this one:</p>
<p><a class="reference" href="http://groups.google.it/groups?hl=it&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;threadm=tyfsmgtbewl.fsf%40lxplus030.cern.ch&amp;rnum=1&amp;prev=/groups%3Fhl%3Dit%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26q%3Dsimionato%2Blambda%26btnG%3DCerca%26meta%3Dgroup%253Dcomp.lang.python">http://groups.google.it/groups?hl=it&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;threadm=tyfsmgtbewl.fsf%40lxplus030.cern.ch&amp;rnum=1&amp;prev=/groups%3Fhl%3Dit%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26q%3Dsimionato%2Blambda%26btnG%3DCerca%26meta%3Dgroup%253Dcomp.lang.python</a>.*</p>
<div class="section" id="statement-of-the-issue">
<h1><a name="statement-of-the-issue">Statement of the issue</a></h1>
<p>This gotcha is related to the scope rules of Python in loops: it often
appears in conjunction with lambda functions, but actually has nothing
to do with them, since lambda functions are not special at all in
Python. To show what the surprising behaviour is, consider the
following code:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def make_adders(n):
...    return [(lambda x: x+i) for i in range(n)]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; add0,add1=make_adders(n=2)
</pre>
<p>Now, it is clear what add1(0) will do:</p>
<pre class="doctest-block">
&gt;&gt;&gt; add1(0)
1
</pre>
<p>The surprise is with add0(0), which does not return 0, as you
would probably expect:</p>
<pre class="doctest-block">
&gt;&gt;&gt; add0(0)
1
</pre>
<p>The issue has nothing to do with lambda functions and list comprehensions,
since</p>
<pre class="doctest-block">
&gt;&gt;&gt; def make_adders(n):
...     ls=[]
...     for i in range(n):
...         def f(x):
...             return x+i
...         ls.append(f)
...     return ls
</pre>
<p>has the same exact behavior:</p>
<pre class="doctest-block">
&gt;&gt;&gt; add1(0)
1
&gt;&gt;&gt; add0(0)
1
</pre>
<p>The behavior is even more surprising if you think that other languages
(such as Haskell, the language from which Python stole list comprehensions)
do the &quot;right&quot; thing, i.e.</p>
<pre class="literal-block">
Prelude&gt; let make-adders n = [ \x -&gt; x + i | i &lt;- [0..n-1] ]
Prelude&gt; let [add0,add1] = make_adders 2
Prelude&gt; add0 0
0
Prelude&gt; add1 0
1
</pre>
<p>(this example was provided to me by a Haskell expert, I never actually used
the language, but I report it here just to show that there are languages
where you get what you expect).</p>
<p>So one could consider this as a Python wart. However, the truth is more
complex.</p>
</div>
<div class="section" id="explanation-of-the-issue">
<h1><a name="explanation-of-the-issue">Explanation of the issue</a></h1>
<p>The reason why Python acts as it does, is that <em>by design</em> Python
loops (both &quot;for&quot; loops and &quot;while&quot; loops) do not introduce a new
scope.</p>
<p>So, if I write</p>
<pre class="doctest-block">
&gt;&gt;&gt; a = 1 # no-new-scope
&gt;&gt;&gt; for i in range(1,10):
...     a = i
...     if i == 2: break
&gt;&gt;&gt; a
2
</pre>
<p>the &quot;a&quot; inside the for loop is exactly the same as the &quot;a&quot; defined outside
the &quot;for&quot; loop. This is what I want: if the &quot;for&quot; loop introduced a new
scope, then the inner &quot;a&quot; would be a local variable and the result of
this code would be &quot;a=1&quot; for the original global variable. Since
Python does not have the ability to rebind variables in outer scopes,
there would be no way to change &quot;a&quot; from inside the loop <a class="footnote-reference" href="#id2" id="id1" name="id1">[1]</a>.</p>
<p>But what exactly happens, when Python encounters a &quot;for&quot; loop?
The answer is that the form</p>
<pre class="literal-block">
for i in iterable:
    &lt;do_something i&gt;
</pre>
<p>is essentially interpreted as</p>
<pre class="literal-block">
try:
    it = iter(iterable)  
    while True:
        i = it.next()
        &lt;do_something i&gt;
except StopIteration:
    pass
</pre>
<p>As you see, this does not introduce any new scope. In order to solve the 
&quot;issue&quot; you have to introduce a new scope. In Python, the natural way
to introduce a new scope is via a function.
If the &quot;for&quot; loop was interpreted as follows</p>
<pre class="literal-block">
try:   
    it = iter(iterable)
    def helper(i): # helper function
        &lt;do_something i&gt;
    while True:
        helper(it.next())
except StopIteration:
    pass
</pre>
<p>then a new &quot;i&quot; would enter in the scope at each iteration.</p>
<p>For instance, in the example I am talking about,</p>
<pre class="literal-block">
def make_adders(n):
    return [lambda x: x+i for i in range(n)]
</pre>
<p>would be interpreted as</p>
<pre class="doctest-block">
&gt;&gt;&gt; def make_adders(n):
...     try:
...         adders=[]
...         it = iter(range(2))
...         def helper(i):
...             adders.append(lambda x: x+i)
...         while True:
...             helper(it.next())
...     except StopIteration:
...         return adders
</pre>
<p>You can check that with this definition <tt class="literal"><span class="pre">make_adders</span></tt> does the right thing:</p>
<pre class="doctest-block">
&gt;&gt;&gt; add0,add1 = make_adders(n=2)
&gt;&gt;&gt; add1(0)
1
&gt;&gt;&gt; add0(0)
0
</pre>
<p>Essentially, the &quot;i&quot; variable would be passed via the helper function
call and at each iteration the lambda function would see a different
value of it.</p>
<p>Unfortunately, changing Python &quot;for&quot; loops in this way would cause
an even worse wart, as I discussed in the <tt class="literal"><span class="pre">no-new-scope</span></tt> example.</p>
<p>That is the reason why the present behavior will
not change.</p>
<table class="footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[1]</a></td><td>Unless you use contorsion involving making &quot;a&quot; an element of
a mutable container.</td></tr>
</tbody>
</table>
</div>
</div>
<hr class="footer" />
<div class="footer">
<a class="reference" href="python-subtilities.txt">View document source</a>.
Generated on: 2004-05-03 15:26 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
