<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.9: http://docutils.sourceforge.net/" />
<title>Implementing PEP 318 (decorators)</title>
<meta name="author" content="Michele Simionato" />
<meta name="date" content="September 2003" />
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="implementing-pep-318-decorators">
<h1 class="title">Implementing PEP 318 (decorators)</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">Module:</th><td class="field-body">decorators</td>
</tr>
<tr><th class="docinfo-name">Version:</th>
<td>0.5</td></tr>
<tr><th class="docinfo-name">Author:</th>
<td>Michele Simionato</td></tr>
<tr class="field"><th class="docinfo-name">e-mail:</th><td class="field-body"><a class="reference" href="mailto:MicheleSimionato&#64;libero.it">MicheleSimionato&#64;libero.it</a></td>
</tr>
<tr class="field"><th class="docinfo-name">Licence:</th><td class="field-body">Python-like</td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>September 2003</td></tr>
<tr class="field"><th class="docinfo-name">Disclaimer:</th><td class="field-body">This is experimental code. Use it at your own risk!</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title"><a name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#using-decorators" id="id4" name="id4">Using decorators</a><ul>
<li><a class="reference" href="#basics" id="id5" name="id5">Basics</a></li>
<li><a class="reference" href="#decorating-methods" id="id6" name="id6">Decorating methods</a></li>
<li><a class="reference" href="#decorating-classes" id="id7" name="id7">Decorating classes</a></li>
<li><a class="reference" href="#adding-magic" id="id8" name="id8">Adding magic</a></li>
<li><a class="reference" href="#defining-method-decorators" id="id9" name="id9">Defining method decorators</a></li>
<li><a class="reference" href="#defining-class-decorators" id="id10" name="id10">Defining class decorators</a></li>
<li><a class="reference" href="#composing-decorators" id="id11" name="id11">Composing decorators</a></li>
<li><a class="reference" href="#diving-into-magic" id="id12" name="id12">Diving into magic</a></li>
<li><a class="reference" href="#advanced-usage" id="id13" name="id13">Advanced usage</a></li>
</ul>
</li>
<li><a class="reference" href="#the-implementation" id="id14" name="id14">The implementation</a><ul>
<li><a class="reference" href="#module-decorators" id="id15" name="id15">Module <tt class="literal"><span class="pre">decorators</span></tt></a><ul>
<li><a class="reference" href="#id3" id="id16" name="id16">Metaclasses</a></li>
<li><a class="reference" href="#classes" id="id17" name="id17">Classes</a></li>
<li><a class="reference" href="#functions" id="id18" name="id18">Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="using-decorators">
<h1><a class="toc-backref" href="#id4" name="using-decorators">Using decorators</a></h1>
<p>Having plenty of free time in these days, I have finished an old 
project of mine, the implementation of <a class="reference" href="http://www.python.org/pep">PEP 318</a> in pure Python
(2.3).</p>
<p>Here is the rationale:</p>
<ul class="simple">
<li>some kind of decorator syntax is scheduled to go in Python 2.4,
therefore it is interesting to play with the concept;</li>
<li>it is nice to play with decorators now, without having to
wait for one year or so;</li>
<li>it is much easier to experiment with a pure Python implementation
than with a C implementation;</li>
<li>the implementation can be seen as an exercise on modern Python
programming and may be valuable to people wanting to study the most
advanced new constructs in Python (<a class="reference" href="http://users.rcn.com/python/download/Descriptor.htm">descriptors</a>, <a class="reference" href="http://www-106.ibm.com/developerworks/library/l-pymeta2.html">metaclasses</a>, 
<a class="reference" href="http://www.python.org/2.3/descrintro.html">cooperative methods</a>, etc.)</li>
</ul>
<div class="section" id="basics">
<h2><a class="toc-backref" href="#id5" name="basics">Basics</a></h2>
<p>PEP 318 has the goal of providing a nice syntactic sugar for expressions like</p>
<blockquote>
<pre class="literal-block">
def identity(x):
    return x
identity=staticmethod(identity)
</pre>
</blockquote>
<p>or</p>
<blockquote>
<pre class="literal-block">
def name(cls):
   return cls.__name__
name=classmethod(name)
</pre>
</blockquote>
<p>which are pretty verbose. It is clear that having new syntax (as 
for instance the proposed square bracket notation)</p>
<blockquote>
<pre class="literal-block">
def identity(x)[staticmethod]:
    return x

def name(cls)[classmethod]:
    return cls.__name__
</pre>
</blockquote>
<p>involves changing the grammar and modifying the interpreter at the
C level. This means a lot of work. Fortunately, it is possible to 
have the same effect without changing the Python grammar. 
The idea is to use magic docstrings like this:</p>
<blockquote>
<pre class="literal-block">
def identity(x):
    &quot;[staticmethod]&quot;
    return x

def name(cls):
    &quot;[classmethod]&quot;
    return cls.__name__
</pre>
</blockquote>
<p>The implementation is able to recognize such magic docstrings
and automatically converts methods with magic docstrings in 
method decorators.</p>
<p>Decorators are nothing else than a sophisticated kind of wrappers.
The <tt class="literal"><span class="pre">decorators</span></tt> module provides support both for method decorators
and class decorators:</p>
<ul class="simple">
<li><em>Method decorators</em> are classes taking a single function as input and 
producing a descriptor object as output. <tt class="literal"><span class="pre">staticmethod</span></tt> and 
<tt class="literal"><span class="pre">classmethod</span></tt> are two examples of already existing
method decorators (actually my implementation rewrites them).
A knowledge of descriptors <a class="footnote-reference" href="#id2" id="id1" name="id1">[1]</a> is not needed in order to use the <tt class="literal"><span class="pre">decorator</span></tt> 
module; however it is welcomed for advanced users wanting to implement
custom method decorators.</li>
<li><em>Class decorators</em> are metaclasses taking a class as imput and returning
a decorated class as output. A good understanding of metaclasses is needed 
in order to be able to write custom class decorators, but no knowledge
at all is required in order to use the pre-defined class decorators
provided by the module.</li>
</ul>
<p>Notice that properties are not decorators according to my definitions, 
since they take four functions as input, <tt class="literal"><span class="pre">get,</span> <span class="pre">set,</span> <span class="pre">del_</span></tt> and <tt class="literal"><span class="pre">doc</span></tt>.
Whereas the decorators concept could be generalized to the case of
multiple inputs, I don't see the need for such complication, so
properties are not implemented as method decorators. Moreover, I
think it is much better to use them trough a class decorator.</p>
<p>Finally, the module is meant to be extensible; so one could 
define new kind of decorators. For instance, the original version of
the module also had the concept of module decorators; however I have cut 
down that part in order to keep the documentation short.</p>
<p>Admittedly, the implementation 
is not for the faint of heart, nevertheless I have tried to make the 
basic usage easy and simple to understand.</p>
<table class="footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[1]</a></td><td>Descriptors are objects with a <tt class="literal"><span class="pre">__get__</span></tt> method; they are quite 
sophisticated, but fortunately they have been wonderfully explained by 
Raymond Hettinger already, so  I am allowed to skip on this point ;).</td></tr>
</tbody>
</table>
</div>
<div class="section" id="decorating-methods">
<h2><a class="toc-backref" href="#id6" name="decorating-methods">Decorating methods</a></h2>
<p>Before talking about the implementation details, I will show
how the <tt class="literal"><span class="pre">decorators</span></tt> module works in practice. The simplest and safest
usage is by means of the <tt class="literal"><span class="pre">decorators.decorated()</span></tt> function, which
takes an object (a function or a class) and checks its docstring: if 
a magic docstring is found, it returns a decorated version of the object, 
otherwise it returns the original object. Using <tt class="literal"><span class="pre">decorators.decorated()</span></tt>
is simple but verbose, so magic shortcuts will be discussed in the next 
sections.</p>
<p>Here, let me give an example, showing that method decorators work both for 
<a class="reference" href="http://www.python.org/2.3/descrintro.html">new style classes and old style classes</a>:</p>
<blockquote>
<pre class="literal-block">
#&lt;example1.py&gt;

import decorators

def do_nothing(self):
   &quot;No magic docstring here&quot;
dec_do_nothing=decorators.decorated(do_nothing)

def identity(x):
    &quot;[staticmethod]&quot;
    return x
dec_identity=decorators.decorated(identity) 

def name(cls):
    &quot;[classmethod]&quot;
    return cls.__name__
dec_name=decorators.decorated(name)

class OldStyle:
    do_nothing=dec_do_nothing
    identity=dec_identity

class NewStyle(object):
    name=dec_name

o=OldStyle() # creates an old style instance
n=NewStyle() # creates a new style instance

#&lt;/example1.py&gt;
</pre>
</blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from example1 import * # for testing purposes
</pre>
<p>In this example, both <tt class="literal"><span class="pre">dec_identity</span></tt> and <tt class="literal"><span class="pre">dec_name</span></tt> are decorator objects,
i.e. descriptors modifiying the attribute access. It is easy to recognize
decorators objects in the interpreter, since they have a re-defined 
printing representation:</p>
<pre class="doctest-block">
&gt;&gt;&gt; print dec_identity
&lt;staticmethod:identity&gt;
&gt;&gt;&gt; print dec_name
&lt;classmethod:name&gt;
</pre>
<p>On the other hand, <tt class="literal"><span class="pre">do_nothing</span></tt> does not have a magic 
docstring, therefore it is not converted to a decorator object; 
actually it is <em>exactly</em> the original function</p>
<pre class="doctest-block">
&gt;&gt;&gt; dec_do_nothing is do_nothing # not converted
True
</pre>
<p>and it works as a standard method:</p>
<pre class="doctest-block">
&gt;&gt;&gt; o.do_nothing() # does nothing, correct
</pre>
<p>On the contrary, <tt class="literal"><span class="pre">dec_</span> <span class="pre">identity</span></tt> works as a staticmethod,</p>
<pre class="doctest-block">
&gt;&gt;&gt; OldStyle.identity(1) # called from the class
1
&gt;&gt;&gt; o.identity(1) # called from the instance
1
</pre>
<p>whereas <tt class="literal"><span class="pre">dec_name</span></tt> works as a classmethod:</p>
<pre class="doctest-block">
&gt;&gt;&gt; NewStyle.name() # called from the class
'NewStyle'
&gt;&gt;&gt; n.name() # called from the instance
'NewStyle'
</pre>
<p>Notice that, I have re-implemented the built-in 
<tt class="literal"><span class="pre">staticmethod</span></tt> and <tt class="literal"><span class="pre">classmethod</span></tt>, so</p>
<pre class="doctest-block">
&gt;&gt;&gt; isinstance(dec_identity,staticmethod)
False
</pre>
<p>and</p>
<pre class="doctest-block">
&gt;&gt;&gt; isinstance(dec_name,classmethod)
False
</pre>
<p>It is possible to recognize method decorators since they provides 
a couple of special attributes:</p>
<ul>
<li><p class="first"><tt class="literal"><span class="pre">__func__</span></tt>: returning the function from which they originated:</p>
<pre class="doctest-block">
&gt;&gt;&gt; assert dec_identity.__func__ is identity
&gt;&gt;&gt; assert dec_name.__func__ is name
</pre>
</li>
<li><p class="first"><tt class="literal"><span class="pre">__klass__</span></tt>: returning the class where they where defined:</p>
<pre class="doctest-block">
&gt;&gt;&gt; dec_identity.__klass__
&lt;class 'safetype.?'&gt;
</pre>
</li>
</ul>
<p>The question mark here means that the definition class is unknown.
The <tt class="literal"><span class="pre">__klass__</span></tt> attribute can be set by hand or automatically
with the trick explained in the next section.</p>
</div>
<div class="section" id="decorating-classes">
<h2><a class="toc-backref" href="#id7" name="decorating-classes">Decorating classes</a></h2>
<p>The problem with the approach just described 
is that it does not present any significant advantage over 
the already existing mechanism. A real step forward would be to
have classes with the ability of automatically decorating their 
methods according to the docstrings. 
This sounds a bit of magic, but actually can be done very simply 
by adding to the class a docstring starting with &quot;[Decorated]&quot;
and by decorating the class. 
Here is an example:</p>
<blockquote>
<pre class="literal-block">
#&lt;example2.py&gt;

from decorators import decorated
from example1 import do_nothing,identity,name

class B(object):
    &quot;This is a regular class&quot;

B=decorated(B) # does nothing

class C(B):
   &quot;[Decorated]&quot;
   do_nothing=do_nothing
   identity=identity
   class Inner: # old style class
       &quot;[Decorated]&quot; # required docstring   
       name=name

C=decorated(C) # regenerates the class converting methods in decorators
c=C()

#&lt;/example2.py&gt;
</pre>
</blockquote>
<p>Under the hood <tt class="literal"><span class="pre">decorators.decorated()</span></tt> recognizes the class level
magic docstring &quot;[Decorated]&quot; and creates an instance of the 
<tt class="literal"><span class="pre">decorators.Decorated</span></tt> metaclass.
Internally the metaclass invokes <tt class="literal"><span class="pre">decorators.decorated()</span></tt>
on the methods of its instances: this is why they becomes decorated
if a suitable docstring is found. Moreover, it decorates inner classes,
if a suitable docstring is found, and it works recursively.</p>
<p>Here is the testing:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from example2 import *
&gt;&gt;&gt; assert C.identity(1) == 1
&gt;&gt;&gt; assert C.Inner.name() == 'Inner'
&gt;&gt;&gt; assert c.identity(1) == 1 
&gt;&gt;&gt; assert c.Inner.name() == 'Inner' 
</pre>
<p>Notice that adding <tt class="literal"><span class="pre">identity</span></tt> after the class creation with the syntax 
<tt class="literal"><span class="pre">C.identity=identity</span></tt> would not work; 
<tt class="literal"><span class="pre">C.identity=decorators.decorated(identity)</span></tt> is required:</p>
<pre class="doctest-block">
&gt;&gt;&gt; C.identity=decorators.decorated(identity)
&gt;&gt;&gt; C.identity(1) # it works
1
</pre>
<p>If a class misses the magic docstring, nothing happens:</p>
<pre class="doctest-block">
&gt;&gt;&gt; B # returns the original B
&lt;class 'example2.B'&gt;
</pre>
<p>The mechanism works for old style classes too,
since the metaclass automagically converts the old style classes in a 
new style one:</p>
<pre class="doctest-block">
&gt;&gt;&gt; type(C.Inner) # C.Inner is an instance of decorator.Decorated
&lt;class 'decorators.Decorated'&gt;
</pre>
<p>The enhancement provided by the metaclass includes a new default 
printing representation for both the class</p>
<pre class="doctest-block">
&gt;&gt;&gt; print C # returns the name of D and of its metaclass
&lt;class C[Decorated]&gt;
</pre>
<p>and its instances:</p>
<pre class="doctest-block">
&gt;&gt;&gt; print c
&lt;C instance&gt;
</pre>
<p>On the other hand, if a custom printing representation is already
defined, the metaclass takes it without any change.</p>
<p>One can even forget the docstring in subclasses of decorated 
classes, since metaclasses are inherited:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class D(C):
...     def name(cls):
...          &quot;[classmethod]&quot;
...          return cls.__name__
&gt;&gt;&gt; print D.name()
D
</pre>
<p>Decorating whole classes presents another advantage: the decorated methods know
the class where they were defined via the special attribute <tt class="literal"><span class="pre">__klass__</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; D.__dict__['name'].__klass__ # the class where 'name' is defined
&lt;class 'D'&gt;
</pre>
<p>This is useful for introspection and debugging purposes.</p>
</div>
<div class="section" id="adding-magic">
<h2><a class="toc-backref" href="#id8" name="adding-magic">Adding magic</a></h2>
<p>The problem of the previous approach is that one must explicitely
decorate the classes by hand, by invoking <tt class="literal"><span class="pre">decorators.decorated()</span></tt>
each time. However, it is possible to add more magic
and to decorate all the classes automatically. 
It is as easy as writing <tt class="literal"><span class="pre">decorators.enhance_classes()</span></tt>
on top of you module. Then all methods in all classes with a magic docstring 
will be checked for magic docstrings and automagically decorated if needed. 
For instance, the previous example would be written</p>
<blockquote>
<pre class="literal-block">
#&lt;example3.py&gt;

import decorators; decorators.enhance_classes()

class C:
    &quot;[Decorated]&quot; # magic docstring here 
    def do_nothing(self):
       &quot;No magic docstring here&quot;

    def identity(x):
        &quot;[staticmethod]&quot;
        return x

class D(object):
    &quot;Undecorated&quot; # no magic docstring here
    def name(cls):
        &quot;[classmethod]&quot;
        return cls.__name__

c=C(); d=D()

#&lt;/example3.py&gt;
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">C</span></tt> has a <tt class="literal"><span class="pre">[Decorated]</span></tt> docstring, so its methods
are automatically decorated:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from example3 import *
&gt;&gt;&gt; assert c.do_nothing() is None
&gt;&gt;&gt; assert C.identity(1) == 1
&gt;&gt;&gt; assert c.identity(1) == 1 
</pre>
<p>On the other hand, since <tt class="literal"><span class="pre">D</span></tt> misses a magic docstring,
its <tt class="literal"><span class="pre">name</span></tt> method is not decorated:</p>
<pre class="doctest-block">
&gt;&gt;&gt; hasattr(D.__dict__['name'],'__func__') # not a decorator
False
</pre>
<p>Since <tt class="literal"><span class="pre">D.name</span></tt> is a regular method and not a classmethod, <tt class="literal"><span class="pre">D.name()</span></tt>
gives an error:</p>
<pre class="doctest-block">
&gt;&gt;&gt; D.name()
Traceback (most recent call last):
  ...
TypeError: unbound method name() must be called with D instance as first argument (got nothing instead)
</pre>
<p>Under the hood, the magic works by enhancing the <tt class="literal"><span class="pre">object</span></tt> class 
of the module with a <tt class="literal"><span class="pre">decorators.ClassDecorator</span></tt> metaclass:</p>
<pre class="doctest-block">
&gt;&gt;&gt; import example4
&gt;&gt;&gt; type(example4.object)
&lt;class 'decorators.ClassDecorator'&gt;
</pre>
<p>Notice that for safety reasons the enhancement is only on the module 
<tt class="literal"><span class="pre">object</span></tt> class, not on the <tt class="literal"><span class="pre">__builtin__.object</span></tt> class. The dangers of
adding too much magic are discussed in the <a class="reference" href="#diving-into-magic">Diving into magic</a> section.</p>
</div>
<div class="section" id="defining-method-decorators">
<h2><a class="toc-backref" href="#id9" name="defining-method-decorators">Defining method decorators</a></h2>
<p>The <tt class="literal"><span class="pre">decorators</span></tt> module contains two predefinite method decorators, 
<tt class="literal"><span class="pre">staticmethod</span></tt> and <tt class="literal"><span class="pre">classmethod</span></tt>, which emulate the built-ins 
with the same names. However, it is possible to write your own
custom decorators. The <tt class="literal"><span class="pre">decorators.MethodDecorator</span></tt> class which is here 
exactly for that purpose.</p>
<p>Custom decorators are expected to be implemented by subclassing
<tt class="literal"><span class="pre">MethodDecorator</span></tt> and by overriding its <tt class="literal"><span class="pre">get</span></tt> method. The
<tt class="literal"><span class="pre">get</span></tt> method automagically induces a <tt class="literal"><span class="pre">__get__</span></tt> method, turning the 
class in a descriptor. The machinery is needed since <tt class="literal"><span class="pre">__get__</span></tt> cannot 
be made cooperative using  the standard <tt class="literal"><span class="pre">super</span></tt> mechanism because
there would be a confusion between <tt class="literal"><span class="pre">super.__get__</span></tt> and the decorator 
<tt class="literal"><span class="pre">__get__</span></tt>. This is a bit tricky, but the causal programmer is not 
expected to write custom decorators, and actually I don't want to make 
the access to decorators <em>too</em> easy, since they are potentially dangerous.</p>
<p>In order to give a simple example, let me show the implementation 
of a <tt class="literal"><span class="pre">chattymethod</span></tt> that prints a message when it is called:</p>
<blockquote>
<pre class="literal-block">
#&lt;customdec.py&gt;

from decorators import *  

class chattymethod(MethodDecorator):
    logfile=sys.stdout # default
    def get(self,obj,cls=None): # same signature as __get__
        self.logfile.write('calling %s from %s\n' % (self,obj or cls))
        return super(chattymethod,self).get(obj,cls)

#&lt;/customdec.py&gt;
</pre>
</blockquote>
<p>Notice the usage of the <tt class="literal"><span class="pre">super().get</span></tt> trick. This guarantees that 
<tt class="literal"><span class="pre">chattymethod</span></tt> will play well with other decorators (i.e. it
can be nicely composed via multiple inheritance). The point will
be fully discussed in the section on composing decorators.</p>
<p>Here is an example of usage:</p>
<pre class="doctest-block">
&gt;&gt;&gt; import customdec # adds chattymethod to the list of known decorators
&gt;&gt;&gt; customdec.enhance_classes() # automagically enhances classes
&gt;&gt;&gt; class C: 
...     &quot; [Decorated] &quot;
...     def f(self): 
...         &quot;&quot;&quot;
...         [ chattymethod ]
...         &quot;&quot;&quot;
&gt;&gt;&gt; c=C()
&gt;&gt;&gt; c.f()
calling &lt;chattymethod:f&gt; from &lt;C instance&gt;
</pre>
<p>By the way, this shows that one can safely add whitespaces (including
newlines) to the magic docstring: they are simply ignored.</p>
<p>One can check that the syntax <tt class="literal"><span class="pre">C.f(c)</span></tt> works too:</p>
<pre class="doctest-block">
&gt;&gt;&gt; C.f(c) 
calling &lt;chattymethod:f&gt; from &lt;class C[Decorated]&gt;
</pre>
<p>A tricky point of the decorators mechanism is the issue of parameter passing.
In comp.lang.python there was the proposal of allowing explicit parameter
passing to decorators, with a syntax of kind</p>
<blockquote>
<pre class="literal-block">
def f(self)[chattymethod(logfile=file('file1.log','w'))]
</pre>
</blockquote>
<p>In my view, there are too many parenthesis in this syntax, and it 
becomes rapidly unreadable. Moreover, it complicates the implementation
without any real benefit, so the <tt class="literal"><span class="pre">decorators</span></tt> module does not allow
this kind of parameter passings. There are however viable
workarounds, so you should not miss the syntax.</p>
<p>A simple minded solution is to change the defaults by hand:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from customdec import chattymethod,decorated
&gt;&gt;&gt; chattymethod.logfile=file('file.log','w')
&gt;&gt;&gt; def g(self): 
...     &quot;[chattymethod]&quot;
&gt;&gt;&gt; C.g=decorated(g)
&gt;&gt;&gt; c.g() # will print a message on file.log
</pre>
<p>This approach has the drawback that chattymethods created before changing 
the logfile will also print to the new logfile, if invoked after the
change. Therefore</p>
<pre class="doctest-block">
&gt;&gt;&gt; c.f()
</pre>
<p>will print a message to <tt class="literal"><span class="pre">file.log</span></tt> too, and not to standard output.
Here is the confirmation:</p>
<pre class="doctest-block">
&gt;&gt;&gt; chattymethod.logfile.close()
&gt;&gt;&gt; print file('file.log').read().rstrip()
calling &lt;chattymethod:g&gt; from &lt;C instance&gt;
calling &lt;chattymethod:f&gt; from &lt;C instance&gt;
</pre>
<p>A better solution is to pass  
parameters to method decorators as function attributes: then the function
attributes can be converted to attributes of the decorator 
in  the <tt class="literal"><span class="pre">__init__</span></tt> method. Here is an example:</p>
<blockquote>
<pre class="literal-block">
#&lt;customdec.py&gt;

class chattymethod2(chattymethod): 
    logfile=sys.stdout # default
    def __init__(self,objfunc):
        super(chattymethod2,self).__init__(objfunc)
        logfile=getattr(self.__func__,'logfile',None)
        if logfile: self.logfile=logfile 

#&lt;/customdec.py&gt;
</pre>
</blockquote>
<p>Notice that the <tt class="literal"><span class="pre">__init__</span></tt> method has the signature
<tt class="literal"><span class="pre">__init__(self,objfunc)</span></tt>, where the <tt class="literal"><span class="pre">objfunc</span></tt> object is a
decorator object or the function to be converted in the decorator 
object, and that it is cooperative.
This is the suggested way of overriding <tt class="literal"><span class="pre">__init__</span></tt>.</p>
<p>Here is the testing:</p>
<blockquote>
<pre class="literal-block">
#&lt;chatty2.py&gt;

import customdec; customdec.enhance_classes()

# sets the log files
log1=file('file1.log','w')
log2=file('file2.log','w')

class C:
    &quot;[Decorated]&quot;
    def f(self): 
        &quot;[chattymethod2]&quot;
    f.logfile=log1 # function attribute
    def g(self): 
        &quot;[chattymethod2]&quot;
    g.logfile=log2 # function attribute

assert C.__dict__['f'].logfile is log1 # check the conversion 
assert C.__dict__['g'].logfile is log2 # function attr. -&gt; decorator attr.

c=C() # C instantiation

c.f() # print a message in file1.log
c.g() # print a message in file2.log

log1.close(); log2.close() # finally

#&lt;/chatty2.py&gt;
</pre>
</blockquote>
<p>Let me check the contents of the log files:</p>
<pre class="doctest-block">
&gt;&gt;&gt; import chatty2
&gt;&gt;&gt; print file('file1.log').read().rstrip()
calling &lt;chattymethod2:f&gt; from &lt;C instance&gt;
&gt;&gt;&gt; print file('file2.log').read().rstrip()
calling &lt;chattymethod2:g&gt; from &lt;C instance&gt;
</pre>
<p><tt class="literal"><span class="pre">chattymethod</span></tt> is the poor man version of <tt class="literal"><span class="pre">tracedmethod</span></tt>, a
sophisticated decorator for tracing methods.
Here is the code, given for pedagogical purposes; the lazy reader can 
skip it and go directly to the usage section.</p>
<blockquote>
<pre class="literal-block">
#&lt;customdec.py&gt;

class tracedmethod(MethodDecorator):
    &quot;Descriptor class, converts a method in a traced method&quot;
    indent=0; output=sys.stdout # defaults

    def __init__(self,objfunc):
        super(tracedmethod,self).__init__(objfunc)
        self.funcname=self.__func__.__name__
        output=getattr(self.__func__,'output',None) 
        if output: self.output=output # func.attr. -&gt; dec.attr.

    def get(self,obj,cls):
        clsname=self.__klass__.__name__ # definition clas
        def tracedmeth(obj,*args,**kw):
            i=' '*self.indent # default indentation
            self.__class__.indent+=4 # increases indentation
            self.output.write(&quot;%sCalling '%s.%s' with arguments &quot; % 
                             (i,clsname,self.funcname))
            self.output.write(&quot;%s%s ...\n&quot; % (obj or '',str(args)+str(kw)))
            res=super(tracedmethod,self).get(obj,cls)(*args,**kw)
            self.output.write(&quot;%s'%s.%s' called with result: %s\n&quot;
                               % (i,clsname,self.funcname,res))
            self.__class__.indent-=4 # restores default indentation
            return res
        return tracedmeth.__get__(obj,cls) # method wrapper

#&lt;/customdec.py&gt;
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">tracedmethod.get</span></tt> returns a method wrapper object, so it is
possible to use <tt class="literal"><span class="pre">im_func</span></tt> to retrieve the internal function
<tt class="literal"><span class="pre">tracedmeth</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C:
...     &quot;[Decorated]&quot;
...     def f(self):
...         &quot;[tracedmethod]&quot;
&gt;&gt;&gt; c=C(); c.f() 
Calling 'C.f' with arguments &lt;C instance&gt;(){} ...
'C.f' called with result: None
&gt;&gt;&gt; c.f.im_func.__name__
'tracedmeth'
</pre>
<p>As soon as the <tt class="literal"><span class="pre">tracedmethod</span></tt> module is loaded, the <tt class="literal"><span class="pre">tracedmethod</span></tt> class
is added to the list of know decorators, so one should use the  
&quot;[tracedmethod]&quot; docstring and not something like
&quot;[customdec.tracedmethod]&quot;.</p>
<p>Here is a less trivial example of usage, writing in a log file the 
internal working of a recursive function:</p>
<blockquote>
<pre class="literal-block">
#&lt;example9.py&gt;

import customdec; customdec.enhance_classes()

logfile=file('file3.log','w')

class C(object):
    &quot;[Decorated]&quot;
    def fact(self,n):
        &quot;[tracedmethod] The good old factorial.&quot;
        if n==0: return 1
        else: return n*self.fact(n-1)
    fact.output=logfile

C().fact(2) # write a message to logfile

logfile.close()

#&lt;/example9.py&gt;
</pre>
</blockquote>
<p>Here is the content of <tt class="literal"><span class="pre">file3.log</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; import example9 # creates file3.log
&gt;&gt;&gt; print file('file3.log').read().rstrip()
Calling 'C.fact' with arguments &lt;C instance&gt;(2,){} ...
    Calling 'C.fact' with arguments &lt;C instance&gt;(1,){} ...
        Calling 'C.fact' with arguments &lt;C instance&gt;(0,){} ...
        'C.fact' called with result: 1
    'C.fact' called with result: 1
'C.fact' called with result: 2
</pre>
</div>
<div class="section" id="defining-class-decorators">
<h2><a class="toc-backref" href="#id10" name="defining-class-decorators">Defining class decorators</a></h2>
<p>PEP 318 proposes to decorate methods by using descriptors; it is
quite natural to extend this idea and to decorate classes by using 
class decorators implemented as metaclasses. We already saw a couple of
class decorator at work, the metaclass <tt class="literal"><span class="pre">ClassDecorator</span></tt>, which gives
to its instances the ability to interpret class level magic docstrings, and
its subclass <tt class="literal"><span class="pre">Decorated</span></tt>, which converts functions in method decorators
if suitable docstrings are found.</p>
<p>To define a custom class decorator is easy: one defines a custom metaclass 
as usual, with the only difference of deriving from <tt class="literal"><span class="pre">ClassDecorator</span></tt> instead
of deriving from <tt class="literal"><span class="pre">type</span></tt>.</p>
<p>To understand how this works in practice, let me 
show how to add logging capabilities to a given class. The first
step is to define a suitable class decorator, such as the following:</p>
<blockquote>
<pre class="literal-block">
#&lt;customdec.py&gt;

class Logged(ClassDecorator):
    output=sys.stdout
    def __init__(cls,name,bases,dic):
        super(Logged,cls).__init__(name,bases,dic)
        print &gt;&gt; cls.output,&quot;%s created&quot; % cls

#&lt;/customdec.py&gt;
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">Logged</span></tt> is derived by the metaclass <tt class="literal"><span class="pre">ClassDecorator</span></tt>, 
which provides a certain amount of magic under the hood (in particular
its printing representation and its calling syntax are redefined by its
(meta-)metaclass <tt class="literal"><span class="pre">MetaDecorator</span></tt>). 
Logging capabilities can be added to a class 
by simply using the magic docstring syntax:</p>
<blockquote>
<pre class="literal-block">
#&lt;logged.py&gt;

import customdec; customdec.enhance_classes()

class D(object): # will print a message at D creation
    &quot;[Logged]&quot;

#&lt;/logged.py&gt;
</pre>
</blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import logged
&lt;class 'logged.D'&gt; created
</pre>
<p>Notice that the printing representation of <tt class="literal"><span class="pre">D</span></tt> involves the name
of <tt class="literal"><span class="pre">D</span></tt> preceded by the name of its metaclass, which in this case
is <tt class="literal"><span class="pre">Logged</span></tt></p>
<p>Each time an instance of <tt class="literal"><span class="pre">Logged</span></tt> is created, a similar message is printed:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class E(logged.D):
...     pass
&lt;class 'E'&gt; created
</pre>
<p>Notice that <tt class="literal"><span class="pre">E</span></tt> does not have any magic docstring</p>
<pre class="doctest-block">
&gt;&gt;&gt; E.__doc__ # no docstring
</pre>
<p>but still it inherits its magic from <tt class="literal"><span class="pre">D</span></tt>.</p>
<p>Another simple example of class decorator is the following metaclass 
which modifies the docstrings of the methods of its instances, 
by magically inducing tracing capabilities on them:</p>
<blockquote>
<pre class="literal-block">
#&lt;customdec.py&gt;

from types import FunctionType  

class Traced(Decorated):
    def __init__(cls,n,b,d):
        for name,func in d.iteritems():
            if isinstance(func,FunctionType) and name!='__str__': 
                # cannot trace __str__, since it is invoked by
                # tracedmethod and would generate infinite recursion
                func.__doc__=&quot;[tracedmethod] &quot; + (func.__doc__ or '')
        super(Traced,cls).__init__(n,b,d) # decorates the methods

#&lt;/customdec.py&gt;
</pre>
</blockquote>
<p>Here is an example of usage:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C(object):
...     &quot;&quot;&quot;[Traced] The class decorator adds the magic docstring
...     '[tracedmethod]' to f1 and f2, which are then converted 
...     in method decorator objects.&quot;&quot;&quot;
...     def f1(self): pass
...     def f2(self): pass
...
&gt;&gt;&gt; type(C)
&lt;class 'customdec.Traced'&gt;
&gt;&gt;&gt; c=C()
&gt;&gt;&gt; c.f1()
Calling 'C.f1' with arguments &lt;C instance&gt;(){} ...
'C.f1' called with result: None
&gt;&gt;&gt; c.f2()
Calling 'C.f2' with arguments &lt;C instance&gt;(){} ...
'C.f2' called with result: None
</pre>
<p>By default, the decorators module only decorates classes with a magic 
docstring (and they subclasses, even without magic docstrings). 
If all the classes of your module have the same magic docstring, 
it makes sense to decorate them all
with a single command. It is enough to use <tt class="literal"><span class="pre">decorators.enhance_classes()</span></tt>
with a magic docstring corresponding to a class decorator as argument, 
as in this example:</p>
<blockquote>
<pre class="literal-block">
#&lt;example7.py&gt;

from example2 import identity,name
import inspect, decorators; decorators.enhance_classes(&quot;[Decorated]&quot;)

class C1(object): # automagically converted to a decorated class
    identity=identity 

class C2: # automagically converted to a decorated class
    name=name

c1=C1() # C1 instance
c2=C2() # C2 instance

#&lt;/example7.py&gt;
</pre>
</blockquote>
<p>The magic works both for new style classes such as <tt class="literal"><span class="pre">C1</span></tt></p>
<pre class="doctest-block">
&gt;&gt;&gt; from example7 import C1,c1
&gt;&gt;&gt; assert C1.identity(1) == 1
&gt;&gt;&gt; assert c1.identity(1) == 1 
</pre>
<p>and old style classes such as <tt class="literal"><span class="pre">C2</span></tt> by implicitly converting them
to new style classes:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from example7 import C2,c2 
&gt;&gt;&gt; assert C2.name() == 'C2'
&gt;&gt;&gt; assert c2.name() == 'C2' 
</pre>
</div>
<div class="section" id="composing-decorators">
<h2><a class="toc-backref" href="#id11" name="composing-decorators">Composing decorators</a></h2>
<p>Decorators can be composed by using magic docstrings with comma-separated
decorator names. For instance, you can trace a classmethod:</p>
<blockquote>
<pre class="literal-block">
#&lt;example6.py&gt;

&quot;How to trace a class method&quot;

import customdec; customdec.enhance_classes()

class C(object):
    &quot;[Decorated]&quot;
    def fact(cls,n): # a traced classmethod
        &quot;[classmethod,tracedmethod]&quot;
        if n==0: return 1
        else: return n*cls.fact(n-1)

#&lt;/example6.py&gt;
</pre>
</blockquote>
<p>Here is the testing:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from example6 import C
&gt;&gt;&gt; C.fact(2)
Calling 'C.fact' with arguments &lt;class C[Decorated]&gt;(2,){} ...
    Calling 'C.fact' with arguments &lt;class C[Decorated]&gt;(1,){} ...
        Calling 'C.fact' with arguments &lt;class C[Decorated]&gt;(0,){} ...
        'C.fact' called with result: 1
    'C.fact' called with result: 1
'C.fact' called with result: 2
2
</pre>
<p>You may easily check that calling <tt class="literal"><span class="pre">C().fact</span></tt> will work too.</p>
<p>Under the hood the syntax</p>
<blockquote>
<pre class="literal-block">
[classmethod,tracedmethod]
</pre>
</blockquote>
<p>generates a <tt class="literal"><span class="pre">classmethodtracedmethod</span></tt> class obtained via
multiple inheritance:</p>
<pre class="doctest-block">
&gt;&gt;&gt; type(C.__dict__['fact'])
&lt;class 'safetype.classmethodtracedmethod'&gt;
</pre>
<p>Notice that the order <em>does</em> matter and using the docstring 
&quot;[tracedmethod,classmethod]&quot; will not work:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class D:
...     &quot;[Decorated]&quot;
...     def f(cls):
...         &quot;[tracedmethod,classmethod]&quot;
&gt;&gt;&gt; D.f()
Traceback (most recent call last):
  ...
TypeError: unbound method tracedmeth() must be called with D instance as first argument (got nothing instead)
</pre>
<p>The problem here is that <tt class="literal"><span class="pre">tracedmethod.get</span></tt> returns a method-wrapper object
which expects a D instance as first argument whereas it gets <tt class="literal"><span class="pre">None</span></tt> since
it is called from the class. On the other hand,</p>
<pre class="doctest-block">
&gt;&gt;&gt; D().f()
Calling 'D.f' with arguments &lt;D instance&gt;(){} ...
'D.f' called with result: None
</pre>
<p>will work. When <tt class="literal"><span class="pre">classmethod</span></tt> precedes <tt class="literal"><span class="pre">tracedmethod</span></tt>, then
<tt class="literal"><span class="pre">classmethod</span></tt> passes to <tt class="literal"><span class="pre">tracedmeth</span></tt> a non-empty first argument,
i.e. the calling class, even when called from the instance:</p>
<pre class="doctest-block">
&gt;&gt;&gt; C().fact(2)
Calling 'C.fact' with arguments &lt;class C[Decorated]&gt;(2,){} ...
    Calling 'C.fact' with arguments &lt;class C[Decorated]&gt;(1,){} ...
        Calling 'C.fact' with arguments &lt;class C[Decorated]&gt;(0,){} ...
        'C.fact' called with result: 1
    'C.fact' called with result: 1
'C.fact' called with result: 2
2
</pre>
<p>If we try to trace a staticmethod, we will get a different error with
the order &quot;tracedmethod, staticmethod&quot;:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class F(object):
...    &quot;[Decorated]&quot;
...    def fact(n):
...        &quot;[tracedmethod,staticmethod]&quot;
...        if n==0: return 1
...        else: return n*F.fact(n-1)
&gt;&gt;&gt; F.fact(2)
Traceback (most recent call last):
  ...
TypeError: unbound method tracedmeth() must be called with F instance as first argument (got int instance instead)
</pre>
<p>The message is self-explanatory.</p>
<p>On the other hand, composing the decorators in the order
&quot;[tracedmethod,staticmethod]&quot; will work just fine.</p>
<p>It is possible to compose class decorators just as method decorators,
by using the docstring syntax: for instance we may create a class
which is both <tt class="literal"><span class="pre">Decorated</span></tt> and <tt class="literal"><span class="pre">Logged</span></tt> and by trivially writing</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C: 
...     &quot;[Decorated,Logged]&quot;
...     def f(): 
...         &quot;[staticmethod]&quot;
...         return 'it works!'
&lt;class C[DecoratedLogged]&gt; created
&gt;&gt;&gt; C().f()
'it works!'
</pre>
</div>
<div class="section" id="diving-into-magic">
<h2><a class="toc-backref" href="#id12" name="diving-into-magic">Diving into magic</a></h2>
<p>If you never use metaclasses, this part can be safely skipped. On the
other hand, if you are a metaclass user, you <em>must</em> read this section
in order to keep your code working.</p>
<p>The <tt class="literal"><span class="pre">decorators</span></tt> module provide a <tt class="literal"><span class="pre">ClassDecorator</span></tt> metaclass which 
converts a regular (both old style or new style) class in a class with 
the ability to recognize magic docstrings. Under the hood, the 
<tt class="literal"><span class="pre">decorators.enhance_classes()</span></tt> trick works by decorating the 
<tt class="literal"><span class="pre">object</span></tt> class with <tt class="literal"><span class="pre">decorators.ClassDecorator</span></tt> and by setting 
the custom metaclass to <tt class="literal"><span class="pre">decorators.ClassDecorator</span></tt> and it is 
equivalent to</p>
<blockquote>
<pre class="literal-block">
import decorators
object=decorators.ClassDecorator(object) # decorates new style classes
__metaclass__= decorators.ClassDecorator # decorates old style classes
</pre>
</blockquote>
<p>If you want the magic to work only for new style classes only, you may 
forget the second line; if you want the magic to work for old style 
classes only, you may forget the first line.</p>
<p>The <tt class="literal"><span class="pre">decorators.enhance_classes(&quot;[SomeClassDec]&quot;)</span></tt> syntax looks at the
magic docstring and executes something like</p>
<blockquote>
<pre class="literal-block">
import decorators
object=decorators.SomeClassDec(object) # decorates all new style classes
__metaclass__= decorators.SomeClassDec # decorates all old style classes
</pre>
</blockquote>
<p>The problem with the <tt class="literal"><span class="pre">enhance_classes()</span></tt> syntaxes is that it is
not 100% safe under metaclass conflicts. In order to explain the issue,
let me give an example.</p>
<p>Suppose we enhance the <tt class="literal"><span class="pre">object</span></tt> class in the interpreter namespace:</p>
<pre class="doctest-block">
&gt;&gt;&gt; import decorators; decorators.enhance_classes()
</pre>
<p>making it an instance of <tt class="literal"><span class="pre">ClassDecorator</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; object.__class__ 
&lt;class 'decorators.ClassDecorator'&gt;
</pre>
<p>Now, if we naively create a custom metaclass <tt class="literal"><span class="pre">M</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class M(type): 
...     &quot;Some non-trivial code here...&quot; 
</pre>
<p>and we try to use it to enhance a new style class <tt class="literal"><span class="pre">NwithM</span></tt>, we will get a
conflict:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class NwithM(object): __metaclass__=M # does not work!
...
Traceback (most recent call last):
  ...
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
</pre>
<p>The problem is that the previous line tries to create a class <tt class="literal"><span class="pre">NwithM</span></tt> 
which should have both metaclasses <tt class="literal"><span class="pre">ClassDecorator</span></tt> and <tt class="literal"><span class="pre">M</span></tt>: 
a conflict follows.</p>
<p>Fortunately, the decorators module imports the <tt class="literal"><span class="pre">type</span></tt> metaclass from
my <tt class="literal"><span class="pre">safetype</span></tt> module just to avoid this kind of problems. If we
derive <tt class="literal"><span class="pre">M</span></tt> from <tt class="literal"><span class="pre">decorators.type</span></tt> (which is really <tt class="literal"><span class="pre">safetype.type</span></tt>)
the conflict is automagically avoided:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class M(decorators.type):
...     &quot;This metaclass is conflict-proof&quot;
&gt;&gt;&gt; class NwithM(object): # it works!
...     __metaclass__=M
</pre>
<p>The reason why the conflict is avoided is that the <tt class="literal"><span class="pre">safetype</span></tt> module
(which makes use of really <em>deep</em> metaclass magic) automatically
creates the composed class <tt class="literal"><span class="pre">MClassDecorator</span></tt> by multiply inheriting
from <tt class="literal"><span class="pre">M</span></tt> and from <tt class="literal"><span class="pre">ClassDecorator</span></tt>. Then, <tt class="literal"><span class="pre">NwithM</span></tt> can be safely 
created as an instance of <tt class="literal"><span class="pre">safetype.MClassDecorator</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; type(NwithM)
&lt;class 'safetype.MClassDecorator'&gt;
</pre>
<p>The situation with old style classes is worse since
apparently</p>
<pre class="doctest-block">
&gt;&gt;&gt; class OwithM: # old style class with metaclass M
...     __metaclass__=M
...     def sm(): 
...         &quot;[staticmethod]&quot;
</pre>
<p>gives no error, but actually <tt class="literal"><span class="pre">M</span></tt> overrides 
<tt class="literal"><span class="pre">ClassDecorator</span></tt>, so <tt class="literal"><span class="pre">OwithM</span></tt> will not recognize magic docstrings:</p>
<pre class="doctest-block">
&gt;&gt;&gt; type(OwithM)
&lt;class 'M'&gt;
&gt;&gt;&gt; OwithM.sm()
Traceback (most recent call last):
  ...
TypeError: unbound method sm() must be called with OwithM instance as first argument (got nothing instead)
</pre>
<p>The simpler solution is to convert <tt class="literal"><span class="pre">OwithM</span></tt> in a new style class:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class NwithM(OwithM,object):
...     __metaclass__=M
...     def sm():
...         &quot;[staticmethod]&quot;
&gt;&gt;&gt; type(NwithM) 
&lt;class 'safetype.MClassDecorator'&gt;
</pre>
<p>Now <tt class="literal"><span class="pre">NwithM</span></tt> is not decorated since it does miss a magic docstring, but
it provides the ability to recognizing magic docstrings, so <tt class="literal"><span class="pre">NwithM</span></tt>
subclasses with a &quot;[Decorated]&quot; docstring will be decorated:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class E(NwithM): 
...     &quot;[Decorated]&quot;
...     def cm(cls):
...         &quot;[classmethod]&quot;
...         print '.cm() called from',cls
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; E.cm() # it works
.cm() called from &lt;class E[MClassDecoratorDecorated]&gt;
</pre>
<p>Notice that <tt class="literal"><span class="pre">sm</span></tt> was defined in <tt class="literal"><span class="pre">NwithM</span></tt>, the undecorated class: therefore
it is not decorated:</p>
<pre class="doctest-block">
&gt;&gt;&gt; E.sm() # correctly, does not work
Traceback (most recent call last):
  ...
TypeError: unbound method sm() must be called with E instance as first argument (got nothing instead)
</pre>
<p>The error message says that <tt class="literal"><span class="pre">sm</span></tt> is an unbound method and not a 
static method.</p>
<p>It is possible to go even deeper in <strong>black</strong> magic, and to decorate all 
the new style classes in <em>all</em> modules, by decorating the 
<tt class="literal"><span class="pre">__builtin__.object</span></tt>. Still, naively redefining the <tt class="literal"><span class="pre">__builtin__object</span></tt> 
class is risky, since it will induce metaclass conflicts in other modules 
using metaclasses. In other words, it will work only if you import modules 
not using metaclasses, or modules using metaclasses safely, i.e. modules 
taking care of possible conflicts by using <tt class="literal"><span class="pre">safetype.type</span></tt> as base metaclass.
If you really enjoy black magic, you may solve the problem by 
redefining the <tt class="literal"><span class="pre">__builtin__.type</span></tt> as  <tt class="literal"><span class="pre">safetype.type</span></tt>.
The <tt class="literal"><span class="pre">decorators</span></tt> module does not go so deep in dark magic, but still
there are cases where you may want to do it. In these cases you must be
explicit and redefine the builtins by hand, without help from the
module. For instance, one of my original motivation for the usage
of metaclasses/class decorators was to use them for debugging purposes.
For instance, I wanted to trace the execution of methods in
complicate inheritance hierarchies, <em>without changing the source code</em>.
For simple situations, i.e. in absence of inheritance and of pre-existing
metaclasses, the function <tt class="literal"><span class="pre">import_with_metaclass</span></tt> discussed in the
<a class="reference" href="http://www-106.ibm.com/developerworks/library/l-pymeta.html">first paper on metaclasses</a> written in collaboration with David Mertz, works 
fine but in general the implementation of a working <tt class="literal"><span class="pre">import_with_metaclass</span></tt>
is cumbersome. For debugging purposes, the quick and dirty way can be a
good enough way, so let me show how we can redefine the builtins <tt class="literal"><span class="pre">object</span></tt> and
<tt class="literal"><span class="pre">type</span></tt> <em>before</em> importing the module, in such a way to enhance <em>all</em>
its classes with tracing capabilities.</p>
<p>Let me start from a module using an unsafe metaclass <tt class="literal"><span class="pre">M</span></tt>, such that it
cannot be traced trivially by decorating its classes <em>after</em> the import;
moreover there is an inheritance hierarchy, such that it cannot be
traced correctly by naively decorating all the classes one after the
other (unless one modifies the original source code, but this forbidden
by the rules of the game ;)</p>
<blockquote>
<pre class="literal-block">
#&lt;tracing.py&gt;

&quot;&quot;&quot;
This is a pre-existing module not using decorators but using multiple
inheritance and unsafe metaclasses. We want to trace it for debugging 
purposes.
&quot;&quot;&quot;
 
class M(type): 
    &quot;There should be some non-trivial code here&quot;

class B(object): 
    def __init__(self):
        super(B,self).__init__()

class D(object): 
    __metaclass__=M
    def __init__(self):
        super(D,self).__init__()

class E(B,D):
    def __init__(self):
        super(E,self).__init__()

 #&lt;/tracing.py&gt;
</pre>
</blockquote>
<p>Everything works is we modify the builtins before importing the module:</p>
<pre class="doctest-block">
&gt;&gt;&gt; import __builtin__
&gt;&gt;&gt; __object__=__builtin__.object # the original 'object' class
&gt;&gt;&gt; __builtin__.object=customdec.Traced('tracedobject',(),{}) 
&gt;&gt;&gt; __builtin__.type=customdec.type # a safe 'type' class
</pre>
<p>Now, when we import the module, all the classes <tt class="literal"><span class="pre">M</span></tt>, <tt class="literal"><span class="pre">B</span></tt>, <tt class="literal"><span class="pre">D</span></tt> and <tt class="literal"><span class="pre">E</span></tt>
will be created starting for the tricked builtins, so they will be traced
and safe under conflicts. For instance, let me show that <tt class="literal"><span class="pre">E</span></tt> is created
with a conflict safe <tt class="literal"><span class="pre">MTraced</span></tt> metaclass:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from tracing import E
&gt;&gt;&gt; print E
&lt;class E[MTraced]&gt;
</pre>
<p>This shows that the <tt class="literal"><span class="pre">__init__</span></tt> methods are traced indeed and shows the
Method Resolution Order:</p>
<pre class="doctest-block">
&gt;&gt;&gt; e=E()
Calling 'E.__init__' with arguments &lt;E instance&gt;(){} ...
    Calling 'B.__init__' with arguments &lt;E instance&gt;(){} ...
        Calling 'D.__init__' with arguments &lt;E instance&gt;(){} ...
        'D.__init__' called with result: None
    'B.__init__' called with result: None
'E.__init__' called with result: None
</pre>
<p>This works, indeed. At the end, one should not forget to restore
the standard builtins, otherwise it will trace <em>all</em> the classes
created thereafter.</p>
<pre class="doctest-block">
&gt;&gt;&gt; __builtin__.object=__object__ # restore the __builtin__
&gt;&gt;&gt; __builtin__.type=decorators.__type__ # restore the __builtin__
</pre>
<p>At the end, I will notice that it is possible to solve the problem more
nicely, without redefining the builtins, but I will discuss the solution
elsewhere ;)</p>
</div>
<div class="section" id="advanced-usage">
<h2><a class="toc-backref" href="#id13" name="advanced-usage">Advanced usage</a></h2>
<p>Whereas the average programmer is expected to use the <tt class="literal"><span class="pre">decorated()</span></tt> 
and <tt class="literal"><span class="pre">enhance_classes()</span></tt> functions only, the <tt class="literal"><span class="pre">decorators</span></tt> module provides 
facilities which may be useful to the advanced programmer.</p>
<p>The simplest is an utility function which retrieves the list of
recognized decorators, <tt class="literal"><span class="pre">decorators.getdec()</span></tt>. The precise syntax is
<tt class="literal"><span class="pre">decorators.getdec(docstring)</span></tt>, where <tt class="literal"><span class="pre">docstring</span></tt>
is a magic docstring, i.e. a bracketed comma-separated list 
of decorator names. For instance <tt class="literal"><span class="pre">decorators.getdec('[MethodDecorator]')</span></tt>
gives the list of all subclasses of <tt class="literal"><span class="pre">MethodDecorator</span></tt>, i.e. all method
decorators, whereas <tt class="literal"><span class="pre">decorators.getdec('[ClassDecorator]')</span></tt>
gives the list of the known class decorators. The utility of the function
is that it also returns decorators that have been automagically created:</p>
<pre class="doctest-block">
&gt;&gt;&gt; decorators.getdec(&quot;[classmethodtracedmethod]&quot;)
[&lt;class 'safetype.classmethodtracedmethod'&gt;]
</pre>
<p>It is even possible to use the comma notation:</p>
<pre class="doctest-block">
&gt;&gt;&gt; decorators.getdec(&quot;[classmethod,tracedmethod]&quot;)
[&lt;class 'safetype.classmethodtracedmethod'&gt;]
</pre>
<p>If you mispell a decorator name you get an helpful error message:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class E:
...     &quot;[Decorated]&quot;
...     def f():
...         &quot;[staticmeth]&quot;
Traceback (most recent call last):
  .. a cryptic traceback here ..
UnknownDecoratorError: staticmeth
</pre>
<p>By design, the <tt class="literal"><span class="pre">decorated</span></tt> function is quite limited, and does not 
decorate functions without magic docstrings. This is safe and also convenient 
for internal usage of the <tt class="literal"><span class="pre">decorated</span></tt> function in the <tt class="literal"><span class="pre">Decorated</span></tt> 
metaclass. Nevertheless, advanced users may want to have the ability 
of decorating functions by hand, without invoking <cite>decorators.decorated()`</cite>
and magic docstrings. This is possible, by calling the decorator directly.
For instance, here is how to convert a lambda function in a staticmethod:</p>
<pre class="doctest-block">
&gt;&gt;&gt; do_nothing=decorators.staticmethod(lambda:None)
&gt;&gt;&gt; print do_nothing # ``do_nothing`` is a static method
&lt;staticmethod:&lt;lambda&gt;&gt;
</pre>
<p>The most convenient usage of this feature is in the composition of decorators. 
For instance, we may compose the just defined <tt class="literal"><span class="pre">staticmethod</span></tt> with a 
<tt class="literal"><span class="pre">chattymethod2</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; chattystatic=customdec.chattymethod2(do_nothing)
&gt;&gt;&gt; print chattystatic
&lt;chattymethod2staticmethod:&lt;lambda&gt;&gt;
</pre>
<p>The syntax</p>
<blockquote>
<tt class="literal"><span class="pre">decorator1(decorator2(obj))</span></tt></blockquote>
<p>automagically creates a composed class <tt class="literal"><span class="pre">decorator1decorator2</span></tt> in the
<tt class="literal"><span class="pre">safetype</span></tt> module (or recycle it, if <tt class="literal"><span class="pre">decorator1decorator2</span></tt> has 
been already created) and it is equivalent to</p>
<blockquote>
<tt class="literal"><span class="pre">decorator1decorator2(obj)</span></tt></blockquote>
<p>Here is the check that everything works:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class B: 
...     chattystatic=chattystatic
&gt;&gt;&gt; B.chattystatic()
calling &lt;chattymethod2staticmethod:&lt;lambda&gt;&gt; from &lt;class 'B'&gt;
</pre>
<p>Notice that <tt class="literal"><span class="pre">chattystatic</span></tt> does not know the class where it 
is defined:</p>
<pre class="doctest-block">
&gt;&gt;&gt; chattystatic.__klass__
&lt;class 'safetype.?'&gt;
</pre>
<p>unless the <tt class="literal"><span class="pre">__klass__</span></tt> attribute is explicitly set.</p>
<p>This is the hierarchy:</p>
<pre class="doctest-block">
&gt;&gt;&gt; for C in type(chattystatic).mro(): print C
...
&lt;class 'safetype.chattymethod2staticmethod'&gt;
&lt;class 'customdec.chattymethod2'&gt;
&lt;class 'customdec.chattymethod'&gt;
&lt;class 'decorators.staticmethod'&gt;
&lt;class 'decorators.MethodDecorator'&gt;
&lt;class 'decorators.Decorator'&gt;
&lt;type 'object'&gt;
</pre>
<p>One can also compose classes by hand, by using class decorators:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C: 
...     &quot;[Logged]&quot;
...     def f(): &quot;[staticmethod]&quot;
...
&lt;class 'C'&gt; created
&gt;&gt;&gt; C=customdec.Traced(C)
&lt;class C[TracedLogged]&gt; created
</pre>
<p>The <tt class="literal"><span class="pre">decorators.enhance_classes(&lt;classdecorator&gt;)</span></tt> syntax performs
the composition automagically:</p>
<blockquote>
<pre class="literal-block">
#&lt;example8.py&gt;

from example2 import identity,name
import inspect, decorators; decorators.enhance_classes(&quot;[Decorated]&quot;)

class C1: # automagically converted to a Decorated class
    identity=identity 

class C2: # automagically converted to a DecoratedLogged class
    &quot;[Logged]&quot;
    name=name

c1=C1() # C1 instance
c2=C2() # C2 instance

#&lt;/example8.py&gt;
</pre>
</blockquote>
<p>In this example the class <tt class="literal"><span class="pre">C2</span></tt> has already a magic docstring. This means that
<tt class="literal"><span class="pre">C2</span></tt> has to be enhanced both from <tt class="literal"><span class="pre">Logged</span></tt> and from <tt class="literal"><span class="pre">Decorated</span></tt>.
This is done by automagically creating a <tt class="literal"><span class="pre">DecoratedLogged</span></tt> class
decorator:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from example8 import C1,C2,c1,c2 
&lt;class C2[DecoratedLogged]&gt; created
</pre>
<p>The second line is printed because of the logging capabilities of <tt class="literal"><span class="pre">C2</span></tt>.
Moreover, since <tt class="literal"><span class="pre">C2</span></tt> is decorated too, the following will work:</p>
<pre class="doctest-block">
&gt;&gt;&gt; assert C2.name() == 'C2'
&gt;&gt;&gt; assert c2.name() == 'C2' 
</pre>
<p>Idem for <tt class="literal"><span class="pre">C1</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; assert C1.identity(1) == 1
&gt;&gt;&gt; assert c1.identity(1) == 1 
</pre>
</div>
</div>
<div class="section" id="the-implementation">
<h1><a class="toc-backref" href="#id14" name="the-implementation">The implementation</a></h1>
<p>This part can be safely skipped, unless you are a <em>really</em> curious and
you want to know how the implementation works.</p>
<p>The module is rather short (less than 150 lines if you skip comments and
docstrings) but far from being trivial, since it is based on extensive 
usage of metaclass wizardry. Moreover,
it invokes the <tt class="literal"><span class="pre">safetype</span></tt> module to solve metaclass conflicts, and
<tt class="literal"><span class="pre">safetype</span></tt> contains 50 lines of <em>really</em> deep metaclass wizardry.</p>
<blockquote>
<div class="figure">
<p><img alt="decorators.png" src="decorators.png" /></p>
</div>
</blockquote>
<p>The main class-metaclass hierarchy is represented in the figure, where
boxes denote classes and ovals denote metaclasses; instantiation is
denoted by dashed green lines whereas inheritance is denoted by continuous
blue lines.</p>
<p>For instance, this is the Method Resolution Order for the <tt class="literal"><span class="pre">Decorated</span></tt>
metaclass:</p>
<pre class="doctest-block">
&gt;&gt;&gt; for i,c in enumerate(decorators.Decorated.__mro__): 
...     print i,c,&quot;[%s]&quot; % type(c).__name__
0 &lt;class 'decorators.Decorated'&gt; [MetaDecorator]
1 &lt;class 'decorators.ClassDecorator'&gt; [MetaDecorator]
2 &lt;class 'safetype.safetype'&gt; [type]
3 &lt;type 'type'&gt; [type]
4 &lt;class 'decorators.Decorator'&gt; [MetaDecorator]
5 &lt;type 'object'&gt; [type]
</pre>
<p><tt class="literal"><span class="pre">Decorator</span></tt> is the mother of all decorators. Its main purpose it to
provide the <tt class="literal"><span class="pre">MetaDecorator</span></tt>
metaclass to all decorators.</p>
<p>The <tt class="literal"><span class="pre">safetype</span></tt> metaclass, imported from the <tt class="literal"><span class="pre">safetype</span></tt> module,
ensures that class decorators can generate classes without incurring 
in conflicts.</p>
<p>Since class decorators are metaclasses,
<tt class="literal"><span class="pre">MetaDecorator</span></tt> is actually a meta-metaclass with respect to
instances of decorated classes. For this reason if</p>
<pre class="doctest-block">
&gt;&gt;&gt; C=decorators.ClassDecorator('C',(),{})
</pre>
<p>then</p>
<pre class="doctest-block">
&gt;&gt;&gt; C.__class__
&lt;class 'decorators.ClassDecorator'&gt;
</pre>
<p>but</p>
<pre class="doctest-block">
&gt;&gt;&gt; C.__metaclass__ 
&lt;class 'decorators.MetaDecorator'&gt;
</pre>
<p>since the <tt class="literal"><span class="pre">C.__metaclass__</span></tt> attribute is inherited from <tt class="literal"><span class="pre">Decorator</span></tt>.</p>
<p>On the other hand, <tt class="literal"><span class="pre">MetaDecorator</span></tt> is a simple metaclass with
respect to instances of decorated methods.</p>
<p>The implementation is relatively smart. Consider for instance the case of
the <tt class="literal"><span class="pre">logged</span></tt> example. In that example class <tt class="literal"><span class="pre">D</span></tt> was a subclass 
of a tricked <tt class="literal"><span class="pre">object</span></tt> class, enhanced by <tt class="literal"><span class="pre">ClassDecorator</span></tt>. Moreover <tt class="literal"><span class="pre">D</span></tt> 
had a <tt class="literal"><span class="pre">Logged</span></tt> docstring. Therefore it should have been an instance of a 
<tt class="literal"><span class="pre">ClassDecoratorLogged</span></tt> metaclass. But logged was
a subclass of <tt class="literal"><span class="pre">ClassDecorator</span></tt>, therefore it already had all the features
of <tt class="literal"><span class="pre">ClassDecorator</span></tt> and it would have been redundant to create 
<tt class="literal"><span class="pre">ClassDecoratorLogged</span></tt>, when``Logged`` would have been enough. 
So <tt class="literal"><span class="pre">Logged</span></tt> was used and <tt class="literal"><span class="pre">ClassDecoratorLogged</span></tt> was never created. 
All this magic is in the <tt class="literal"><span class="pre">safetype.remove_redundant(*classes)</span></tt> function.</p>
<p>The current implementation does not make any attempt of optimization and
there may be alternative implementations faster or more memory efficient.
At this experimental level I didn't care to explore about performances 
issues. Probably, they do not  matter unless one has to decorate
thousands or millions of functions and classes.</p>
<p>Finally, a word about bugs. The <tt class="literal"><span class="pre">decorators</span></tt> module is fairly sophisticated,
therefore whereas I can guarantee that it passes my test suite (which involves
~200 tests, most of them extracted from the documentation you are reading), 
I cannot guarantee that it is correct. If somebody finds a bug or an 
unexpected behavior, please let me know and I will fix it or document it.</p>
<!-- References: -->
<div class="section" id="module-decorators">
<h2><a class="toc-backref" href="#id15" name="module-decorators">Module <tt class="literal"><span class="pre">decorators</span></tt></a></h2>
<p>A module to implement pep318 (decorator syntax) via magic doctrings.
For the full documentation see
<a class="reference" href="http://www.phyast.pitt.edu/~micheles/python/decorators.html">http://www.phyast.pitt.edu/~micheles/python/decorators.html</a> .</p>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id16" name="id3">Metaclasses</a></h3>
<p><tt class="literal"><span class="pre">metaclass</span> <span class="pre">ClassDecorator(type,Decorator):</span></tt></p>
<blockquote>
Metaclass callable with one or three arguments, having its calling
syntax redefined by <tt class="literal"><span class="pre">MetaDecorator</span></tt>.</blockquote>
<p><tt class="literal"><span class="pre">metaclass</span> <span class="pre">Decorated(ClassDecorator):</span></tt></p>
<blockquote>
<p>Metaclass which decorates the methods of its instances according
to the docstrings. It redefines <tt class="literal"><span class="pre">__str__</span></tt> on
its instances and the default <tt class="literal"><span class="pre">__str__</span></tt> on the instances of its
instances.</p>
<p><tt class="literal"><span class="pre">__str__(cls):</span></tt></p>
<blockquote>
Redefine the printing representation of classes</blockquote>
</blockquote>
<p><tt class="literal"><span class="pre">metaclass</span> <span class="pre">safetype(type):</span></tt></p>
<blockquote>
Overrides the <tt class="literal"><span class="pre">__new__</span></tt> method of the <tt class="literal"><span class="pre">type</span></tt> metaclass, making the
generation of classes conflict-proof.</blockquote>
<p><tt class="literal"><span class="pre">metaclass</span> <span class="pre">MetaDecorator(type):</span></tt></p>
<blockquote>
<p>Metaclass inducing a certain amount of magic on decorators:</p>
<ol class="arabic simple">
<li>Each time a decorator is defined in any module, it is stored in
MetaDecorator.dic and MetaDecorator.ls.</li>
<li>If the (method) decorator has a 'get' method, a '__get__' method
is automagically created as an alias to 'get'.</li>
<li>Decorators calls are dispatched to the decorator _call_
classmethod.</li>
</ol>
<p><tt class="literal"><span class="pre">__call__(dec,*args):</span></tt></p>
<blockquote>
This is the heart of the module. Infers the correct decorator class
from <tt class="literal"><span class="pre">dec</span></tt> and the docstring and creates the correct decorator object.
Returns the original object if <tt class="literal"><span class="pre">dec</span></tt> is the trivial <tt class="literal"><span class="pre">Decorator</span></tt>
class and no docstring is found.</blockquote>
<p><tt class="literal"><span class="pre">__init__(dec,*args):</span></tt></p>
<blockquote>
Update the metaclass attributes <tt class="literal"><span class="pre">dic</span></tt> and <tt class="literal"><span class="pre">ls</span></tt>;
alias <tt class="literal"><span class="pre">get</span></tt> to <tt class="literal"><span class="pre">__get__</span></tt>.</blockquote>
</blockquote>
</div>
<div class="section" id="classes">
<h3><a class="toc-backref" href="#id17" name="classes">Classes</a></h3>
<p><tt class="literal"><span class="pre">class</span> <span class="pre">UnknownDecoratorError(Exception):</span></tt></p>
<blockquote>
The name says it all.</blockquote>
<p><tt class="literal"><span class="pre">class</span> <span class="pre">Decorator(object):</span></tt></p>
<blockquote>
Instance of MetaDecorator and mothers of all decorators. When called
in the form <tt class="literal"><span class="pre">Decorator(obj)</span></tt> with obj having a magic docstring, it returns
a decorated object; otherwise it returns the original object.</blockquote>
<p><tt class="literal"><span class="pre">class</span> <span class="pre">staticmethod(MethodDecorator):</span></tt></p>
<blockquote>
Decorator, converts a function in a staticmethod</blockquote>
<p><tt class="literal"><span class="pre">class</span> <span class="pre">MethodDecorator(Decorator):</span></tt></p>
<blockquote>
<p>Descriptor class callable with a function or a descriptor object
as argument. It defines a default printing representation on method
decorators objects and a default <tt class="literal"><span class="pre">get</span></tt>  method. All the rest is
provided by the metaclass <tt class="literal"><span class="pre">MetaDecorator</span></tt>.</p>
<p><tt class="literal"><span class="pre">get(self,obj,cls=None):</span></tt></p>
<blockquote>
aliased to __get__ by the metaclass, to be overridden</blockquote>
<p><tt class="literal"><span class="pre">__str__(self):</span></tt></p>
<blockquote>
Printing representation of kind &lt;decoratorclass:functionname&gt;</blockquote>
<p><tt class="literal"><span class="pre">__init__(self,objfunc):</span></tt></p>
<blockquote>
objfunc is a decorator object or a function</blockquote>
</blockquote>
<p><tt class="literal"><span class="pre">class</span> <span class="pre">classmethod(MethodDecorator):</span></tt></p>
<blockquote>
Decorator, converts a function in a classmethod</blockquote>
</div>
<div class="section" id="functions">
<h3><a class="toc-backref" href="#id18" name="functions">Functions</a></h3>
<p><tt class="literal"><span class="pre">enhance_classes(magicstring='[ClassDecorator]'):</span></tt></p>
<blockquote>
Enhances all the classes in the caller module with a metaclass
built from the given magicstring.</blockquote>
<p><tt class="literal"><span class="pre">remove_redundant(bases):</span></tt></p>
<blockquote>
<p>Returns a tuple of non-redundant base classes.
Given a sequence of base classes, a class is redundant if it is duplicated
or if it is implied by the others, i.e. it is an ancestor of at least one
of the other classes. For instance, if <tt class="literal"><span class="pre">C</span></tt> is derived from <tt class="literal"><span class="pre">B</span></tt>, in the
sequence <tt class="literal"><span class="pre">C,B</span></tt> the class <tt class="literal"><span class="pre">B</span></tt> is redundant, since all its features are
already provided by <tt class="literal"><span class="pre">C</span></tt>. Therefore <tt class="literal"><span class="pre">B</span></tt>
is removed and <tt class="literal"><span class="pre">remove_redundant</span></tt> returns the tuple <tt class="literal"><span class="pre">(C,)</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class B(object): pass
...
&gt;&gt;&gt; class C(B): pass
...
&gt;&gt;&gt; import safetype; safetype.remove_redundant([C,B])
(&lt;class 'C'&gt;,)
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">compose(dclasses,*defaultclasses):</span></tt></p>
<blockquote>
Retrieves or creates a decorator for a tuple of decorators. If
defaults decorators are given, they get the precedence. It removes
redundant classes.</blockquote>
<p><tt class="literal"><span class="pre">instance_str(self):</span></tt></p>
<blockquote>
Redefines the printing representation of simple objects</blockquote>
<p><tt class="literal"><span class="pre">getdec(magicstring=&quot;[Decorator]&quot;):</span></tt></p>
<blockquote>
Given a magicstring describing a valid decorator name, returns the list
of its subclasses. By default returns the full list of decorators.</blockquote>
<p><tt class="literal"><span class="pre">decorate(objdict):</span></tt></p>
<blockquote>
Takes an object with a dictionary and decorates all its functions
and classes according to their docstrings.</blockquote>
<p><tt class="literal"><span class="pre">decorators_in(docstring):</span></tt></p>
<blockquote>
Takes a docstring and returns a (possibly empty) tuple of decorator
classes.</blockquote>
</div>
</div>
</div>
</div>
<hr class="footer"/>
<div class="footer">
<a class="reference" href="decorators.txt">View document source</a>.
Generated on: 2003-09-30 10:07 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
