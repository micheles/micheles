Implementing PEP 318 (decorators)
======================================================================

 :Module: decorators
 :Version: 0.5
 :Author: Michele Simionato
 :e-mail: MicheleSimionato@libero.it
 :Licence: Python-like
 :Disclaimer: This is experimental code. Use it at your own risk!

.. contents::

Having plenty of free time in these days, I have finished an old 
project of mine, the implementation of PEP 318 in pure Python.
 
Here is the rationale:

* some kind of decorator syntax is scheduled to go in Python 2.4,
  therefore it is interesting to play with the concept;

* it is nice to play with decorators now, without having to
  wait for one year or so;

* it is much easier levelto experiment with a pure Python implementation
  than with a C implementation;

* the implementation can be seen as an exercise on modern Python
  programming and may be valuable to people wanting to study the most
  advanced new constructs in Python 2.2 (descriptors_, metaclasses_, 
  `cooperative methods`_, etc.)

Basics
--------------------------------------------------------------------

PEP 318 has the goal of providing a nice syntactic sugar for expressions like

 ::

  def identity(x):
      return x
  identity=staticmethod(identity)

or

 ::

  def name(cls):
     return cls.__name__
  name=classmethod(name)

which are pretty verbose. It is clear that having new syntax (as 
for instance the proposed square bracket notation)

 ::

  def identity(x)[staticmethod]:
      return x

  def name(cls)[classmethod]:
      return cls.__name__

involves changing the grammar and modifying the interpreter at the
C level. This means a lot of work. Fortunately, it is possible to 
have the same effect without changing the Python grammar. 
The idea is to use magic docstrings like this:

 ::

  def identity(x):
      "[staticmethod]"
      return x

  def name(cls):
      "[classmethod]"
      return cls.__name__

The implementation is able to recognize such docstrings
and to automagically convert those methods in decorators. 

Decorators are nothing else than a sophisticated kind of wrappers.
The ``decorators`` module provides support both for method decorators,
which wrap functions and class decorator, which wrap classes. 
``staticmethod`` and ``classmethod`` are two examples of already existing
method decorators (actually my implementation rewrites them, but let me 
pass on this detail). Technically speaking, method decorators are classes 
taking a single function as input and producing a descriptor object 
as output (properties are not decorators according to this definition, 
since they take four functions as input, ``get, set, del_`` and ``doc``). 
Descriptors are objects with a ``__get__`` method; they are quite 
sophisticated, but fortunately they have been wonderfully explained by 
Raymond Hettinger already, so  I am allowed to skip on this point ;). 
A knowledge of descriptors is not needed in order to use the ``decorator`` 
module; however it is welcomed for advanced users wanting to implement
custom method decorators. 
Class decorators are metaclasses taking a class as imput and returning
a decorated class as output. A good understanding of metaclasses is needed 
in order to be able to write custom class decorators, but no knowledge
at all is required in order to use the pre-defined class decorators
provided by the module.
Finally, the module is meant to be extensible; so one could 
define new kind of decorators. For instance, the original version of
the module also had the concept of module decorators; however I have cut 
down that part in order to keep the module short. 

Admittedly, the implementation 
is not for the faint of heart, nevertheless I have tried to make the 
basic usage easy and simple to understand.

Simple usage of decorators
------------------------------------------------------------------------

Before talking about the implementation details, I will show
how the ``decorators`` module works in practice. The simplest and safest
usage is by means of the ``decorators.decorated()`` function, which
takes an object (a function or a class) and checks its docstring: if 
a magic docstring is found, it returns a decorated version of the object, 
otherwise it returns the original object. Using ``decorators.decorated()``
is simple but verbose, so magic shortcuts will be discussed in the next 
section.

Here, let me give an example, showing that method decorators work both for 
`new style classes and old style classes`_:

 ::

  #<example1.py>

  import decorators
 
  def do_nothing(self):
     "No magic docstring here"
  dec_do_nothing=decorators.decorated(do_nothing)

  def identity(x):
      "[staticmethod]"
      return x
  dec_identity=decorators.decorated(identity) 

  def name(cls):
      "[classmethod]"
      return cls.__name__
  dec_name=decorators.decorated(name)

  class OldStyle:
      do_nothing=dec_do_nothing
      identity=dec_identity

  class NewStyle(object):
      name=dec_name

  o=OldStyle() # creates an old style instance
  n=NewStyle() # creates a new style instance

  #</example1.py>

In this example, both ``dec_identity`` and ``dec_name`` are decorator objects,
i.e. descriptors modifiying the attribute access. It is easy to recognize
decorators objects, since they have a re-defined printing representation:

>>> from example1 import *

>>> print dec_identity
<staticmethod:identity>

>>> print dec_name
<classmethod:name>

Now, let me check that ``dec_ identity`` works as a staticmethod,

>>> assert OldStyle.identity(1) == 1 # called from the class
>>> assert o.identity(1) == 1 # called from the instance

whereas ``dec_name`` works as a classmethod:

>>> assert NewStyle.name() == 'NewStyle' # called from the class
>>> assert n.name() == 'NewStyle' # called from the instance

On the other hand, ``do_nothing`` does not have a magic 
docstring, therefore it is not converted to a decorator object; 
actually it is *exactly* the original function:

>>> assert dec_do_nothing is do_nothing # not converted

Therefore it works without surprises:

>>> o.do_nothing() # does nothing, correct

For sake of convenience, I have re-implemented the built-in 
``staticmethod`` and ``classmethod``, so

>>> isinstance(dec_identity,staticmethod)
False

and

>>> isinstance(dec_name,classmethod)
False

but

>>> isinstance(dec_identity,decorators.staticmethod)
True

and

>>> isinstance(dec_name,decorators.classmethod)
True

It is possible to recognize method decorators since they provides 
a couple of special attributes:  

``__func__``, returning the function from which they originated

  >>> assert dec_identity.__func__ is identity
  >>> assert dec_name.__func__ is name

and ``__klass__``, returning the class where they where defined
 
  >>> dec_identity.__klass__
  <class 'decorators.?'>

The question mark here means that the definition class is unknown.

Decorating classes
----------------------------------------------------------------------

The problem with the approach described in the previous section 
is that it does not present any significant advantage over 
the already existing mechanism. A real step forward would be to
have classes with the ability of automatically converting their 
methods to method decorators according to the docstrings. 
This sounds a bit of magic, but actually can be done very simply 
by adding to the class a docstring starting with "[Decorated]"
and decorating the class. 
Here is an example:

 ::

  #<example2.py>

  from decorators import decorated
  from example1 import do_nothing,identity,name

  class B(object):
      "This is a regular class"

  B=decorated(B) # does nothing

  class C(B):
     "[Decorated]"
     do_nothing=do_nothing
     identity=identity
     name=name

  C=decorated(C) # regenerates the class converting methods in decorators
  c=C()

  #</example2.py>

Here is the testing:

>>> from example2 import *
>>> assert C.identity(1) == 1
>>> assert C.name() == 'C'
>>> assert c.identity(1) == 1 
>>> assert c.name() == 'C' 

Notice that adding ``identity`` after the class creation with the syntax 
``C.identity=identity`` would not work; 
``C.identity=decorators.decorated(identity)`` is required:

>>> C.identity=decorators.decorated(identity)
>>> C.identity(1) # it works
1

If a class misses the magic docstring, nothing happens:

>>> B # returns the original B
<class 'example2.B'>

The mechanism works for old style classes too:

 ::

  #<example2.py>

  class D: # old style
      "[Decorated]"
      def identity(x):
          "[staticmethod]"
          return x

  D=decorated(D)

  d=D()

  # test
  assert d.identity(1) == 1
  assert D.identity(1) == 1 

  #</example2.py>

Under the hood ``decorators.decorated()`` recognizes the class level
magic docstring "[Decorated]" and creates an instance of the 
``decorators.Decorated`` metaclass; incidentally, 
this converts old style classes in new style classes: 

>>> from example2 import D,d
>>> type(D) # D is an instance of decorator.Decorated
<class 'decorators.Decorated'>

Internally the metaclass invokes ``decorators.decorated()``
on the methods of its instances: this is why they becomes decorated
if a suitable docstring is found. By the way, if you mispell a
decorator name you get an helpful error message:

>>> class E:
...     "[Decorated]"
...     def f():
...         "[staticmeth]"
>>> E=decorators.decorated(E)
Traceback (most recent call last):
  .. a long and cryptic traceback here ..
UnknownDecoratorError: staticmeth

The enhancement provided by the metaclass includes a new default 
printing representation for both the class

>>> print D # returns the name of D and of its metaclass
<class D[Decorated]>

and its instances:

>>> print d
<D instance>

One can even forget the docstring in subclasses of decorated 
classes, since metaclasses are inherited:

>>> class E(D):
...     def name(cls):
...          "[classmethod]"
...          return cls.__name__
>>> print E.name()
E

This approach presents another advantage: the decorated methods know
the class where they were defined via the special attribute ``__klass__``:

>>> E.__dict__['name'].__klass__ # the class where 'name' is defined
<class 'E'>

This is useful for introspection and debugging purposes.

Adding magic
----------------------------------------------------------------------------

The problem of the previous approach is that one must explicitely
decorate the classes by hand, by invoking ``decorators.decorated()``
each time. However, it is possible to add more magic
and to decorate all the classes automatically. 
It is as easy as writing ``decorators.enhance_classes()``
on top of the module. Then all methods in all classes of the module 
with a magic docstring will be checked for magic docstrings and 
automagically decorated if needed. 
For instance, the previous example would be written

 ::

  #<example4.py>

  import decorators; decorators.enhance_classes()

  class C:
      "[Decorated]" # magic docstring here 
      def do_nothing(self):
         "No magic docstring here"

      def identity(x):
          "[staticmethod]"
          return x

  class D(object):
      "Undecorated" # no magic docstring here
      def name(cls):
          "[classmethod]"
          return cls.__name__

  c=C(); d=D()
 
  #</example4.py>

``C`` has a ``[Decorated]`` docstring, so its methods
are automatically decorated:

>>> from example4 import *
>>> assert c.do_nothing() is None
>>> assert C.identity(1) == 1
>>> assert c.identity(1) == 1 

On the other hand, since ``D`` misses a magic docstring,
its ``name`` method is not decorated:

>>> hasattr(D.__dict__['name'],'__func__') # not a decorator
False

Since ``D.name`` is a regular method and not a classmethod, ``D.name()``
gives an error:

>>> D.name()
Traceback (most recent call last):
  ...
TypeError: unbound method name() must be called with D instance as first argument (got nothing instead)

The trick works for classes containing inner classes, too:

 ::

  #<example5.py>

  import decorators; decorators.enhance_classes()

  class C:
      "[Decorated]" # required docstring 
      def identity(x):
          "[staticmethod]"
          return x
      class Inner:
          "[Decorated]" # required docstring   
          def name(cls):
              "[classmethod]"
              return cls.__name__


  assert C.identity(1) == 1
  assert C.Inner.name() == 'Inner'

  #</example5.py>

Under the hood, the magic works by enhancing the ``object`` class 
of the module with a ``decorators.ClassDecorator`` metaclass:

>>> import example5
>>> type(example5.object)
<class 'decorators.ClassDecorator'>

Notice that for safety reasons the enhancement is only on the module 
``object`` class, not on the ``__builtin__.object`` class. The problem
is that adding too much magic can be risky. 

The dangers of magic
-----------------------------------------------------------------------

For the sake of metaclass users, in this section I will point out the 
dangers of the  ``enhance_classes()`` syntax. On the other hand, if you 
never use metaclasses, you may safely skip to the following section.

The problem is that the  ``enhance_classes()`` syntax is not 100% safe, 
because of possible metaclass conflicts. 
Here is an example:

>>> import decorators; decorators.enhance_classes()

This line enhances the ``object`` class in the interpreter namespace:

>>> print object 
<class object[ClassDecorator]>

This shows that ``object`` is an instance of ``ClassDecorator``.

>>> class M(type): 
...     "Some non-trivial code here..." 

This line creates a custom metaclass we want to use to enhance our classes.

>>> class D(object): __metaclass__=M # does not work!
...
Traceback (most recent call last):
  ...
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases

The problem is that the previous line tries to create a class ``D`` 
which should have both metaclasses ``ClassDecorator`` and ``M``: 
a conflict follows.

Fortunately, the decorators module imports the ``makecls`` function from my
``noconflict`` module (described in the cookbook_)
just to avoid this kind of problems:

>>> class D(object):
...     __metaclass__=decorators.makecls(M)

Now the class has been safely created as an instance of the composed
class ``ClassDecoratorM``.

>>> type(D)
<class 'noconflict.ClassDecoratorM'>

If we want ``M`` to have the priority over ``ClassDecorator``, the
option ``priority=True`` makes the job:

>>> class D(object):
...     __metaclass__=decorators.makecls(M,priority=True)
>>> type(D)
<class 'noconflict.MClassDecorator'>

The situation for old style classes is worse, since

>>> class D:
...     __metaclass__=M
...     def sm(): 
...         "[staticmethod]"

apparently gives no error, but actually the metaclass ``M`` overrides 
``ClassDecorator``, so ``D`` will not recognize magic docstrings:

>>> type(D)
<class 'M'>
>>> D.sm()
Traceback (most recent call last):
  ...
TypeError: unbound method sm() must be called with D instance as first argument (got nothing instead)

Using ``decorators.makecls(M)`` will not help here (because of the way Python 
assigns metaclasses) and the only solution is to be completely explicit:

>>> class D:
...     __metaclass__=decorators.makecls(decorators.ClassDecorator,M)
...     def sm():
...         "[staticmethod]"
>>> type(D) 
<class 'noconflict.ClassDecoratorM'>

Now ``D`` is not decorated since it does miss a magic docstring, but
it provides the ability to recognizing magic docstrings, so ``D``
subclasses with a "[Decorated]" docstring will be decorated:

>>> class E(D): 
...     "[Decorated]"
...     def cm(cls):
...         "[classmethod]"
...         print '.cm() called from',cls

>>> E.cm() # it works
.cm() called from <class E[ClassDecoratorMDecorated]>

Notice that ``sm`` was defined in ``D``, the undecorated class: therefore
it is not decorated:

>>> E.sm() # correctly, does not work
Traceback (most recent call last):
  ...
TypeError: unbound method sm() must be called with E instance as first argument (got nothing instead)

The error message says clearly that ``sm`` is an unbound method and not
a static method.

Defining method decorators
-----------------------------------------------------------------------

The ``decorators module`` contains two predefinite method decorators, 
``staticmethod`` and ``classmethod``, which emulate the built-ins 
with the same names. However, it is possible to write your own
custom decorators. The ``decorators.MethodDecorator`` class which is here 
exactly for that purpose.

Custom decorators are expected to be implemented by subclassing
``MethodDecorator`` and by overriding its ``get`` method. The
``get`` method automagically induces a ``__get__`` method, turning the 
class in a descriptor. The machinery is needed since ``__get__`` cannot 
be made cooperative using  the standard ``super`` mechanism because
there would be a confusion between ``super.__get__`` and the decorator 
``__get__``. This is a bit tricky, but the causal programmer is not 
expected to write custom decorators, and actually I don't want to make 
the access to decorators *too* easy, since they are potentially dangerous.

In order to give a simple example, let me show the implementation 
of a ``chattymethod`` that prints a message when it is called:

 ::

  #<customdec.py>

  from decorators import *  

  class chattymethod(MethodDecorator):
      logfile=sys.stdout # default
      def get(self,obj,cls=None): # same signature as __get__
          self.logfile.write('calling %s from %s\n' % (self,obj or cls))
          return super(chattymethod,self).get(obj,cls)

  #</customdec.py>

Notice the usage of the ``super().get`` trick. This guarantees that 
``chattymethod`` will play well with other decorators (i.e. it
can be nicely composed via multiple inheritance). The point will
be fully discussed in the section on composing decorators.

Here is an example of usage:

>>> import customdec # adds chattymethod to the list of known decorators
>>> customdec.enhance_classes() # automagically enhances classes when needed
>>> class C: 
...     " [Decorated] "
...     def f(self): 
...         """
...         [ chattymethod ]
...         """
>>> c=C()
>>> c.f()
calling <chattymethod:f> from <C instance>

By the way, this shows that one can safely add whitespaces (including
newlines) to the magic docstring: they are simply ignored.

One can check that the syntax ``C.f(c)`` works too:

>>> C.f(c) 
calling <chattymethod:f> from <class C[Decorated]>

A tricky point of the decorators mechanism is the issue of parameter passing.
In comp.lang.python there was the proposal of allowing explicit parameter
passing to decorators, with a syntax of kind

 ::

  def f(self)[chattymethod(logfile=file('file1.log','w'))]

In my view, there are too many parenthesis in this syntax, and it may
become rapidly unreadable. Moreover, it complicates the implementation
without any real benefit, so the decorators module does not allow
this kind of parameter passings. There are however viable
workarounds, so you should not miss the syntax. 

A simple minded solution is to change the defaults by hand:

>>> from customdec import chattymethod,decorated
>>> chattymethod.logfile=file('file.log','w')
>>> def g(self): 
...     "[chattymethod]"
>>> C.g=decorated(g)
>>> c.g() # will print a message on file.log

This approach has the drawback that chattymethods created before changing 
the logfile will also print to the new logfile, if invoked after the
change. Therefore 

>>> c.f()

will print a message to ``file.log`` too, and not to standard output.
Here is the confirmation:

>>> chattymethod.logfile.close()
>>> print file('file.log').read().rstrip()
calling <chattymethod:g> from <C instance>
calling <chattymethod:f> from <C instance>

A much better solution is to pass  
parameters to method decorators as function attributes: then the function
attributes can be converted to attributes of the decorator 
in  the ``__init__`` method. Here is an example:

 ::

  #<customdec.py>

  class chattymethod2(chattymethod): 
      logfile=sys.stdout # default
      def __init__(self,objfunc):
          super(chattymethod2,self).__init__(objfunc)
          logfile=getattr(self.__func__,'logfile',None)
          if logfile: self.logfile=logfile 

  #</customdec.py>

Notice that the ``__init__`` method has the signature
``__init__(self,objfunc)``, where the ``objfunc`` object is a
decorator object or the function to be converted in the decorator 
object, and that it is cooperative.
This is the suggested way of overriding ``__init__`` (see also 
``help(decorators.MethodDecorator.__init__)``).

Here is the testing:

 ::

  #<chatty2.py>
  
  import customdec; customdec.enhance_classes("[Decorated]")

  # sets the log files
  log1=file('file1.log','w')
  log2=file('file2.log','w')

  class C:
      def f(self): 
          "[chattymethod2]"
      f.logfile=log1 # function attribute
      def g(self): 
          "[chattymethod2]"
      g.logfile=log2 # function attribute

  assert C.__dict__['f'].logfile is log1 # check the conversion 
  assert C.__dict__['g'].logfile is log2 # function attr. -> decorator attr.

  c=C() # C instantiation

  c.f() # print a message in file1.log
  c.g() # print a message in file2.log

  log1.close(); log2.close() # finally

  #</chatty2.py>

Let me check the contents of the log files:

>>> import chatty2
>>> print file('file1.log').read().rstrip()
calling <chattymethod2:f> from <C instance>
>>> print file('file2.log').read().rstrip()
calling <chattymethod2:g> from <C instance>

``chattymethod`` is the poor man version of ``tracedmethod``, a
sophisticated decorator for tracing methods.
Here is the code, given for pedagogical purposes; the lazy reader can 
skip it and go directly to the usage section.

 ::

  #<customdec.py>

  class tracedmethod(MethodDecorator):
      "Descriptor class, converts a method in a traced method"
      indent=0; output=sys.stdout # defaults

      def __init__(self,objfunc):
          super(tracedmethod,self).__init__(objfunc)
          self.funcname=self.__func__.__name__
          output=getattr(self.__func__,'output',None) 
          if output: self.output=output # func.attr. -> dec.attr.

      def get(self,obj,cls):
          clsname=self.__klass__.__name__ # definition clas
          def tracedmeth(obj,*args,**kw):
              i=' '*self.indent # default indentation
              self.__class__.indent+=4 # increases indentation
              self.output.write("%sCalling '%s.%s' with arguments " % 
                               (i,clsname,self.funcname))
              self.output.write("%s%s ...\n" % (obj or '',str(args)+str(kw)))
              res=super(tracedmethod,self).get(obj,cls)(*args,**kw)
              self.output.write("%s'%s.%s' called with result: %s\n"
                                 % (i,clsname,self.funcname,res))
              self.__class__.indent-=4 # restores default indentation
              return res
          return tracedmeth.__get__(obj,cls) # method wrapper

  #</customdec.py>

``tracedmethod.get`` returns a method wrapper object, so it is
possible to use ``im_func`` to retrieve the internal function
``tracedmeth``:

>>> class C:
...     "[Decorated]"
...     def f(self):
...         "[tracedmethod]"
>>> c=C(); c.f() 
Calling 'C.f' with arguments <C instance>(){} ...
'C.f' called with result: None
>>> c.f.im_func.__name__
'tracedmeth'

As soon as the ``tracedmethod`` module is loaded, the ``tracedmethod`` class
is added to the list of know decorators, so one should use the  
"[tracedmethod]" docstring and not something like
"[customdec.tracedmethod]".

Here is a less trivial example of usage, writing in a log file the 
internal working of a recursive function:

 ::

  #<example9.py>
 
  import customdec; customdec.enhance_classes()

  logfile=file('file3.log','w')

  class C(object):
      "[Decorated]"
      def fact(self,n):
          "[tracedmethod] The good old factorial."
          if n==0: return 1
          else: return n*self.fact(n-1)
      fact.output=logfile

  C().fact(2) # write a message to logfile

  logfile.close()

  #</example9.py>

Here is the content of the ``file3.log``:

>>> import example9
>>> print file('file3.log').read().rstrip()
Calling 'C.fact' with arguments <C instance>(2,){} ...
    Calling 'C.fact' with arguments <C instance>(1,){} ...
        Calling 'C.fact' with arguments <C instance>(0,){} ...
        'C.fact' called with result: 1
    'C.fact' called with result: 1
'C.fact' called with result: 2

Composing decorators
---------------------------------------------------------------------

Decorators can be composed by using magic docstrings with comma-separated
decorator names. For instance, you can trace a classmethod as in this example:

 ::

  #<example6.py>

  "How to trace a class method"

  import customdec; customdec.enhance_classes()

  class C(object):
      "[Decorated]"
      def fact(cls,n): # a traced classmethod
          "[classmethod,tracedmethod]"
          if n==0: return 1
          else: return n*cls.fact(n-1)
  
  #</example6.py>

Here is the testing:

>>> from example6 import C
>>> C.fact(2)
Calling 'C.fact' with arguments <class C[Decorated]>(2,){} ...
    Calling 'C.fact' with arguments <class C[Decorated]>(1,){} ...
        Calling 'C.fact' with arguments <class C[Decorated]>(0,){} ...
        'C.fact' called with result: 1
    'C.fact' called with result: 1
'C.fact' called with result: 2
2

You may easily check that calling ``.fact`` from the instance will work too.

Under the hood the syntax

 ::

  [classmethod,tracedmethod]

generates a ``classmethodtracedmethod`` class obtained via
multiple inheritance:

>>> C.__dict__['fact'].__class__
<class 'noconflict.classmethodtracedmethod'>

Notice that the order does matter and using the docstring 
"[tracedmethod,classmethod]" will not work:

>>> class D:
...     "[Decorated]"
...     def f(cls):
...         "[tracedmethod,classmethod]"
>>> D.f()
Traceback (most recent call last):
  ...
TypeError: unbound method tracedmeth() must be called with D instance as first argument (got nothing instead)

The problem here is that ``tracedmethod.get`` returns a method-wrapper object
which expects a D instance as first argument whereas it gets ``None`` since
it is called from the class. On the other hand,

>>> D().f()
Calling 'D.f' with arguments <D instance>(){} ...
'D.f' called with result: None

will work. When ``classmethod`` precedes ``tracedmethod``, then
``classmethod`` passes to ``tracedmeth`` a non-empty first argument,
i.e. the calling class, even when called from the instance:

>>> C().fact(2)
Calling 'C.fact' with arguments <class C[Decorated]>(2,){} ...
    Calling 'C.fact' with arguments <class C[Decorated]>(1,){} ...
        Calling 'C.fact' with arguments <class C[Decorated]>(0,){} ...
        'C.fact' called with result: 1
    'C.fact' called with result: 1
'C.fact' called with result: 2
2

If we try to trace a staticmethod, we will get a different error with
the order "tracedmethod, staticmethod":

>>> class F(object):
...    "[Decorated]"
...    def fact(n):
...        "[tracedmethod,staticmethod]"
...        if n==0: return 1
...        else: return n*F.fact(n-1)
>>> F.fact(2)
Traceback (most recent call last):
  ...
TypeError: unbound method tracedmeth() must be called with F instance as first argument (got int instance instead)

The message is self-explanatory.

On the other hand, composing the decorators in the other order
"[tracedmethod,staticmethod]" will work just fine.

Defining class decorators
-----------------------------------------------------------------------

PEP 318 proposes to decorate methods by using descriptors; it is
quite natural to extend this idea and to decorate classes by using 
class decorators implemented as metaclasses. We already saw a
class decorator at work, the metaclass ``Decorated``, giving
to its instances the ability to interpret magic docstrings,
and converting functions in method decorators.

To define a custom class decorator is easy: one defines a custom metaclass 
as usual, with the only difference from deriving by ``ClassDecorator`` instead
of deriving from ``type``. To understand how this works in practice, let me 
show how to add logging capabilities to a given class. The first
step is to define a suitable class decorator, such as the following:

 ::

  #<customdec.py>

  class Logged(ClassDecorator):
      output=sys.stdout
      def __init__(cls,name,bases,dic):
          super(Logged,cls).__init__(name,bases,dic)
          print >> cls.output,"%s created" % cls

  #</customdec.py>

``Logged`` is derived by the metaclass ``ClassDecorator``, 
which provides a certain amount of magic under the hood (in particular
its printing representation and its calling syntax are redefined by its
metaclass ``MetaDecorator``). Logging capabilities can be added to a class 
by simply using the magic docstring syntax:

 ::

  #<logged.py>

  import customdec; customdec.enhance_classes()

  class D(object): # will print a message at D creation
      "[Logged]"

  #</logged.py>

>>> import logged
<class D[Logged]> created

Notice that the printing representation of ``D`` involves the name
of ``D`` preceded by the name of its metaclass, which in this case
is ``Logged``

Each time an instance of ``Logged`` is created, a similar message is printed:

>>> class E(logged.D):
...     pass
<class E[Logged]> created

Notice that ``E`` does not have any magic docstring

>>> E.__doc__ # no docstring

but still it inherits its magic from ``D``.

Another simple example of class decorator is the following metaclass 
which modifies the docstrings of the methods of its instances, 
by magically inducing tracing capabilities on them:

 ::

  #<customdec.py>

  from types import FunctionType  

  class Traced(ClassDecorator):
      def __init__(cls,n,b,d):
          for name,func in d.iteritems():
              if isinstance(func,FunctionType): # modifies the docstring
                  func.__doc__="[tracedmethod] " + (func.__doc__ or '')
          super(Traced,cls).__init__(n,b,d)


  #</customdec.py>

Here is an example of usage:

>>> class C(object):
...     """[Decorated,Traced] The class decorator adds the magic docstring
...     '[tracedmethod]' to f1 and f2, which are then converted 
...     to method decorator objects."""
...     def f1(self): pass
...     def f2(self): pass
...
>>> type(C)
<class 'noconflict.DecoratedTraced'>
>>> c=C()
>>> c.f1()
Calling 'C.f1' with arguments <C instance>(){} ...
'C.f1' called with result: None
>>> c.f2()
Calling 'C.f2' with arguments <C instance>(){} ...
'C.f2' called with result: None

By default, the decorators module only decorates classes with a magic 
docstring (and they subclasses, even without magic docstrings). 
If all the classes of your module have the same magic docstring, 
it makes sense to decorate them all
with a single command. It is enough to use ``decorators.enhance_classes()``
with a magic docstring corresponding to a class decorator as argument, 
as in this example:

 ::

  #<example.py>

  from example2 import identity,name
  import inspect, decorators; decorators.enhance_classes("[Decorated]")

  class C1: # automagically converted to a decorated class
      identity=identity 

  class C2: # automagically converted to a DecoratedLogged class
      "[Logged]"
      name=name

  c1=C1() # C1 instance
  c2=C2() # C2 instance

  #</example.py>

Notice that class ``C2`` has already a magic docstring. This means that
``C2`` has to be enhanced both from ``Logged`` and from ``Decorated``.
This is done by automagically creating a ``DecoratedLogged`` class
decorator:

>>> from example import C1,C2,c1,c2 
<class C2[DecoratedLogged]> created

The second line is printed because of the logging capabilities of ``C2``.
Moreover, since ``C2`` is decorated too, the following will work:

>>> assert C2.name() == 'C2'
>>> assert c2.name() == 'C2' 

Idem for ``C1``:

>>> assert C1.identity(1) == 1
>>> assert c1.identity(1) == 1 

You may check that the magic works both for new style classes (decorating
module ``object`` class) and old style classes (by setting the module level 
``__metaclass`` attribute and by implicitly converting the classes 
to new style classes).

This magical approach is the easiest way to go if you want to trace
inheritance hierarchies. For instance, here is how to trace cooperative 
methods in complicate (which is useful for debugging):

 ::

  #<tracing.py>

  import customdec; customdec.enhance_classes("[Decorated]")
   
  class B(object): 
      def __init__(self):
          "[tracedmethod]"
          super(B,self).__init__()
  
  class D(object): 
      def __init__(self):
          "[tracedmethod]"
          super(D,self).__init__()
  
  class E(B,D):
      def __init__(self):
          "[tracedmethod]"
          super(E,self).__init__()

   #</tracing.py>

>>> from tracing import E
>>> e=E()
Calling 'E.__init__' with arguments <E instance>(){} ...
    Calling 'B.__init__' with arguments <E instance>(){} ...
        Calling 'D.__init__' with arguments <E instance>(){} ...
        'D.__init__' called with result: None
    'B.__init__' called with result: None
'E.__init__' called with result: None

Advanced usage
---------------------------------------------------------------------------

Whereas the average programmer is expected to use the 
``decorators.decorated`` function only, the module provides access to
its underlining implementation, which may be useful to the advanced
programmer. 


The module provides an utility functions to retrieve the list of
recognized decorators: ``decorators.get(docstring)``, where ``docstring``
is a magic docstring, i.e. a bracketed comma-separated list 
of decorator names. For instance ``decorators.get('[MethodDecorator]')``
gives the list of all subclasses of ``MethodDecorator``, i.e. all method
decorators, whereas ``decorators.get('[ClassDecorator]')``
gives the list of the known class decorators. It is even possible
to use the comma notation:

>>> decorators.get("[classmethod,tracedmethod]")
[<class 'noconflict.classmethodtracedmethod'>]

For instance, it is possible to decorate functions by hand,
without using magic docstring. Here is an example:
  
>>> do_nothing=decorators.staticmethod(lambda:None)
>>> print do_nothing # ``do_nothing`` is a static method
<staticmethod:<lambda>>

One can even compose decorators by hand:

>>> class B: pass
...
>>> B.chattystatic=customdec.chattymethod2(do_nothing)
>>> B.chattystatic()
calling <chattymethod2staticmethod:<lambda>> from <class B[ClassDecorator]>

In other words

  ``decorator1(decorator2(obj))``

automagically creates a composed class ``decorator1decorator2`` in the
``noconflict`` module (or recycle it, if ``decorator1decorator2`` has 
been already created) and it is equivalent to

  ``decorator1decorator2(obj)``

Here is the check:

>>> decorators.get("[chattymethod2staticmethod]")
[<class 'noconflict.chattymethod2staticmethod'>]

Here is another example:

>>> from customdec import tracedmethod
>>> class C(object):
...     def fact(self,n):
...         if n==0: return 1
...         else: return n*self.fact(n-1)
...     fact=tracedmethod(fact)
>>> c=C()
>>> c.fact(2)
Calling '?.fact' with arguments <C instance>(2,){} ...
    Calling '?.fact' with arguments <C instance>(1,){} ...
        Calling '?.fact' with arguments <C instance>(0,){} ...
        '?.fact' called with result: 1
    '?.fact' called with result: 1
'?.fact' called with result: 2
2

In this second syntax ``fact`` does not know where it 
is defined, unless the containing class is explicitly set:

>>> C.__dict__['fact'].__klass__=C

Now the code will work as with the docstring syntax.




What happens if you try to decorate something which is already
decorated? You get ``None``:

>>> def f(x): "[tracedmethod]"
...
>>> tm=decorators.decorated(f) # creates a tracedmethod from f
>>> print decorators.decorated(tm) # trying to decorate a tracedmethod
None

You can compose decorators in a trivial way:

>>> cmtm=decorators.classmethod(tm)
>>> print cmtm
<classmethodtracedmethod:f>


whereas you can compose classes:

>>> class C: "[Decorated]"
...
>>> print customdec.Traced(C)
<class C[TracedDecorated]>




>>> class D: pass
...
>>> print customdec.Decorated(customdec.Traced(D))
<class D[DecoratedTraced]>


This is the hierarchy:

>>> for C in type(cmtm).mro(): print C
...
<class 'noconflict.classmethodtracedmethod'>
<class 'decorators.classmethod'>
<class 'customdec.tracedmethod'>
<class 'decorators.MethodDecorator'>
<class 'decorators.Decorator'>
<type 'object'>



One can also decorate classes by hand, by using class decorators.
``decorators.ClassDecorator`` which converts a regular (both old 
style or new style) class in a class with the ability to recognize 
magic docstrings. Actually, the ``decorators.enhance_classes()`` 
trick works by decorating the ``object`` class with
``decorators.ClassDecorator`` and by setting the custom metaclass to 
``decorators.ClassDecorator`` and it is equivalent to write

 ::

  import decorators
  object=decorators.ClassDecorator(object) # decorates all new style classes
  __metaclass__= decorators.ClassDecorator # decorates all old style classes

on top of your module. 
If you want the magic to work only for new style classes only, you may 
forget the
second line; if you want the magic to work for old style classes only, you
may forget the first line. 

If the module contains a magic docstring which is an explicit class decorator,
such as ``decorators.Decorated``, then ``decorators.decorated`` look at the
magic docstring and executes something like

 ::

  import decorators
  object=decorators.Decorated(object) # decorates all new style classes
  __metaclass__= decorators.Decorated # decorates all old style classes

It is possible to go even deeper in black magic, and to decorate all 
the new style classes in *all* modules, by decorating ``__builtin__.object``:

 ::

  import decorators,__builtin__
  __builtin.object=decorators.decorated(object)

Still, redefining ``__builtin__object`` is not recommended since it 
may induce metaclass conflicts in other modules using metaclasses. 
It will work only if you import modules not using metaclasses, or 
modules using metaclasses safely, i.e. modules taking care of 
possible conflicts by using the ``makecls`` function or an equivalent one.

The implementation
-----------------------------------------------------------------------

This part can be safely skipped, unless you are a *really* curious and
you want to know how the implementation works.

The module is rather short (~150 lines) but far from being trivial,
since it is based on extensive usage of metaclass wizardry.

The main class-metaclass hierarchy is represented in figure 1, where
boxes denote classes and ovals denote metaclasses; instantiation is
denoted by dashed green lines whereas inheritance is denoted by continuous
blue lines.

.. figure:: decorators.png

Notice that ``MetaDecorator`` (inherited via ``Decorator``) is the 
metaclass of all decorators. Class decorators are already metaclasses,
so ``MetaDecorator`` is actually a meta-metaclass with respect to
instances of decorated classes, whereas it is a simple metaclass with
respect to instances of decorated methods. For this reason in the
presenced of class decorators the unusual relation

assert object.__metaclass__ != object.__class__

holds. More specifically

>>> object.__class__
<class 'decorators.ClassDecorator'>

but

>>> object.__metaclass__ 
<class 'decorators.MetaDecorator'>

since ``object`` the ``__metaclass__`` 
attribute is inherited from ``Decorator``.

The implementation is relatively smart. Consider for instance the case of
the logged example. In that example class ``D`` was a subclass of a tricked 
``object`` class, enhanced by a metaclass ``ClassDecorator``. Moreover ``D`` 
had a ``Logged`` docstring. Therefore it should have been an instance of 
``_ClassDecoratorLogged`` metaclass. But logged was
a subclass of ``ClassDecorator``, therefore it already had all the features
of ``ClassDecorator`` and it would have been redundant to create 
``_ClassDecoratorLogged``, when``Logged`` would have been enough. 
So ``Logged`` 
was used and ``_ClassDecoratorLogged`` was never created. All the magic is in 
the ``noconflict`` module discussed in my cookbook_ recipe.

The current implementation does not make any attempt of optimization and
there may be alternative implementations faster or more memory efficient.
At this experimental level I didn't care to explore about performances 
issues. They does not probably matter unless one has to decorate
thousands or millions of functions and classes.

Things to do: adding more error checking.

Finally, a word about bugs. The ``decorators`` module is fairly sophisticated,
therefore whereas I can guarantee that it passes my test suite (which involves
~100 tests automatically extracted from the documentation you are reading), 
I cannot guarantee that it is correct. 
If somebody finds a bug or an unexpected 
behavior, please let me know and I will try to fix it.

.. References:

.. _cooperative methods: 
    http://www.python.org/2.3/descrintro.html
.. _new style classes and old style classes: 
    http://www.python.org/2.3/descrintro.html
.. _descriptors: http://users.rcn.com/python/download/Descriptor.htm
.. _cookbook: http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/204197
.. _metaclasses: http://www-106.ibm.com/developerworks/library/l-pymeta2.html
