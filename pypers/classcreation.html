<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.9: http://docutils.sourceforge.net/" />
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="section" id="what-happens-when-python-executes-a-class-statement">
<h1><a name="what-happens-when-python-executes-a-class-statement">What happens when Python executes a class statement?</a></h1>
<p>It seems an easy question, isn't ? 
But the answer is pretty sophisticated ;)</p>
<ol class="arabic">
<li><p class="first">First of all, Python determines which is the currect metaclass to
use in order to create the class. Here are the rules:</p>
<ol class="arabic simple">
<li>if an explicit <tt class="literal"><span class="pre">__metaclass__</span></tt> is given, use it;</li>
<li>otherwise, determine the correct metaclass from the base classes's
metaclass.</li>
</ol>
<p>The determination from the base 
classes' metaclasses is based on the following principles:</p>
<ol class="arabic simple">
<li>custom metaclasses have the precedence over the built-in metaclasses
<tt class="literal"><span class="pre">type</span></tt>  and <tt class="literal"><span class="pre">ClassType</span></tt>;</li>
<li><tt class="literal"><span class="pre">type</span></tt>, i.e. the default metaclass of new style classes, has the precedence 
over <tt class="literal"><span class="pre">ClassType</span></tt>, the metaclass of old style classes;</li>
<li>in the case of same precedence the first, i.e. the leftmost  
metaclass is used.</li>
</ol>
</li>
<li><p class="first">Let's call <tt class="literal"><span class="pre">M</span></tt> the correct metaclass. Then <tt class="literal"><span class="pre">M</span></tt> is called in the form
<tt class="literal"><span class="pre">M(n,b,d)</span></tt>, where <tt class="literal"><span class="pre">n</span></tt> is the name of the class to create, <tt class="literal"><span class="pre">b</span></tt> the tuple 
of its base classes and <tt class="literal"><span class="pre">d</span></tt> its dictionary. This is equivalent to call
<tt class="literal"><span class="pre">type(M).__call__(M,n,b,d)</span></tt>.</p>
<p>Now, unless  <tt class="literal"><span class="pre">type(M).__call__</span></tt> is overridden with a meta-metaclass,
the standard <tt class="literal"><span class="pre">type.__call__</span></tt> will be used.</p>
</li>
<li><p class="first">The following happens when <tt class="literal"><span class="pre">type.__call__(M,n,b,d)</span></tt> is invoked:</p>
<ol class="arabic simple">
<li>Python tries to create the class <tt class="literal"><span class="pre">C</span></tt> by using <tt class="literal"><span class="pre">M.__new__(M,n,b,d)</span></tt>,
which at a certain moment will invoke <tt class="literal"><span class="pre">type.__new__(M,n,b,d)</span></tt>.</li>
<li>If a metaclass conflict is found in <tt class="literal"><span class="pre">type.__new__</span></tt>, Python
raises an exception.</li>
<li>If not, Python initializes <tt class="literal"><span class="pre">C</span></tt> by using <tt class="literal"><span class="pre">type(C).__init__(C,n,b,d)</span></tt>.</li>
</ol>
<p>Notice that <tt class="literal"><span class="pre">type(C)</span></tt> is usually <tt class="literal"><span class="pre">M</span></tt>, unless <tt class="literal"><span class="pre">M.__new__</span></tt> is badly
overridden by a metaclass novice or very subtly overridden by a metaclass 
wizard.</p>
</li>
</ol>
<p>I argued these rules from experiment, but it should be possible to infer
them from Python-2.3/Objects/typeobject.c, at least for experts of Python
internals.</p>
</div>
<div class="section" id="an-example-of-badly-written-metaclass">
<h1><a name="an-example-of-badly-written-metaclass">An example of badly written metaclass</a></h1>
<p>Let me start by checking the validity of point 3.3, i.e the fact that the
newly created class is initialized with <tt class="literal"><span class="pre">type(C).__init__(C,n,b,d)</span></tt>
and not with <tt class="literal"><span class="pre">M.__init__(C,n,b,d)</span></tt>. This happens when <tt class="literal"><span class="pre">M.__new__</span></tt>
is overridden in such a way that it does not return an instance of <tt class="literal"><span class="pre">M</span></tt>.
Here is a simple example:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class M(type):
...     &quot;A badly written metaclass&quot;
...     def __new__(mcl,n,b,d):
...         print 'calling M.__new__, name = %s ...' % n
...         return type(n,b,d)
...     def __init__(cls,n,b,d):
...         print 'calling M.__init__, name = %s ...' % n
</pre>
<p>In this example <tt class="literal"><span class="pre">M.__new__</span></tt> returns an instance of <tt class="literal"><span class="pre">type</span></tt>, so it
will be initialized with <tt class="literal"><span class="pre">type.__init__</span></tt> and not with <tt class="literal"><span class="pre">M.__init__</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C:
...     __metaclass__=M
calling M.__new__, name = C ...
</pre>
<p>As you see, <tt class="literal"><span class="pre">M.__init__</span></tt> is not called since</p>
<pre class="doctest-block">
&gt;&gt;&gt; type(C)
&lt;type 'type'&gt;
</pre>
<p>Typically, missing <tt class="literal"><span class="pre">M.__init__</span></tt> is not what you want. There are two
solutions:</p>
<ol class="arabic simple">
<li>returns <tt class="literal"><span class="pre">type.__call__(mcl,n,b,d)</span></tt> (the poor man solution)</li>
<li>returns <tt class="literal"><span class="pre">super(M,mcl).__new__(mcl,n,b,d)</span></tt> (the right solution)</li>
</ol>
<p>The cooperative solution is the right one because it will work always,
whereas the solution number 1 may fail when <tt class="literal"><span class="pre">M</span></tt> is composed trough
multiple inheritance with another metaclass.</p>
</div>
<div class="section" id="a-simple-example">
<h1><a name="a-simple-example">A simple example.</a></h1>
<p>Suppose we have two classes <tt class="literal"><span class="pre">A</span></tt> (old style) and <tt class="literal"><span class="pre">B</span></tt> (new style):</p>
<pre class="doctest-block">
&gt;&gt;&gt; class A:
...     pass
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; class B(object):
...     pass
</pre>
<p>We want to create a class <tt class="literal"><span class="pre">C</span></tt> with bases <tt class="literal"><span class="pre">A</span></tt> and <tt class="literal"><span class="pre">B</span></tt>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C(A,B): 
...     pass
</pre>
<p>In order to proceed with the creation, Python argues that the metaclass 
to use is the metaclass of <tt class="literal"><span class="pre">B</span></tt>, i.e. <tt class="literal"><span class="pre">type</span></tt> and not the metaclass of 
<tt class="literal"><span class="pre">A</span></tt>, i.e. <tt class="literal"><span class="pre">ClassType</span></tt>. Then the class statement is equivalent to</p>
<pre class="doctest-block">
&gt;&gt;&gt; C=type('C',(A,B),{})
</pre>
<p>i.e. to</p>
<pre class="doctest-block">
&gt;&gt;&gt; type(type).__call__(type,'C',(A,B),{})
&lt;class 'C'&gt;
</pre>
<p>i.e. to (since <tt class="literal"><span class="pre">type</span></tt> is its own metaclass)</p>
<pre class="doctest-block">
&gt;&gt;&gt; type.__call__(type,'C',(A,B),{})
&lt;class 'C'&gt;
</pre>
<p>Notice that</p>
<pre class="doctest-block">
&gt;&gt;&gt; type.__call__('C',(A,B),{})
Traceback (most recent call last):
  ...
TypeError: descriptor '__call__' requires a 'type' object but received a 'str'
</pre>
<p>will not work, i.e. it is not equivalent to 
<tt class="literal"><span class="pre">type(type).__call__(type,'C',(A,B),{})</span></tt> as it happens for regular callable
objects. <tt class="literal"><span class="pre">type</span></tt> is special, since it is its own metaclass, so <tt class="literal"><span class="pre">__call__</span></tt>
has to be defined on it with four and not three arguments.</p>
</div>
<div class="section" id="a-less-simple-example">
<h1><a name="a-less-simple-example">A less simple example</a></h1>
<p>In the previous examples, the class statement and the <tt class="literal"><span class="pre">type</span></tt>
call were perfectly equivalent.
If there is a non-trivial metaclass, the situation changes:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class M1(type):
...     &quot;A chatty metaclass&quot;
...     def __new__(mcl,n,b,d):
...         print 'calling M1.__new__, name = %s ...' % n
...         return super(M1,mcl).__new__(mcl,n,b,d)
...     def __init__(cls,n,b,d):
...         print 'calling M1.__init__, name = %s ...' % n
...         super(M1,cls).__init__(n,b,d)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; class A: 
...     __metaclass__=M1
calling M1.__new__, name = A ...
calling M1.__init__, name = A ...
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; class C(A,B):
...    pass
calling M1.__new__, name = C ...
calling M1.__init__, name = C ...
</pre>
<p>In this case the class statement is equivalent to <tt class="literal"><span class="pre">M1('C',(A,B),{})</span></tt>
i.e. to <tt class="literal"><span class="pre">type(M1).___call__(M1,'C',(A,B),{})</span></tt> i.e. 
<tt class="literal"><span class="pre">type.___call__(M1,'C',(A,B),{})</span></tt>.
However, it is interesting to notice that <tt class="literal"><span class="pre">type</span></tt> would work too:</p>
<pre class="doctest-block">
&gt;&gt;&gt; type('C',(A,B),{})
calling M1.__new__, name = C ...
calling M1.__init__, name = C ...
&lt;class 'C'&gt;
</pre>
<p>The reason is that <tt class="literal"><span class="pre">type.__call__</span></tt> is able to dispatch to the correct 
metaclass. However, the class statement is not always equivalent to a
<tt class="literal"><span class="pre">type.__call__</span></tt> and there is a very subtle difference between the 
two. The difference only manifests itself  in the
the case in which <tt class="literal"><span class="pre">A</span></tt> and <tt class="literal"><span class="pre">B</span></tt> have incompatible metaclasses.</p>
</div>
<div class="section" id="a-more-sophisticated-example">
<h1><a name="a-more-sophisticated-example">A more sophisticated example</a></h1>
<p>Here is an example:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class M2(type):
...     &quot;Another chatty metaclass&quot;
...     def __new__(mcl,n,b,d):
...         print 'calling M2.__new__, name = %s ...' % n
...         return super(M2,mcl).__new__(mcl,n,b,d)
...     def __init__(cls,n,b,d):
...         print 'calling M2.__init__, name = %s ...' % n
...         super(M2,cls).__init__(n,b,d)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; class B: 
...     __metaclass__=M2
calling M2.__new__, name = B ...
calling M2.__init__, name = B ...
</pre>
<p>If we try to create <tt class="literal"><span class="pre">C</span></tt> with <tt class="literal"><span class="pre">type</span></tt>, we simply get a conflict:</p>
<pre class="doctest-block">
&gt;&gt;&gt; type.__call__(type,'C',(A,B),{})
Traceback (most recent call last):
  ...
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
</pre>
<p>On the other hand, with a class statement we get</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C(A,B):
...     pass
calling M1.__new__, name = C ... # doctest bug here
Traceback (most recent call last): 
  File &quot;pro.py&quot;, line 4, in __new__
    return super(M1,mcl).__new__(mcl,n,b,d)
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
</pre>
<p>The difference is that <tt class="literal"><span class="pre">M1.__new__</span></tt> is called <em>first</em>, and only after
the conflict is discovered, when <tt class="literal"><span class="pre">M1.__new__</span></tt> invokes <tt class="literal"><span class="pre">type.__new__</span></tt>.
The error message is pretty clear indeed.
In other words, the class statement in this case is equivalent to 
<tt class="literal"><span class="pre">M1('C',(A,B),{})</span></tt> i.e. to <tt class="literal"><span class="pre">type.__call__(M1,'C',(A,B),{})</span></tt>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; from safetype import safetype as type
</pre>
</div>
</div>
<hr class="footer"/>
<div class="footer">
<a class="reference" href="classcreation.txt">View document source</a>.
Generated on: 2003-10-04 08:36 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
