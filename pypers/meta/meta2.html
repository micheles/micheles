<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.9: http://docutils.sourceforge.net/" />
<title>Metaclass Programming in Python, Part 2: Understanding the Arcana of Inheritance and Instance Creation</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="metaclass-programming-in-python-part-2-understanding-the-arcana-of-inheritance-and-instance-creation">
<h1 class="title">Metaclass Programming in Python, Part 2: Understanding the Arcana of Inheritance and Instance Creation</h1>
<blockquote>
<table class="field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">author:</th><td class="field-body">Michele Simionato, Ph.D., University of Pittsburgh</td>
</tr>
<tr class="field"><th class="field-name">author:</th><td class="field-body">David Mertz, Ph.D., Gnosis Software, Inc.</td>
</tr>
<tr class="field"><th class="field-name">date:</th><td class="field-body">June 2003</td>
</tr>
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body">Our initial developerWorks article on metaclass programming
prompted quite a bit of feedback, some of it from perplexed
readers still trying to grasp the subtleties of Python
metaclasses.  This article revisits the working of
metaclasses and their relation to other OOP concepts.  We
contrast class instantiation with inheritance, distinguish
classmethods and metamethods, and explain and solve metaclass
conflicts.</td>
</tr>
</tbody>
</table>
</blockquote>
<div class="section" id="metaclasses-and-their-discontents">
<h1><a name="metaclasses-and-their-discontents">METACLASSES AND THEIR DISCONTENTS</a></h1>
<blockquote>
<p>In our earlier article on metaclass programming in Python, we
introduced the concept of metaclasses, showed some of their power,
and demonstrated their use in solving problems such as dynamic
customization of classes and libraries at run-time.</p>
<p>That article has proved quite popular, but there were ellisions in
our condensed initial summary.  Certain details in the use of
metaclasses merit futher explanation.  Based on the feedback of our
readers and on discussions in comp.lang.python, we decided to
address some of those trickier point in this second article.  In
particular, we think the following points are important for any
programmer wanting to master metaclasses:</p>
<p>(1) Users must understand the differences and interactions between
metaclass programming and traditional object-oriented programming
(under both single and multiple inheritance).</p>
<p>(2) Python 2.2 added the built-in functions 'staticmethod()' and
'classmethod()' to create methods that do not require an instance
object during invocation.  To an extent, -classmethods- overlap in
purpose with (meta)methods defined in metaclasses.  But the precise
similarities and differences have also generated confusion in the
mind of many programmers.</p>
<p>(3) User should understand the cause and the resolution of metatype
conflicts.  This becomes essential when you want to use more than
one custom metaclass.  We explain the concept of -composition- of
metaclasses.</p>
</blockquote>
</div>
<div class="section" id="instantiation-versus-inheritance">
<h1><a name="instantiation-versus-inheritance">INSTANTIATION VERSUS INHERITANCE</a></h1>
<blockquote>
<p>Many programmers are confused about the difference between a
metaclass and a base class.  At the superficial level of &quot;determing&quot;
a class, both look similar.  But once you look any deeper, the
concepts drift apart.</p>
<p>Before presenting some examples, it is worth being precise about
some nomenclature.  An -instance- is a Python object that was
&quot;manufactured&quot; by a class; the class acts as a sort of template for
the instance.  Every instance is an instance of -exactly one- class
(but a class might have multiple instances).  What we often call an
instance object--or perhaps a &quot;simple instance&quot;--is &quot;final&quot; in the
sense it cannot act as a template for other objects (but it might
still be a -factory- or a -delegate-, which serve overlapping
purposes).</p>
<p>Some instance objects are themselves classes; and all classes are
instances of a corresponding -metaclass-.  Even classes only come
into existence through the instantiation mechanism.  Usually classes
are instances of the built-in, standard metaclass 'type'; it is only
when we specify metaclasses other than 'type' that we need to think
about metaclass programming.  We also call the class used to
instantiate an object the -type- of that object.</p>
<p>Running -orthogonal- to the idea of instantiation is the notion of
inheritance.  Here, a class can have one or multiple parents, not
just one unique type.  And parents can have parents, creating a
transitive subclass relation, conveniently accessible with the
built-in function 'issubclass()'.  For example, if we define a few
classes and an istance:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class A(object): a1 = &quot;A&quot;
...
&gt;&gt;&gt; class B(object): a2 = &quot;B&quot;
...
&gt;&gt;&gt; class C(A,B):    a3 = &quot;C(A,B)&quot;
...
&gt;&gt;&gt; class D(C):      a4 = &quot;D(C)&quot;
...
&gt;&gt;&gt; d = D()
&gt;&gt;&gt; d.a5 = &quot;instance d of D&quot;
</pre>
</blockquote>
<p>Then we can test the relations:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; issubclass(D,C)
True
&gt;&gt;&gt; issubclass(D,A)
True
&gt;&gt;&gt; issubclass(A,B)
False
&gt;&gt;&gt; issubclass(d,D)
[...]
TypeError: issubclass() arg 1 must be a class
</pre>
</blockquote>
<p>The interesting question now--the one necessary for understanding
the contrast between superclasses and metaclasses--is how an
attribute like 'd.attr' is resolved.  For simplicity, we discuss
only the standard look-rule, not the fallback to '.__getattr__()'.
The first step in such resolution is to look in 'd.__dict__' for the
name 'attr'.  If found, that's that; but if not, something fancy
needs to happen, e.g.:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; d.__dict__, d.a5, d.a1
({'a5': 'instance d'}, 'instance d', 'A')
</pre>
</blockquote>
<p>The trick to finding an attribute that isn't attached to an instance
is to look for it in the class of the instance, then after that in
all the superclasses.  The order in which superclasses are checked
is called the -method resolution order- for the class.  You can look
at it with the (meta)method '.mro()' (but only from class objects):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; [k.__name__ for k in d.__class__.mro()]
['D', 'C', 'A', 'B', 'object']
</pre>
</blockquote>
<p>In other words, the access to 'd.attr' first looks in 'd.__dict__',
then in 'D.__dict__', 'C.__dict__', 'A.__dict__', 'B.__dict__', and
finally in 'object.__dict__'.  If the name is not found in any of
those places, an 'AttributeError' is raised.</p>
<p>Notice that metaclasses were never mentioned in the lookup procedure.</p>
</blockquote>
</div>
<div class="section" id="metaclasses-versus-ancestors">
<h1><a name="metaclasses-versus-ancestors">METACLASSES VERSUS ANCESTORS</a></h1>
<blockquote>
<p>Here is a simple example of normal inheritance.  We define a 'Noble'
base class, with subclasses such as 'Prince', 'Duke', 'Baron', etc.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for s in &quot;Power Wealth Beauty&quot;.split(): exec '%s=&quot;%s&quot;'%(s,s)
...
&gt;&gt;&gt; class Noble(object):      # ...in fairy tale world
...     attributes = Power, Wealth, Beauty
...
&gt;&gt;&gt; class Prince(Noble):
...     pass
...
&gt;&gt;&gt; Prince.attributes
('Power', 'Wealth', 'Beauty')
</pre>
</blockquote>
<p>The class 'Prince' inherits the attributes of the class 'Noble'.  An
instance of 'Prince' still follows the lookup chain discussed above:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; charles=Prince()
&gt;&gt;&gt; charles.attributes        # ...remember, not the real world
('Power', 'Wealth', 'Beauty')
</pre>
</blockquote>
<p>If the 'Duke' class should happen to have a custom metaclasses, it
can obtain some attributes that way:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Nobility(type): attributes = Power, Wealth, Beauty
...
&gt;&gt;&gt; class Duke(object): __metaclass__ = Nobility
...
</pre>
</blockquote>
<p>As well as being a class, 'Duke' is an instance of the metaclass
'Nobility'--attribute lookup proceeds as with any object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Duke.attributes
('Power', 'Wealth', 'Beauty')
</pre>
</blockquote>
<p>But 'Nobility' is -not- a superclass of 'Duke', so there is no
reason why an -instance- of 'Duke' would find 'Nobility.attributes':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Duke.mro()
[&lt;class '__main__.Duke'&gt;, &lt;type 'object'&gt;]
&gt;&gt;&gt; earl = Duke()
&gt;&gt;&gt; earl.attributes
[...]
AttributeError: 'Duke' object has no attribute 'attributes'
</pre>
</blockquote>
<p>The availability of metaclass attributes is not transitive; i.e. the
attributes of a metaclass are available to its instances, but not to
the instances of the instances.  Just this is the main difference
between metaclasses and superclasses.  A diagram emphasizes the
orthogonality of inheritence and instantiation:</p>
<div class="figure">
<p><img alt="fig1.png" src="fig1.png" /></p>
</div>
<p>Figure 1--Instantiation versus Inheritance</p>
<p>Since 'earl' still has a class, you can indirectly retrieve the
attributes, however:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; earl.__class__.attributes
</pre>
</blockquote>
<p>Figure 1 contrasts simple cases where -either- inheritance or
metaclasses are involved, but not both.  Sometimes, however, a class
C has both a custom metaclass M and a base class B:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M(type):
...     a = 'M.a'
...     x = 'M.x'
...
&gt;&gt;&gt; class B(object): a = 'B.a'
...
&gt;&gt;&gt; class C(B): __metaclass__=M
...
&gt;&gt;&gt; c=C()
</pre>
</blockquote>
<p>Graphically:</p>
<div class="figure">
<p><img alt="fig2.png" src="fig2.png" /></p>
<p class="caption">Figure 2--Combined Superclass and Metaclass</p>
</div>
<p>From the prior explanation, we could imagine that 'C.a' would
resolve to -either- 'M.a' or 'B.a'.  As it turns out, lookup on a
class follows its MRO before it looks in its instantiating
metaclass:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.a, C.x
('B.a', 'M.x')
&gt;&gt;&gt; c.a
'B.a'
&gt;&gt;&gt; c.x
[...]
AttributeError: 'C' object has no attribute 'x'
</pre>
</blockquote>
<p>You can still enforce a attribute value using a metaclass, you just
need to set it on the class object being instantiated rather than as
an attribute of the metaclass:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M(type):
...     def __init__(cls, *args):
...         cls.a = 'M.a'
...
&gt;&gt;&gt; class C(B): __metaclass__=M
...
&gt;&gt;&gt; C.a, C().a
('M.a', 'M.a')
</pre>
</blockquote>
</blockquote>
</div>
<div class="section" id="more-on-class-magic">
<h1><a name="more-on-class-magic">MORE ON CLASS MAGIC</a></h1>
<blockquote>
<p>The fact that the instantiation constraint is weaker than the
inheritance constraint is essential for implementing the special
methods like '.__new__()', '.__init__()', '.__str__()', etc.  We
will discuss the '.__str__()' method; an analysis is similar for the
other special methods.</p>
<p>Readers probably know that the printed representation of a class
object can be modified by overring its '.__str__()' method.  In the
same sense, the printed representation of a class can be modified by
overring the '.__str__()' methods of its metaclass.  For instance:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Printable(type):
...    def __str__(cls):
...        return &quot;This is class %s&quot; % cls.__name__
...
&gt;&gt;&gt; class C(object): __metaclass__ = Printable
...
&gt;&gt;&gt; print C       # equivalent to print Printable.__str__(C)
This is class C
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; print c       # equivalent to print C.__str__(c)
&lt;C object at 0x40380a6c&gt;
</pre>
</blockquote>
<p>The situation can be represented with the following diagram:</p>
<div class="figure">
<p><img alt="fig3.png" src="fig3.png" /></p>
<p class="caption">Figure 3-Metaclasses and Magic Methods</p>
</div>
<p>From the previous discussion, it is clear that the '.__str__()'
method in 'Printable' cannot override the '.__str__()' method in C,
which is inherited from 'object' and therefore has precedence;
printing 'c' still gives the standard result.</p>
<p>If C inherited its '.__str__()' method from 'Printable' rather than
from 'object', it would cause a problem:  'C' instances do not have
a '.__name__' attribute and printing 'c' would generate an error.
Of course, you could still define a '.__str__()' method in 'C' that
would change the way 'c' prints.</p>
</blockquote>
</div>
<div class="section" id="classmethods-vs-metamethods">
<h1><a name="classmethods-vs-metamethods">CLASSMETHODS VS. METAMETHODS</a></h1>
<blockquote>
<p>Another common confusion arise between Python classmethods and
methods defined in a metaclass, best called -metamethods-.</p>
<p>Consider this example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M(Printable):
...     def mm(cls):
...         return &quot;I am a metamethod of %s&quot; % cls.__name__
...
&gt;&gt;&gt; class C(object):
...     __metaclass__=M
...     def cm(cls):
...         return &quot;I am a classmethod of %s&quot; % cls.__name__
...     cm=classmethod(cm)
...
&gt;&gt;&gt; c=C()
</pre>
</blockquote>
<p>Part of the confusion is due to the fact that in the Smalltalk
terminology, 'C.mm' would be called a &quot;class method of 'C'.&quot;
Python classmethods are a different beast, however.</p>
<p>The metamethod &quot;mm&quot; can be invoked both from either the metaclass or
from the class, but not from the instance.  The classmethod can be
called both from the class and from its instances (but does not
exist in the metaclass).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print M.mm(C)
I am a metamethod of C
&gt;&gt;&gt; print C.mm()
I am a metamethod of C
&gt;&gt;&gt; print c.mm()
[...]
AttributeError: 'C' object has no attribute 'mm'
&gt;&gt;&gt; print C.cm()
I am a classmethod of C
&gt;&gt;&gt; print c.cm()
I am a classmethod of C
</pre>
</blockquote>
<p>Also, the metamethod is retrieved by 'dir(M)' but not by 'dir(C)'
whereas the classmethod is retrieved by 'dir(C)' and 'dir(c)'.</p>
<p>You can only call the metaclass method that are defined in the
class MRO by dispatching on the metaclass (built-ins like 'print' do
this behind the scenes):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print C.__str__()
[...]
TypeError: descriptor '__str__' of 'object' object needs an argument
&gt;&gt;&gt; print M.__str__(C)
This is class C
</pre>
</blockquote>
<p>It is important to notice that this dispatch conflict is not limited
to magic methods.  If we change 'C' by adding an attribute 'C.mm',
the same issue exists (it does not matter if the name is a regular
method, classmethod, staticmethod, or simple attribute):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.mm=lambda self: &quot;I am a regular method of %s&quot; % self.__class__
&gt;&gt;&gt; print C.mm()
[...]
TypeError: unbound method &lt;lambda&gt;() must be called with
    C instance as first argument (got nothing instead)
</pre>
</blockquote>
</blockquote>
</div>
<div class="section" id="conflicting-metaclasses">
<h1><a name="conflicting-metaclasses">CONFLICTING METACLASSES</a></h1>
<blockquote>
<p>Once you work seriously with metaclasses, you will be bitten at
least once by metaclass/metatype conflicts.  Consider a class 'A'
with metaclass 'M_A' and a class 'B' with metaclass 'M_B'; suppose
we derive 'C' from 'A' and 'B'.  The question is:  what is the
metaclass of 'C'?  Is it 'M_A' or 'M_B'?</p>
<p>The correct answer (see &quot;Putting metaclasses to work&quot; for a
discussion) is 'M_C', where 'M_C' is a metaclass that inherits from
'M_A' and 'M_B', as in the following graph:</p>
<dl>
<dt>{Figure 4--Avoiding the Metaclass Conflict:</dt>
<dd><a class="reference" href="http://gnosis.cx/secret/metaclass-conflict.gif">http://gnosis.cx/secret/metaclass-conflict.gif</a>}</dd>
</dl>
<p>However, Python does not (yet) automatically create 'M_C'.  Instead,
it raises a 'TypeError', warning the programmer of the conflict:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M_A(type): pass
...
&gt;&gt;&gt; class M_B(type): pass
...
&gt;&gt;&gt; class A(object): __metaclass__ = M_A
...
&gt;&gt;&gt; class B(object): __metaclass__ = M_B
...
&gt;&gt;&gt; class C(A,B): pass    # Error message less specific under 2.2
[...]
TypeError: metaclass conflict: the metaclass of a derived class must
    be a (non-strict) subclass of the metaclasses of all its bases
</pre>
</blockquote>
<p>The metatype conflict can be avoided by manually creating the needed
metaclass for 'C':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; M_AM_B = type(&quot;M_AM_B&quot;, (M_A,M_B), {})
&gt;&gt;&gt; class C(A,B): __metaclass__ = M_AM_B
...
&gt;&gt;&gt; type(C)
&lt;class 'M_AM_B'&gt;
</pre>
</blockquote>
<p>The resolution of metatype conflicts becomes more complicated when
you wish to &quot;inject&quot; additional metaclasses into a class, beyond
those in its ancestors.  As well, depending on the metaclasses of
parent classes, redundant metaclasses can occur--both identical
metaclasses in different ancestors and superclass/subclass
relationships among metaclasses.  The module [noconflict] is
available to help users resolve these issues in a robust and
automatic way (see Resources).</p>
</blockquote>
</div>
<div class="section" id="conclusion">
<h1><a name="conclusion">CONCLUSION</a></h1>
<blockquote>
There are quite a number of warnings and corner cases discussed in
this article.  Working with metaclasses requires a certain degree of
trial-and-error before the behavior becomes wholly intuitive.
However, the issues are by no means intractable--this fairly short
article touches on most of the pitfalls.  Play with the cases
yourself.  You will find, at the end of the day, that whole new
realms of program generalization are available with metaclasses; the
gains are well worth the few dangers.</blockquote>
</div>
<div class="section" id="resources">
<h1><a name="resources">RESOURCES</a></h1>
<blockquote>
<p>We continue to recomment this useful book on metaclasses:</p>
<blockquote>
<em>Putting Metaclasses to Work</em> by Ira R. Forman, Scott Danforth,
Addison-Wesley 1999</blockquote>
<p>For metaclasses in Python specifically, Guido van Rossum's
essay, <em>Unifying types and classes in Python 2.2</em> is useful:</p>
<blockquote>
<a class="reference" href="http://www.python.org/2.2/descrintro.html">http://www.python.org/2.2/descrintro.html</a></blockquote>
<p>Raymond Hettinger has written an excellent article on the
-descriptor protocol- introducted in Python 2.2.  Descriptors
are a means to to alter the behavior of attribute/method
access, which is an interesting programming technique in
itself.  But of particular value relative to this article is
Hettinger's explanation of the lookup chain that underlies
Python's concept of OOP:</p>
<blockquote>
<a class="reference" href="http://users.rcn.com/python/download/Descriptor.htm">http://users.rcn.com/python/download/Descriptor.htm</a></blockquote>
<p>Michele's [noconflict] module is discussed in the online Active
State Python Cookbook.  This module lets users automatically resolve
metatype conflicts.</p>
<blockquote>
<a class="reference" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/204197">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/204197</a></blockquote>
<p>The Gnosis Utilities library contains a number of tools for
working with metaclasses, generally within the [gnosis.magic]
subpackage.  You may download the last stable version of whole
package from:</p>
<blockquote>
<a class="reference" href="http://gnosis.cx/download/Gnosis_Utils-current.tar.gz">http://gnosis.cx/download/Gnosis_Utils-current.tar.gz</a></blockquote>
<p>Or browse the experimental branch, which includes a version of
[noconflict] at:</p>
<blockquote>
<a class="reference" href="http://gnosis.cx/download/gnosis/">http://gnosis.cx/download/gnosis/</a></blockquote>
<p>Coauthor Michele has written an article on the new method
resolution order (MRO) algorithm in Python 2.3.  While most
programmers can remain blissfully ignorant on the details of
the changes, it is worthwhile for all Python programmers to
understand the concept of MRO--and perhaps have an inkling
that better and worse approaches exist:</p>
<blockquote>
<a class="reference" href="http://www.python.org/2.3/mro.html">http://www.python.org/2.3/mro.html</a></blockquote>
</blockquote>
</div>
<div class="section" id="about-the-authors">
<h1><a name="about-the-authors">ABOUT THE AUTHORS</a></h1>
<blockquote>
<p><img alt="img_dqm.png" src="img_dqm.png" /></p>
<p>David Mertz thought his brain would melt when he wrote about
continuations or semi-coroutines, but he put the gooey mess
back in his skull cavity and moved on to metaclasses.  David
may be reached at <a class="reference" href="mailto:mertz&#64;gnosis.cx">mertz&#64;gnosis.cx</a>; his life pored over at
<a class="reference" href="http://gnosis.cx/publish/">http://gnosis.cx/publish/</a>.  Suggestions and recommendations on
this, past, or future, columns are welcomed.  His book <em>Text
Processing in Python</em> has a webpage at <a class="reference" href="http://gnosis.cx/TPiP/">http://gnosis.cx/TPiP/</a>.</p>
<p><img alt="m-simionato.png" src="m-simionato.png" /></p>
<p>Michele Simionato is a plain, ordinary, theoretical physicist
who was driven to Python by a quantum fluctuation that could
well have passed without consequences, had he not met David
Mertz.  Now he has been trapped in Python gravitational field.
He will let his readers judge the final outcome.  Michele can
be reached at <a class="reference" href="http://www.phyast.pitt.edu/~micheles/">http://www.phyast.pitt.edu/~micheles/</a></p>
</blockquote>
</div>
</div>
</body>
</html>
