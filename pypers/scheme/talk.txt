The R6RS module system
===============================================

:Talk given at: EuroLisp Symposium 2009
:By: Michele Simionato
:date: 2009-05-28

.. include:: <s5defs.txt>
.. footer:: Michele Simionato, EuroLisp 2009

Part I
--------------------------

The easy things about the R6RS module system

.. image:: Jigsaw.png

Part II
----------------------------------------

Explicit phasing and the tower of meta-levels

.. image:: exploding-head.jpg
   :width: 400

Part III
--------------------------

Porting libraries between different R6RS implementations

.. image:: aps_lib_03.jpg
   :width: 500

Self-presentation
----------------------------

Who am I?

.. image:: faccina.jpg


About me
----------------------------

A hobbyist Scheme programmer

.. class:: incremental

- I use Python at work
- I started programming in Scheme 5+ years ago
- I am writing "The Adventures of a Pythonista in Schemeland" on Artima
- the blog posts will become a book
- I think my experience is relevant for new 
  R6RS programmers

What I have done in Scheme
--------------------------------------

- written a module called sweet-macros as sugar over syntax-case

.. class:: incremental

- written various support libraries for the Adventures
- fought a lot with portability issues
- experimented with cutting edge features (found bugs!)
- made a lot of noise in various mailing lists
- got *impressive* support from Scheme implementors :-)

Disclaimer
------------------------------------------------

This is as a talk for **macro** writers who want to write
portable R6RS code. It assumes:

.. class:: incremental

 - knowledge of (R5RS) Scheme
 - knowledge of Scheme macros
 - no knowledge of R6RS Scheme
 - no knowledge of the R6RS module system

Part I: no macros or simple macros
----------------------------------------------------

.. code-block:: scheme

 $ cat my-lib.sls
 #!r6rs
 (library (my-lib)
 (export a b)
 (import (rnrs)); standard R6RS bindings
 (define a 42)
 (define b 0)
 (display "my-lib instantiated!\n")
 )

Import syntax (I)
--------------------------------------

.. code-block:: scheme

   (import (rnrs) (my-lib))
   (display (+ a b)) ;=> 42

.. class:: incremental

- import with a prefix:

  .. code-block:: scheme

   (import (rnrs) (my-lib (prefix my-lib:)))
   (display my-lib:a) ;=> 42

- import only a specific sets of names:

  .. code-block:: scheme

   (import (rnrs) (only (my-lib) a))
   (display a) ;=> 42

Import syntax (II)
----------------------------------------

There are other easy features

.. class:: incremental

- renaming a set of identifiers:

  .. code-block:: scheme

   (import (rnrs) (rename (my-lib) (a ml:a)))
   (display ml:a) ;=> 42

- excluding a set of identifiers:

  .. code-block:: scheme

   (import (rnrs) (exclude (my-lib) a))
   (display b) ;=> 0

Limitations
----------------------------------------

- how to map libraries to the file system is not specified

.. class:: incremental

- support for implementation-specific files (.IMPL.sls convention)
  is in its infancy

- support for importing a specific version is in fieri

- ``(export *)`` not available

  + you must list explicitly all the exported identifiers
  + at least, it makes writing IDEs easier

- no introspection API 

  + no (exported-vars my-lib)
  + no (exported-macros my-lib)

Let's start with macros now
----------------------------------

They are not so scary ...

.. image:: mantid.jpg
   :width: 560

R6RS modules and syntax-rules
---------------------------------------

A simple example:

.. code-block:: scheme

 $ cat my-lib.ss

 #!r6rs
 (library (my-lib)
 (export double)
 (import (rnrs))
 (define-syntax double
   (syntax-rules ()
    ((_ x) (list x x))))
 )

Macro usage
-------------------------

99.99% of times there are no problems with syntax-rules macros:

.. code-block:: scheme

 $ cat example.sls
 (import (rnrs) (my-lib))
 (display (double 1));  prints (1 1)

I will show an issue with a second order syntax-rules macro
later on

Why all the fuss?
-------------------------------------------------

- the most common problem is when you have macro transformers
  depending on helper variables:

.. code-block:: scheme

   > (let ()
       (define a 42)
       (define-syntax m (lambda (x) a))
       (m))
   error: identifier a out of context

.. class:: incremental

- Why the identifier is not available to the macro?

Because of phase separation
-------------------------------

.. code-block:: scheme

  (let ()
   (define a 42)                    ; run-time
   (define-syntax m (lambda (x) a)) ; macro-def-time
   (m))

.. class:: incremental

 - ``a`` is defined too late!

 - regular definitions (both define and let) are performed
   at run-time

 - macro definitions (both define-syntax
   and let-syntax) are performed at compile-time

Phase errors
-------------------------------------

One must be careful not to mix expand-time
and run-time

.. image:: salvador-dali-clock.jpg 

Beware! the REPL may betray you
-------------------------------------------

.. code-block:: scheme

 $ mzscheme # or larceny
 > (define a 42)
 > (let-syntax ((m (lambda (x) a))) (m))
 reference to undefined identifier: a
  
but

.. code-block:: scheme

  $ ikarus # or ypsilon
  > (define a 42)
  > (let-syntax ((m (lambda (x) a))) (m))
    42

Old Scheme behavior
----------------------------------------------------

Phase separation is a "new" thing; for 
instance Guile 1.8 has not phase separation:

.. code-block:: scheme

 guile> (let ()
          (define a 42)
          (define-macro (m) a) 
          (m))
 42

(the next version of Guile will have phase separation
and some support for R6RS Scheme).

To cope with phase separation
--------------------------------------

Put the helper object (value, function, macro)
in a different module and import it at expand time

.. code-block:: scheme

 > (import (for (my-lib) expand))
 > (let-syntax ((m (lambda (x) a))) (m))
   42

.. class:: incremental

- slightly inconvenient
- I wish we could include libraries in scripts :-(

So everthing is settled, right?
-------------------------------------

Not really, there are a few R6RS surprises ...

.. image:: joker_13.jpg
   :width: 300

The R6RS specification is loose
-------------------------------------------------------

An example:

.. code-block:: scheme

  (import (for (only (my-lib) a) expand))
  (display (let-syntax ((m (lambda (x) a))) (m)))
  (display a)
  
.. class:: incremental

- R6RS implementations are required to support 
  ``(import (for (my-lib) expand))`` *syntactically*
- they are not required to honor it!
- this code does not compile on PLT Scheme and Larceny
- but it compiles and runs fine on all other systems!

Lack of phase specification
---------------------------------------------

- systems based on psyntax (and Ypsilon) import the identifiers at 
  all phases simultaneously

.. class:: incremental

- you cannot import a name into a specific phase
- I will argue this a good thing because it avoids the tower
  of meta-levels (later)
- the R6RS forbids reusing the same
  name with different bindings in different phases anyway


Part II
----------------------------

Fasten your seatbelts now ...

The Dark Tower of meta-levels
-----------------------------------------------------

.. image:: DarkTower.jpg

Meta-levels in macros
-------------------------------------------

.. code-block:: scheme

  (define-syntax macro                ; meta-level 0
     (lambda (x)                      ; meta-level 1
       (syntax-case x (literals ...)  ; meta-level 1
         (pattern                     ; meta-level 1
          fender                      ; meta-level 1
          #'template))))              ; meta-level 0

.. class:: incremental

- the right hand side of macro definition refers to names which are
  one meta-level up

- inside a template one goes back one meta-level

- there is an arbitrary number of positive meta-levels,
  depending on the level of nesting

An example at meta-level 2
-----------------------------------------------------

.. code-block:: scheme

  (import (for (only (my-lib) a) (meta 2))
          (for (only (my-lib) b) (meta 1)))
  (define-syntax m1       ;; level 0
   (lambda (x1)           ;; level 1
      (define-syntax m2   ;; level 1
         (lambda (x2) a)) ;; level 2
      (+ (m2) b)))        ;; level 1
  (display                ;; level 0
    (m1)                  ;; level 1
  )                       ;; level 0

Levels/Phases are ordered
---------------------------------------

- innermost levels are compiled first
- outermost templates are evaluated later

.. image:: list-comprehension.jpg 

A subtle second order macro
---------------------------------------------

.. code-block:: scheme

 (define-syntax very-static-table
  (syntax-rules ()
    ((_ (name value) ...) 
      (syntax-rules (<names> name ...)
        ((_ <names>) '(name ...))
        ((_ name) value) ...))))

 (define-syntax color
  (very-static-table (red 0) (green 1) (blue 2)))

 (display (color <names>)) ;=> (red green blue)
 (display (color red)) ;=> 0

Phase levels
---------------------------------------

.. code-block:: scheme

 (define-syntax very-static-table      ;; level 0
  (syntax-rules ()                     ;; level 1
    ((_ (name value) ...)              ;; level 1
      (syntax-rules (<names> name ...) ;; level 0
        ((_ <names>)                   ;; level 0
          '(name ...))                 ;; level -1
        ((_ name)                      ;; level 0
          value)                       ;; level -1
          ...))))

Needs ``(import (for (only (rnrs) quote) (meta -1)))``

Ikarus, Mosh, IronScheme ...
---------------------------------------------------

Such implementations do not need to worry about
the Dark Tower. I think they will have a great future.

.. image:: tower_of_babel.jpg

You get the worse of two worlds
--------------------------------------------

Writers of portable code

.. class:: incremental

- cannot rely on the simplicity of implicit phasing
- cannot rely on the full power of explicit phasing
- cannot rely on a clearly defined import semantics
- apparently it was politically impossible to do better

Part III
-------------------------

Porting macro-rich R6RS libraries can be a rather heavy task ...

.. image:: mule.jpg

Beware of negative metalevels
-------------------------------

.. code-block:: scheme

 (import (rnrs) (for (rnrs) (meta -1))
 (for (sweet-macros helper1) (meta -1) (meta 0) (meta 1)))

.. image:: sweet-macros.png
   :width: 695

Beware of bugs
---------------------------------------------------

I have found many bugs in different R6RS implementations
while porting my ``sweet-macros`` library:

- Ikarus (1)
- Ypsilon (4)
- PLT (3)
- Larceny (1)

*All fixed within hours!*

Other difficulties I encountered
------------------------------------------

- I had to wait for the .IMPL.sls convention to be implemented

- I am generating the helper modules required by PLT/Larceny
  from the Ikarus/Ypsilon module

While writing the APS libraries I have found many non-portable
behaviours:

.. class:: incremental

- in implementations based on psyntax and in Ypsilon a module
  is visited only if one of its macros is used

More non-portable behavior
----------------------------------------------------

.. class:: incremental

- in implementations others than PLT, side-effects
  can leak through phases

- the number of times a library is instantiated is
  totally implementation-dependent

- it also depends if you are using separate compilation
  or not.

An example:

.. code-block:: scheme

 $ cat two-phases.ss
 (import (for (my-lib) expand run))

Different runs
--------------------------------------------

::

 $ plt-r6rs two-phases.ss
 my-lib instantiated!
 my-lib instantiated!

 $ larceny -r6rs -program two-phases.ss
 my-lib instantiated!

 $ ypsilon --r6rs two-phases.ss
 my-lib instantiated!

 $ ikarus --r6rs-script two-phases.ss


References
------------------------------

You can find all the details in my Adventures

- http://www.artima.com
- http://www.phyast.pitt.edu/~micheles/scheme/TheAdventuresofaPythonistainSchemeland.pdf
- http://www.phyast.pitt.edu/~micheles/scheme/sweet-macros.zip

and of course in the R6RS document

- http://www.r6rs.org/final/html/r6rs/r6rs.html
