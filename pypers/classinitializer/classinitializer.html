<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Let's keep it simple (or, how to do metaprogramming without metaclasses)</title>
<meta name="author" content="Michele Simionato" />
<meta name="date" content="10 July 2006" />

</head>
<body>
<div class="document" id="let-s-keep-it-simple-or-how-to-do-metaprogramming-without-metaclasses">
<h1 class="title">Let's keep it simple (or, how to do metaprogramming without metaclasses)</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Michele Simionato</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>10 July 2006</td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>0.5</td></tr>
</tbody>
</table>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#introduction" id="id7" name="id7">Introduction</a></li>
<li><a class="reference" href="#about-class-initialization" id="id8" name="id8">About class initialization</a></li>
<li><a class="reference" href="#please-stop-abusing-metaclasses" id="id9" name="id9">Please stop abusing metaclasses</a></li>
<li><a class="reference" href="#the-classinitializer-decorator" id="id10" name="id10">The <tt class="docutils literal"><span class="pre">classinitializer</span></tt> decorator</a></li>
<li><a class="reference" href="#tricky-points-and-caveats" id="id11" name="id11">Tricky points and caveats</a></li>
<li><a class="reference" href="#example-initializing-records" id="id12" name="id12">Example: initializing records</a></li>
<li><a class="reference" href="#references" id="id13" name="id13">References</a></li>
<li><a class="reference" href="#questions-and-answers" id="id14" name="id14">Questions and answers</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="introduction" name="introduction">Introduction</a></h1>
<p>A few days ago I was at CERN, at the EuroPython 2006 conference. The
conference was good, the organization perfect, the talks of
very high level, the people extremely nice.</p>
<p>Nevertheless, I saw a trend growing in the Python community
that disturbed me a little and motivated
me to write this paper. The trend I am alluding to, is the trend
towards <em>cleverness</em>. Unfortunately, whereas once cleverness was
mostly confined to Zope and Twisted, now is appearing everywhere.</p>
<p>I personally don't have anything against cleverness for
experimental projects and learning exercises. But I have a gripe
against cleverness when I see it deployed in production frameworks
that I am forced to cope with as an user.</p>
<p>Cleverness means making things more complicated than
needed, making things more fragile, making the learning curve
steeper and, worse of all, making debugging harder.</p>
<p>In this short paper I will try to give my small contribution against
cleverness, at least in a case where I have some expertise, i.e.
against metaclass abuses.</p>
<p>Let me say that I consider <em>metaclass abuse</em> any usage of a metaclass
in a situation where you could have solved the problem without a
metaclass.</p>
<p>I feel in part responsible for some of the abuses I see floating
around in newsgroups, in conferences and in frameworks source code,
because of my (together with David Mertz) contribution in popularizing
metaclasses, so I have decided to make amend with this paper.</p>
<p>This paper consider only one kind of metaprogramming technique, i.e.
the creation at runtime of classes with attributes and methods which
are dynamically generated. Contrarily to popular belief, this is a job
where most of the time you <em>don't need</em> and you <em>don't want</em> a custom
metaclass, as I will argue in the next section.</p>
<p>The paper is intended for a double target of readers:</p>
<ul class="simple">
<li>average programmers, that would benefit from knowing a few
meta-programming tricks, but are scared off by brain melting concepts;</li>
<li>clever programmers, which are actually too clever and should know
better <a class="footnote-reference" href="#id2" id="id1" name="id1">[1]</a>.</li>
</ul>
<p>If you are a lazy reader, your may just read the next paragraph and
the last one, and forget about the details.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[1]</a></td><td>The problem is that it is easy to be clever whereas it takes a
lot of time to become unclever. For instance, it took me a few
months to understand how to use metaclasses, but a few years
to understand how <em>not</em> to use them.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="about-class-initialization" name="about-class-initialization">About class initialization</a></h1>
<p>By class initialization I mean setting attributes and methods of
classes immediately after their creation, once and for all <a class="footnote-reference" href="#id4" id="id3" name="id3">[2]</a>.</p>
<p>There are various common situations where a programmer may want to
initialize her classes: for instance, she may want to set some default class
attributes according to parameters read from a configuration
file, or she may want to set class properties according to the fields
in a database table.</p>
<p>The easiest way to perform class initialization
is by using an imperative style: one first creates the class,
and then adds the dynamically generated methods and attributes.</p>
<p>For instance, if the problem is to generate properties for an <tt class="docutils literal"><span class="pre">Article</span></tt>
record class, an imperative solution is something like the following:</p>
<pre class="literal-block">
class Article(object):
   def somemethod(self):
       pass
   ...

set_properties(Article, [('title', str), ('author', str), ('date', date)])
</pre>
<p>However, since (proper) class initialization should occur only once,
it does not need to be distinguished by class
creation, and it may be argued that it
should be treated  with a declarative style, with a syntax like the following:</p>
<pre class="literal-block">
class Article(object):

   def_properties([('title', str), ('author', str), ('date', date)])

   def somemethod(self):
       pass

   ...
</pre>
<p>This paper is about providing a generic facility to define <em>class initializers</em>
to be used in the class scope, such as <tt class="docutils literal"><span class="pre">def_properties</span></tt>.</p>
<p><strong>Disclaimer:</strong> the advantage of the solution I propose here,
is that it works in current Python and it is less clever than
metaclasses, Still I would consider it a little too clever. A clean solution
to the problem would be to add class decorator to the language. That
would allow a syntax like the following:</p>
<pre class="literal-block">
&#64;with_properties([('title', str), ('author', str), ('date', date)])
class Article(object):
   def somemethod(self):
       pass
   ...
</pre>
<p>However, it is not sure at the moment if and when Guido will add class
decorators, so my proposed solution is the lesser of two evils.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id4">[2]</a></td><td>Well, in Python methods and attributes can always be changed at
a later time, but let us assume that nobody is cheating here.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="please-stop-abusing-metaclasses" name="please-stop-abusing-metaclasses">Please stop abusing metaclasses</a></h1>
<p>Everybody knows how to initialize instances. One just overrides
the class <tt class="docutils literal"><span class="pre">__init__</span></tt> method. Since classes are instances of metaclasses,
the natural solution to the class initialization problem seems to be
to use a custom metaclass and to override its <tt class="docutils literal"><span class="pre">__init__</span></tt> method.</p>
<p>Un fortunately, things are not so easy, because of inheritance. The
issue is that once you have defined a custom metaclass for your base
class, all the derived classes will inherit the metaclass, so the
initialization code will be run on all derived classes, magically and
implicitly.</p>
<p>That may be fine in specific circumstances (for instance,
suppose you have to register in your framework all the classes you
define: using a metaclass ensures that you cannot forget to register a
derived class), however, in many cases you may not like this behavior because:</p>
<ol class="arabic simple">
<li>you may believe that <em>explicit is better than implicit</em>;</li>
<li>if the derived classes have the same dynamic class attributes of
the base class, implicitly setting them again for each derived
class is a waste, since they would be available anyway by
inheritance. This may be a real issue if the initialization code is
slow, possibly because it must access a database, or perform some
heavy computation: in this case one must add a check in the
metaclass code to see if the attributes were already set in
a parent class, but this adds plumbing and it does not give real
control on a per-class basis;</li>
<li>a custom metaclass will make your classes somewhat magic and
nonstandard: you may not want to increase your chances to incur in
metaclass conflicts, issues with <tt class="docutils literal"><span class="pre">__slots__</span></tt>, fights with (Zope)
extension classes and other guru-level intricacies <a class="footnote-reference" href="#id6" id="id5" name="id5">[3]</a>;</li>
<li>you feel that a custom metaclasses is overkill for the simple job
of class initialization and you would rather use a simpler solution.</li>
</ol>
<p>In other words,you should use a custom metaclass only when your real
intention is to have code running on derived classes without users of
those classes noticing it. If this is not your case, please don't a
metaclass and  make your life (as well your users) happier.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="id6">[3]</a></td><td>Metaclasses are more fragile than many people realize. I
personally have never used them for production code, even
after four years of usage in experimental code.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id10" id="the-classinitializer-decorator" name="the-classinitializer-decorator">The <tt class="docutils literal"><span class="pre">classinitializer</span></tt> decorator</a></h1>
<p>The aim of this paper is to provide a decorator called
<tt class="docutils literal"><span class="pre">classinitializer</span></tt> that can be used to define
class initializers, i.e. procedures taking classes and setting their
attributes and methods. In order to be concrete, consider the following
class initializer example:</p>
<pre class="literal-block">
def set_defaults(cls, **kw):
    for k, v in kw.iteritems():
        setattr(cls, k, v)
</pre>
<p>You may use it imperatively, right after a class definition:</p>
<pre class="literal-block">
class ClassToBeInitialized(object):
    pass

set_defaults(ClassToBeInitialized, a=1, b=2)
</pre>
<p>However the imperative solution has a few drawbacks:</p>
<ol class="arabic simple">
<li>it does not comply with DRY, i.e. the class name is repeated
and if I change it during refactoring, I have to change it (at
least) twice;</li>
<li>readability is suboptimal: since class definition and class
initialization are separated, for long class definitions I may end
up not seeing the last line;</li>
<li>it feels wrong to first define something and immediately right
after to mutate it.</li>
</ol>
<p>Luckily, the <tt class="docutils literal"><span class="pre">classinitializer</span></tt> decorator provides a much nicer
declarative solution. The decorator performs some deep magic and converts
<tt class="docutils literal"><span class="pre">set_defaults(cls,</span> <span class="pre">**kw)</span></tt> into a function that can be
used at the top scope into a class definition, with the current class
automagically passed as first parameter:</p>
<pre class="doctest-block">
&gt;&gt;&gt; &#64;classinitializer # add magic to set_defaults
... def set_defaults(cls, **kw):
...     for k, v in kw.iteritems():
...         setattr(cls, k, v)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; class ClassToBeInitialized(object):
...     set_defaults(a=1, b=2)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; ClassToBeInitialized.a
1
&gt;&gt;&gt; ClassToBeInitialized.b
2
</pre>
<p>If you have used Zope interfaces, you may have seen examples of class
initializers (I mean <tt class="docutils literal"><span class="pre">zope.interface.implements</span></tt>). In fact under the hood
<tt class="docutils literal"><span class="pre">classinitializer</span></tt> is implemented by using a trick copied from
<tt class="docutils literal"><span class="pre">zope.interface.advice</span></tt>, which credits Phillip J. Eby. The trick
uses the <tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hook, but it <em>does not use</em> a custom
metaclass, so that in this example <tt class="docutils literal"><span class="pre">ClassToBeInitialized</span></tt> will
continue to keep its original metaclass, i.e. the plain old regular
built-in metaclass <tt class="docutils literal"><span class="pre">type</span></tt> of new style classes:</p>
<pre class="doctest-block">
&gt;&gt;&gt; type(ClassToBeInitialized)
&lt;type 'type'&gt;
</pre>
<p>In principle, the trick also works for old style classes,
and it would be easy to write an implementation keeping old style
classes old style. However, since according  to Guido himself
<em>old style classes are morally deprecated</em>, the current implementation
automagically converts old style classes into new style classes:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class WasOldStyle:
...     set_defaults(a=1, b=2)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; WasOldStyle.a, WasOldStyle.b
(1, 2)
&gt;&gt;&gt; type(WasOldStyle)
&lt;type 'type'&gt;
</pre>
<p>One of the motivations for the <tt class="docutils literal"><span class="pre">classinitializer</span></tt> decorator, is to hide the
plumbing, and to make mere mortals able to implements their own
class initializers in an easy way, without knowing the details of
how class creation works and the secrets of the <tt class="docutils literal"><span class="pre">__metaclass__</span></tt>
hook. The other motivation, is that even for Python wizards it is very
unconvenient to rewrite the code managing the <tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hook
every time one writes a new class initializer. So I have decided to
use a decorator to allow separation of concerns and reuse of code.</p>
<p>As a final note, let me point out that the decorated version of
<tt class="docutils literal"><span class="pre">set_defaults</span></tt> is so smart  that it will continue to
work as the non-decorated version outside a class scope, provided that
you pass to it an explicit class argument.</p>
<pre class="doctest-block">
&gt;&gt;&gt; set_defaults(WasOldStyle, a=2)
&gt;&gt;&gt; WasOldStyle.a
2
</pre>
<p>In other words, you <em>might</em> continue to use the imperative style.</p>
<p>Here is the code for <tt class="docutils literal"><span class="pre">classinitializer</span></tt> (the point being that you
don't need to be able to understand it to use the decorator):</p>
<pre class="literal-block">
#&lt;_main.py&gt;

import sys

def classinitializer(proc):
  # basic idea stolen from zope.interface.advice, which credits P.J. Eby
  def newproc(*args, **kw):
      frame = sys._getframe(1)
      if '__module__' in frame.f_locals and not \
         '__module__' in frame.f_code.co_varnames: # we are in a class
          if '__metaclass__' in frame.f_locals:
            raise SyntaxError(&quot;Don't use two class initializers or\n&quot;
            &quot;a class initializer together with a__metaclass__ hook&quot;)
          def makecls(name, bases, dic):
             try:
                cls = type(name, bases, dic)
             except TypeError, e:
                if &quot;can't have only classic bases&quot; in str(e):
                   cls = type(name, bases + (object,), dic)
                else: # other strange errors, such as __slots__ conflicts, etc
                   raise
             proc(cls, *args, **kw)
             return cls
          frame.f_locals[&quot;__metaclass__&quot;] = makecls
      else:
          proc(*args, **kw)
  newproc.__name__ = proc.__name__
  newproc.__module__ = proc.__module__
  newproc.__doc__ = proc.__doc__
  newproc.__dict__ = proc.__dict__
  return newproc

#&lt;/_main.py&gt;
</pre>
<p>From the implementation it is clear how class initializers work:
when you call a class initializer inside a class, your are actually defining a
<tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hook that will be called by
the class' metaclass (typically <tt class="docutils literal"><span class="pre">type</span></tt>). The
metaclass will create the class (as a new style one) and
will pass it to the class initializer procedure.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="tricky-points-and-caveats" name="tricky-points-and-caveats">Tricky points and caveats</a></h1>
<p>Since class initializers (re)define the <tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hook,
they don't play well with classes that define a <tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hook
explicitly (as opposed to implicitly inheriting one). The issue is
that if a <tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hook is defined <em>after</em> the
class initializer, it <em>silently</em> overrides it.</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C:
...     set_defaults(a=1)
...     def __metaclass__(name, bases, dic):
...         cls = type(name, bases, dic)
...         print 'set_defaults is silently ignored'
...         return cls
...
set_defaults is silently ignored
&gt;&gt;&gt; C.a
Traceback (most recent call last):
  ...
AttributeError: type object 'C' has no attribute 'a'
</pre>
<p>This is unfortunate, but there is no general solution to this issue, and I will
simply document it (this is one of the reasons why I feel
class initializers to be a clever hack that should be dismissed if we
had class decorators).</p>
<p>On the other hand, if you call a class initializer
<em>after</em> the <tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hook, you will get an exception:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C:
...     def __metaclass__(name, bases, dic):
...         cls = type(name, bases, dic)
...         print 'calling explicit __metaclass__'
...         return cls
...     set_defaults(a=1)
...
Traceback (most recent call last):
   ...
SyntaxError: Don't use two class initializers or
a class initializer together with a__metaclass__ hook
</pre>
<p>I feel raising an error is preferable to silently overriding your
explicit <tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hook. As a consequence, you will get an
error if you try to use two class initializers at the same time, or
if you call twice the same one:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class C:
...     set_defaults(a=1)
...     set_defaults(b=2)
Traceback (most recent call last):
  ...
SyntaxError: Don't use two class initializers or
a class initializer together with a__metaclass__ hook
</pre>
<p>I feel raising an error to be better than having the second
initializer overriding the first one, i.e. in this example
to set the <tt class="docutils literal"><span class="pre">b</span></tt> attribute <em>without</em> setting the <tt class="docutils literal"><span class="pre">a</span></tt> attribute,
which would be very confusing.</p>
<p>Finally, let me show that there are no issues for inherited
<tt class="docutils literal"><span class="pre">__metaclass__</span></tt> hooks and for custom metaclasses:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class B: # a base class with a custom metaclass
...     class __metaclass__(type):
...         pass
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; class C(B): # a class with both a custom metaclass AND a class initializer
...     set_defaults(a=1)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; C.a
1
&gt;&gt;&gt; type(C)
&lt;class '_main.__metaclass__'&gt;
</pre>
<p>The class initializer does not disturb the metaclass of <tt class="docutils literal"><span class="pre">C</span></tt>, which is
the one inherited by its base <tt class="docutils literal"><span class="pre">B</span></tt>, and the inherited metaclass does
not disturb the class initializer, which does its job just fine.
You would have run into trouble, instead, if you tried to call <tt class="docutils literal"><span class="pre">set_defaults</span></tt>
directly in the base class.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id12" id="example-initializing-records" name="example-initializing-records">Example: initializing records</a></h1>
<p>In this section I will finally discuss the example I gave at the
beginning, about how to define record classes with a class initializer.
Here is the code for the class initializer, plus an helper function
for managing dates:</p>
<pre class="literal-block">
#&lt;_main.py&gt;

import datetime

&#64;classinitializer
def def_properties(cls, schema):
    &quot;&quot;&quot;
    Add properties to cls, according to the schema, which is a list
    of pairs (fieldname, typecast). A typecast is a
    callable converting the field value into a Python type.
    The initializer saves the attribute names in a list cls.fields
    and the typecasts in a list cls.types. Instances of cls are expected
    to have private attributes with names determined by the field names.
    &quot;&quot;&quot;
    cls.fields = []
    cls.types = []
    for name, typecast in schema:
        if hasattr(cls, name): # avoid accidental overriding
            raise AttributeError('You are overriding %s!' % name)
        def getter(self, name=name):
            return getattr(self, '_' + name)
        def setter(self, value, name=name, typecast=typecast):
            setattr(self, '_' + name, typecast(value))
        setattr(cls, name, property(getter, setter))
        cls.fields.append(name)
        cls.types.append(typecast)

def date(isodate): # add error checking if you like
    &quot;Convert an ISO date into a datetime.date object&quot;
    return datetime.date(*map(int, isodate.split('-')))

#&lt;/_main.py&gt;
</pre>
<p>As an example of application of the above class initializer,
I will define an <em>Article</em> record class with fields <em>title</em>, <em>author</em>
and <em>date</em>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; class Article(object):
...    # fields and types are dynamically set by the initializer
...    def_properties([('title', str), ('author', str), ('date', date)])
...    def __init__(self, values): # add error checking if you like
...        for field, cast, value in zip(self.fields, self.types, values):
...            setattr(self, '_' + field, cast(value))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a=Article(['How to use class initializers', 'M. Simionato', '2006-07-10'])
&gt;&gt;&gt; a.title
'How to use class initializers'
&gt;&gt;&gt; a.author
'M. Simionato'
&gt;&gt;&gt; a.date
datetime.date(2006, 7, 10)
&gt;&gt;&gt; a.date = '2006-07-11'
&gt;&gt;&gt; a.date
datetime.date(2006, 7, 11)
</pre>
<p>The point of using the class initializer is that the class is completely
dynamic and it can be built at runtime with a schema that can be read
from a configuration file or by introspecting a database table. You
have the advantages of a custom metaclass without any of the disadvantages.</p>
<p>It is also interesting to notice that this approach avoids inheritance
completely, so if you have a pre-existing record class and you want
to change its implementation to use this trick, it is enough to add
<tt class="docutils literal"><span class="pre">def_properties</span></tt>, you don't need any kind of (multiple)
inheritance.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id13" id="references" name="references">References</a></h1>
<p>About metaclasses:
<a class="reference" href="http://www-128.ibm.com/developerworks/linux/library/l-pymeta.html">http://www-128.ibm.com/developerworks/linux/library/l-pymeta.html</a> and
<a class="reference" href="http://www-128.ibm.com/developerworks/linux/library/l-pymeta2">http://www-128.ibm.com/developerworks/linux/library/l-pymeta2</a></p>
<p>About using decorators instead of metaclasses:</p>
<p>&lt;David's last paper&gt;</p>
<p>The code from which everything was born:</p>
<p><a class="reference" href="http://svn.zope.org/Zope3/trunk/src/zope/interface/advice.py">http://svn.zope.org/Zope3/trunk/src/zope/interface/advice.py</a></p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id14" id="questions-and-answers" name="questions-and-answers">Questions and answers</a></h1>
<dl class="docutils">
<dt>Q</dt>
<dd>Is there any specific licence for the code discussed in the paper?</dd>
<dt>A</dt>
<dd>No, you may assume the Public Domain or the Python licence, whatever
you are happier with. If you are using my code, or
code heavily derived from my own in your frameworks/applications I
would appreciated to be notified, just to gratify my ego.</dd>
<dt>Q</dt>
<dd>How do I extract snippets of code from the paper?</dd>
<dt>A</dt>
<dd><p class="first">Download <a class="reference" href="http://www.phyast.pitt.edu/~micheles/classinitializer.zip">http://www.phyast.pitt.edu/~micheles/classinitializer.zip</a>
which contains the source
version of the paper (as well as the HTML and PDF versions)
and a doctester utility. Run</p>
<p><tt class="docutils literal"><span class="pre">$</span> <span class="pre">python</span> <span class="pre">doctester.py</span> <span class="pre">classinitializer.txt</span></tt></p>
<p class="last">This will run many doctests and generate a script called <tt class="docutils literal"><span class="pre">_main.py</span></tt>
with the source code for <tt class="docutils literal"><span class="pre">classinitializer</span></tt> and <tt class="docutils literal"><span class="pre">def_properties</span></tt>.</p>
</dd>
<dt>Q</dt>
<dd>The doctester is a really cool idea! Can I use it for my own projects?</dd>
<dt>A</dt>
<dd>Yes. See also
<a class="reference" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/410052">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/410052</a></dd>
</dl>
</div>
</div>
</body>
</html>
