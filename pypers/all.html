<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.4: http://docutils.sourceforge.net/" />
<title>OBJECT ORIENTED PROGRAMMING IN PYTHON</title>
<meta name="author" content="Michele Simionato" />
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<h1 class="title">OBJECT ORIENTED PROGRAMMING IN PYTHON</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Version:</th>
<td>0.5</td></tr>
<tr><th class="docinfo-name">Author:</th>
<td>Michele Simionato</td></tr>
<tr class="field"><th class="docinfo-name">E-mail:</th><td class="field-body"><a class="reference" href="mailto:mis6&#64;pitt.edu">mis6&#64;pitt.edu</a></td>
</tr>
<tr class="field"><th class="docinfo-name">Home-page:</th><td class="field-body"><a class="reference" href="http://www.phyast.pitt.edu/~micheles/">http://www.phyast.pitt.edu/~micheles/</a></td>
</tr>
<tr class="field"><th class="docinfo-name">Disclaimer:</th><td class="field-body">I release this book to the general public. 
It can be freely distributed if unchanged.
As usual, I don't give any warranty: while I have tried hard to ensure the
correctness of what follows, I disclaim any responsability in case of
errors . Use it at your own risk and peril !</td>
</tr>
</tbody>
</table>
<div class="document" id="object-oriented-programming-in-python">
<div class="contents topic" id="contents">
<p class="topic-title first"><a name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#preface" id="id49" name="id49">Preface</a><ul>
<li><a class="reference" href="#the-philosophy-of-this-book" id="id50" name="id50">The philosophy of this book</a></li>
<li><a class="reference" href="#for-who-this-book-in-intended" id="id51" name="id51">For who this book in intended</a></li>
<li><a class="reference" href="#about-the-scripts-in-this-book" id="id52" name="id52">About the scripts in this book</a></li>
<li><a class="reference" href="#conventions-used-in-this-book" id="id53" name="id53">Conventions used in this book</a></li>
</ul>
</li>
<li><a class="reference" href="#introduction" id="id54" name="id54">Introduction</a><ul>
<li><a class="reference" href="#why-oop" id="id55" name="id55">Why OOP ?</a></li>
<li><a class="reference" href="#why-python" id="id56" name="id56">Why Python ?</a></li>
<li><a class="reference" href="#further-thoughts" id="id57" name="id57">Further thoughts</a></li>
</ul>
</li>
<li><a class="reference" href="#first-things-first" id="id58" name="id58">FIRST THINGS, FIRST</a><ul>
<li><a class="reference" href="#what-s-an-object" id="id59" name="id59">What's an object?</a></li>
<li><a class="reference" href="#objects-and-classes" id="id60" name="id60">Objects and classes</a></li>
<li><a class="reference" href="#objects-have-attributes" id="id61" name="id61">Objects have attributes</a></li>
<li><a class="reference" href="#objects-have-methods" id="id62" name="id62">Objects have methods</a></li>
<li><a class="reference" href="#summing-objects" id="id63" name="id63">Summing objects</a></li>
<li><a class="reference" href="#inspecting-objects" id="id64" name="id64">Inspecting objects</a></li>
<li><a class="reference" href="#built-in-objects-iterators-and-generators" id="id65" name="id65">Built-in objects: iterators and generators</a></li>
</ul>
</li>
<li><a class="reference" href="#the-convenience-of-functions" id="id66" name="id66">THE CONVENIENCE OF FUNCTIONS</a><ul>
<li><a class="reference" href="#id16" id="id67" name="id67">Introduction</a></li>
<li><a class="reference" href="#a-few-useful-functions" id="id68" name="id68">A few useful functions</a></li>
<li><a class="reference" href="#functions-are-objects" id="id69" name="id69">Functions are objects</a></li>
<li><a class="reference" href="#profiling-functions" id="id70" name="id70">Profiling functions</a></li>
<li><a class="reference" href="#about-python-speed" id="id71" name="id71">About Python speed</a></li>
<li><a class="reference" href="#tracing-functions" id="id72" name="id72">Tracing functions</a></li>
<li><a class="reference" href="#tracing-objects" id="id73" name="id73">Tracing objects</a></li>
<li><a class="reference" href="#inspecting-functions" id="id74" name="id74">Inspecting functions</a></li>
</ul>
</li>
<li><a class="reference" href="#the-beauty-of-objects" id="id75" name="id75">THE BEAUTY OF OBJECTS</a><ul>
<li><a class="reference" href="#user-defined-objects" id="id76" name="id76">User defined objects</a></li>
<li><a class="reference" href="#objects-have-static-methods-and-classmethods" id="id77" name="id77">Objects have static methods and classmethods</a></li>
<li><a class="reference" href="#objects-have-their-privacy" id="id78" name="id78">Objects have their privacy</a></li>
<li><a class="reference" href="#objects-have-properties" id="id79" name="id79">Objects have properties</a></li>
<li><a class="reference" href="#objects-have-special-methods" id="id80" name="id80">Objects have special methods</a></li>
<li><a class="reference" href="#objects-can-be-called-added-subtracted" id="id81" name="id81">Objects can be called, added, subtracted, ...</a></li>
</ul>
</li>
<li><a class="reference" href="#the-power-of-classes" id="id82" name="id82">THE POWER OF CLASSES</a><ul>
<li><a class="reference" href="#the-concept-of-inheritance" id="id83" name="id83">The concept of inheritance</a></li>
<li><a class="reference" href="#inheritance-versus-run-time-class-modifications" id="id84" name="id84">Inheritance versus run-time class modifications</a></li>
<li><a class="reference" href="#inheriting-from-built-in-types" id="id85" name="id85">Inheriting from built-in types</a></li>
<li><a class="reference" href="#controlling-the-creation-of-objects" id="id86" name="id86">Controlling the creation of objects</a></li>
<li><a class="reference" href="#multiple-inheritance" id="id87" name="id87">Multiple Inheritance</a></li>
<li><a class="reference" href="#cooperative-hierarchies" id="id88" name="id88">Cooperative hierarchies</a></li>
<li><a class="reference" href="#inheritance-and-privacy" id="id89" name="id89">Inheritance and privacy</a></li>
</ul>
</li>
<li><a class="reference" href="#the-sophistication-of-descriptors" id="id90" name="id90">THE SOPHISTICATION OF DESCRIPTORS</a><ul>
<li><a class="reference" href="#motivation" id="id91" name="id91">Motivation</a></li>
<li><a class="reference" href="#functions-versus-methods" id="id92" name="id92">Functions versus methods</a></li>
<li><a class="reference" href="#methods-versus-functions" id="id93" name="id93">Methods versus functions</a></li>
<li><a class="reference" href="#static-methods-and-class-methods" id="id94" name="id94">Static methods and class methods</a></li>
<li><a class="reference" href="#properties" id="id95" name="id95">Properties</a></li>
<li><a class="reference" href="#user-defined-attribute-descriptors" id="id96" name="id96">User-defined attribute descriptors</a></li>
<li><a class="reference" href="#data-descriptors" id="id97" name="id97">Data descriptors</a></li>
<li><a class="reference" href="#the-super-attribute-descriptor" id="id98" name="id98">The <tt class="literal"><span class="pre">super</span></tt> attribute descriptor</a></li>
<li><a class="reference" href="#method-wrappers" id="id99" name="id99">Method wrappers</a></li>
</ul>
</li>
<li><a class="reference" href="#the-subtleties-of-multiple-inheritance" id="id100" name="id100">THE SUBTLETIES OF MULTIPLE INHERITANCE</a><ul>
<li><a class="reference" href="#a-little-bit-of-history-why-python-2-3-has-changed-the-mro" id="id101" name="id101">A little bit of history: why Python 2.3 has changed the MRO</a></li>
<li><a class="reference" href="#the-c3-method-resolution-order" id="id102" name="id102">The C3 Method Resolution Order</a></li>
<li><a class="reference" href="#examples" id="id103" name="id103">Examples</a></li>
<li><a class="reference" href="#bad-method-resolution-orders" id="id104" name="id104">Bad Method Resolution Orders</a></li>
<li><a class="reference" href="#understanding-the-method-resolution-order" id="id105" name="id105">Understanding the Method Resolution Order</a></li>
<li><a class="reference" href="#counting-instances" id="id106" name="id106">Counting instances</a></li>
<li><a class="reference" href="#the-pizza-shop-example" id="id107" name="id107">The pizza-shop example</a></li>
<li><a class="reference" href="#fixing-wrong-hierarchies" id="id108" name="id108">Fixing wrong hierarchies</a></li>
<li><a class="reference" href="#modifying-hierarchies" id="id109" name="id109">Modifying hierarchies</a></li>
<li><a class="reference" href="#inspecting-python-code" id="id110" name="id110">Inspecting Python code</a></li>
</ul>
</li>
<li><a class="reference" href="#the-magic-of-metaclasses-part-i" id="id111" name="id111">THE MAGIC OF METACLASSES - PART I</a><ul>
<li><a class="reference" href="#metaclasses-as-class-factories" id="id112" name="id112">Metaclasses as class factories</a></li>
<li><a class="reference" href="#metaclasses-as-class-modifiers" id="id113" name="id113">Metaclasses as class modifiers</a></li>
<li><a class="reference" href="#a-few-caveats-about-the-usage-of-metaclasses" id="id114" name="id114">A few caveats about the usage of metaclasses</a></li>
<li><a class="reference" href="#metaclasses-and-inheritance" id="id115" name="id115">Metaclasses and inheritance</a></li>
<li><a class="reference" href="#conflicting-metaclasses" id="id116" name="id116">Conflicting metaclasses</a></li>
<li><a class="reference" href="#cooperative-metaclasses" id="id117" name="id117">Cooperative metaclasses</a></li>
<li><a class="reference" href="#metamethods-vs-class-methods" id="id118" name="id118">Metamethods vs class methods</a></li>
</ul>
</li>
<li><a class="reference" href="#the-magic-of-metaclasses-part-2" id="id119" name="id119">THE MAGIC OF METACLASSES - PART 2</a><ul>
<li><a class="reference" href="#the-secrets-of-the-metaclass-hook" id="id120" name="id120">The secrets of the <tt class="literal"><span class="pre">__metaclass__</span></tt> hook</a></li>
<li><a class="reference" href="#anonymous-inner-metaclasses" id="id121" name="id121">Anonymous inner metaclasses</a></li>
<li><a class="reference" href="#passing-parameters-to-meta-classes" id="id122" name="id122">Passing parameters to (meta) classes</a></li>
<li><a class="reference" href="#meta-functions" id="id123" name="id123">Meta-functions</a></li>
<li><a class="reference" href="#anonymous-cooperative-super-calls" id="id124" name="id124">Anonymous cooperative super calls</a></li>
<li><a class="reference" href="#more-on-metaclasses-as-class-factories" id="id125" name="id125">More on metaclasses as class factories</a></li>
<li><a class="reference" href="#programming-with-metaclasses" id="id126" name="id126">Programming with metaclasses</a></li>
<li><a class="reference" href="#metaclass-aided-operator-overloading" id="id127" name="id127">Metaclass-aided operator overloading</a></li>
</ul>
</li>
<li><a class="reference" href="#advanced-metaprogramming-techniques" id="id128" name="id128">ADVANCED METAPROGRAMMING TECHNIQUES</a><ul>
<li><a class="reference" href="#on-code-processing" id="id129" name="id129">On code processing</a></li>
<li><a class="reference" href="#regular-expressions" id="id130" name="id130">Regular expressions</a></li>
<li><a class="reference" href="#more-on-metaclasses-and-subclassing-built-in-types" id="id131" name="id131">More on metaclasses and subclassing built-in types</a></li>
<li><a class="reference" href="#a-simple-state-machine" id="id132" name="id132">A simple state machine</a></li>
<li><a class="reference" href="#creating-classes" id="id133" name="id133">Creating classes</a></li>
<li><a class="reference" href="#modifying-modules" id="id134" name="id134">Modifying modules</a></li>
<li><a class="reference" href="#metaclasses-and-attribute-descriptors" id="id135" name="id135">Metaclasses and attribute descriptors</a></li>
<li><a class="reference" href="#id46" id="id136" name="id136">Modifying hierarchies</a></li>
<li><a class="reference" href="#tracing-hierarchies" id="id137" name="id137">Tracing hierarchies</a></li>
<li><a class="reference" href="#modifying-source-code" id="id138" name="id138">Modifying source code</a></li>
<li><a class="reference" href="#metaclass-regenerated-hierarchies" id="id139" name="id139">Metaclass regenerated hierarchies</a></li>
</ul>
</li>
<li><a class="reference" href="#the-programmable-programming-language" id="id140" name="id140">THE PROGRAMMABLE PROGRAMMING LANGUAGE</a><ul>
<li><a class="reference" href="#enhancing-the-python-language" id="id141" name="id141">Enhancing the Python language</a></li>
<li><a class="reference" href="#restricting-python-dynamism" id="id142" name="id142">Restricting Python dynamism</a></li>
<li><a class="reference" href="#changing-the-language-without-changing-the-language" id="id143" name="id143">Changing the language without changing the language</a></li>
<li><a class="reference" href="#recognizing-magic-comments" id="id144" name="id144">Recognizing magic comments</a></li>
<li><a class="reference" href="#interpreting-python-source-code-on-the-fly" id="id145" name="id145">Interpreting Python source code on the fly</a></li>
<li><a class="reference" href="#implementing-lazy-evaluation" id="id146" name="id146">Implementing lazy evaluation</a></li>
<li><a class="reference" href="#implementing-a-ternary-operator" id="id147" name="id147">Implementing a ternary operator</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="preface">
<h1><a class="toc-backref" href="#id49" name="preface">Preface</a></h1>
<blockquote>
<pre class="line-block">
<em>There is only one way to learn: trough examples</em>
</pre>
</blockquote>
<div class="section" id="the-philosophy-of-this-book">
<h2><a class="toc-backref" href="#id50" name="the-philosophy-of-this-book">The philosophy of this book</a></h2>
<p>This book is written with the intent to help the programmer going trough
the fascinating concepts of Object Oriented Programming (OOP), in their
Python incarnation. Notice that I say to help, not to teach. Actually,
I do not think that a book can teach OOP or any other non-trivial matter 
in Computer Science or other disciplines. Only the
practice can teach: practice, then practice, and practice again. 
You must learn yourself from your experiments, not from the books. 
Nevertheless, books are useful. They cannot teach, but they can help. 
They should give you new ideas that you was not thinking about, they should
show tricks you do not find in the manual, and in general they should be of
some guidance in the uphill road to knowledge. That is the philosophy
of this book. For this reason</p>
<p>1. It is not comprehensive, not systematic; 
it is intended to give ideas and basis: from
that the reader is expected to cover the missing part on his own,
browsing the documentation, other sources and other books, and finally
the definite autority, the source itself.</p>
<p>2. It will not even try to teach the <em>best</em> practices. I will show what you can
do with Python, not what you &quot;should&quot; do. Often I will show solutions that are
not recommended. I am not a mammy saying this is
good, this is bad, do this do that.</p>
<p>3. You can only learn from your failures. If you think &quot;it should work, if I do
X and Y&quot; and it works, then you have learned nothing new. 
You have merely verified
that your previous knowledge was correct, but you haven't create a new
knowledge. On the other hand, when you think &quot;it should work, if I do
X and Y&quot; and it doesn't, then you have learned that your previous knowlegde
was wrong or incomplete, and you are forced to learn something new to
overcome the difficulty. For this reason, I think it is useful to report
not only how to do something, but also to report how not to do something, 
showing the pitfalls of wrong approaches.</p>
<p>That's in my opinion is the goal of a good book. I don't know if have
reached this goal or not (the decision is up to the reader), but at least
I have tried to follow these guidelines.</p>
<p>Moreover, this is not a book on OOP, 
it is a book on OOP <em>in Python</em>.</p>
<p>In other words, the point of view of this book is not 
to emphasize general topics of OOP that are exportable to other languages, 
but exactly the opposite: I want to emphasize specific techniques that one
can only use in Python, or that are difficult to translate to other 
languages. Moreover, I will not provide comparisons with other 
languages (except for the section &quot;Why Python?&quot; in this introduction and
in few selected other places), 
in order to keep the discussion focused.</p>
<p>This choice comes from the initial motivation for this book, which was 
to fulfill a gap in the (otherwise excellent) Python documentation. 
The problem is that the available documentation still lacks an accessible 
reference of the new Python 2.2+ object-oriented features.
Since myself I have learned Python and OOP from scratch, 
I have decided to write this book in order to fill that gap and
help others.</p>
<p>The emphasis in this book is not in giving 
solutions to specific problems (even if most of the recipes of this book
can easily be tailored to solve real life concrete problems), it is in 
teaching  how does it work, why it does work in some cases and why does 
not work in some other cases. Avoiding too specific problems has an
additional bonus, since it allows me to use <em>short</em> examples (the majority 
of the scripts presented here is under 20-30 lines) which I think are 
best suited to teach a new matter <a class="footnote-reference" href="#id2" id="id1" name="id1">[1]</a> . Notice, however, that whereas
the majority of the scripts in this book are short, it is also true
that they are pretty <em>dense</em>. The density is due to various reasons:</p>
<ol class="arabic simple">
<li>I am defining a lot of helper functions and classes, that are
reused and enhanced during all the book.</li>
<li>I am doing a strong use of inheritance, therefore a script at the
end of the book can inherits from the classes defined through all
the book;</li>
<li>A ten line script involving metaclasses can easily perform the equivalent 
of generating hundreds of lines of code in a language without metaclasses 
such as Java or C++.</li>
</ol>
<p>To my knowledge, there are no other books covering the same topics with
the same focus (be warned, however, that I haven't read so many Python 
books ;-). The two references that come closest to the present book are
the <tt class="literal"><span class="pre">Python</span> <span class="pre">Cookbook</span></tt> by Alex Martelli and David Ascher, and
Alex Martelli's <tt class="literal"><span class="pre">Python</span> <span class="pre">in</span> <span class="pre">a</span> <span class="pre">Nutshell</span></tt>. They are quite recent books and 
therefore it covers (in much less detail) some of the 2.2 features that are 
the central topics to this book. 
However, the Cookbook reserves to OOP only one chapter and has a quite 
different philosophy from the present book, therefore there is 
practically no overlapping. Also <tt class="literal"><span class="pre">Python</span> <span class="pre">in</span> <span class="pre">a</span> <span class="pre">Nutshell</span></tt> covers 
metaclasses in few pages, whereas half of this book is essentially
dedied to them. This means that you can read both ;-)</p>
<table class="footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[1]</a></td><td>Readers that prefer the  opposite philosophy of using longer, 
real life-like, examples, have already the excellent &quot;Dive into 
Python&quot; book <a class="reference" href="http://diveintopython.org/">http://diveintopython.org/</a> at their disposal. This is 
a very good book that I certainly recommend to any (experienced) 
Python programmer; it is also freely available (just like this ;-).
However, the choice of arguments is quite different and there is 
essentially no overlap between my book and &quot;Dive into Python&quot; 
(therefore you can read both ;-).</td></tr>
</tbody>
</table>
</div>
<div class="section" id="for-who-this-book-in-intended">
<h2><a class="toc-backref" href="#id51" name="for-who-this-book-in-intended">For who this book in intended</a></h2>
<p>I have tried to make this tutorial useful to a large public of Pythonistas, 
i.e. both people with no previous experience of Object Oriented Programming
and people with experience on OOP, but unfamiliar with the most
recent Python 2.2-2.3 features (such as attribute descriptors,
metaclasses, change of the MRO in multiple inheritance, etc). 
However, this is not a book for beginners: the non-experienced reader should 
check (at least) the Internet sites www.python.org/newbies.com and 
www.awaretek.com, that provide a nice collection of resources for Python 
newbies.</p>
<p>These are my recommendations for the reader, according to her/his level:</p>
<ol class="arabic simple">
<li>If you are an absolute beginner, with no experience on programming,
this book is <em>not</em> for you (yet ;-). Go to 
<a class="reference" href="http://www.python.org/doc/Newbies.html">http://www.python.org/doc/Newbies.html</a> and read one of the introductive 
texts listed there, then come back here. I recommend &quot;How to Think Like 
a Computer Scientist&quot;, available for free on the net (see 
<a class="reference" href="http://www.ibiblio.org/obp/thinkCSpy/">http://www.ibiblio.org/obp/thinkCSpy/</a>); I found it useful myself when 
I started learning Python; be warned, however, that it refers to the rather 
old Python version 1.5.2. There are also excellent books 
on the market (see <a class="reference" href="http://www.awaretek.com/plf.html">http://www.awaretek.com/plf.html</a>). 
<a class="reference" href="http://www.uselesspython.com/">http://www.uselesspython.com/</a> is a good resource to find recensions 
about available Python books. For free books, look at
<a class="reference" href="http://www.tcfb.com/freetechbooks/bookphyton.html">http://www.tcfb.com/freetechbooks/bookphyton.html</a> .
This is <em>not</em> another Python tutorial.</li>
<li>If you know already (at least) another programming language, but you don't
know Python, then this book is <em>not</em> for you (again ;-). Read the FAQ, the
Python Tutorial and play a little with the Standard Library (all this
material can be downloaded for free from  <a class="reference" href="http://www.python.org">http://www.python.org</a>), then
come back here.</li>
<li>If you have passed steps 1 and 2, and you are confortable with Python
at the level of simple procedural programming, but have no clue about
objects and classes, <em>then</em> this book is for you. Read this book till
the end and your knowledge of OOP will pass from zero to a quite advanced 
level (hopefully). Of course, you will have to play with the code in 
this book and write a lot of code on your own, first ;-)</li>
<li>If you are confortable with Python and you also known OOP from other
languages or from earlier version of Python, then this book is for
you, too: you are ready to read the more advanced chapters.</li>
<li>If you are a Python guru, then you should read the book, too. I expect
you will find the errors and send me feedback, helping me to improve
this tutorial.</li>
</ol>
</div>
<div class="section" id="about-the-scripts-in-this-book">
<h2><a class="toc-backref" href="#id52" name="about-the-scripts-in-this-book">About the scripts in this book</a></h2>
<p>All the scripts  in this book are free. You are expected to play
with them, to modify them and to improve them.</p>
<p>In order to facilitate the extraction of the scripts from the main text, both
visually for the reader and automatically for Python, I use the
convention of sandwiching the body of the example scripts in blocks like this</p>
<blockquote>
<pre class="literal-block">
#&lt;myfirstscript.py&gt;

print &quot;Here Starts the Python Way to Object Oriented Programming !&quot;

#&lt;/myfirstscript.py&gt;
</pre>
</blockquote>
<p>You may extract the source of this script with the a Python program
called &quot;test.py&quot; and provided in the distribution. Simply give the 
following command:</p>
<blockquote>
<pre class="literal-block">
$ python test.py myfirstscript.py
</pre>
</blockquote>
<p>This will create a file called &quot;myfirstscript.py&quot;, containing the
source of <tt class="literal"><span class="pre">myfirstscript.py</span></tt>; moreover it will execute the script 
and write its output in a file called &quot;output.txt&quot;. I have tested
all the scripts in this tutorial under Red Hat Linux 7.x and 
Windows 98SE. You should not have any problem in running them,
but if a problem is there, &quot;test.py&quot; will probably discover it,
even if, unfortunately, it will not provide the solution :-(.
Notice that test.py requires Python 2.3+ to work, since most of
the examples in this book heavily depends on the new features
introduced in Python 2.2-2.3. Since the installation of Python 
2.3 is simple, quick and free, I think I am requiring to my readers
who haven't upgraded yet a very little effort. This is well worth
the pain since Python 2.3 fixes few bugs of 2.2 (notably in the subject of
attribute descriptors and the <tt class="literal"><span class="pre">super</span></tt> built-in) that makes</p>
<p>You may give more arguments to test.py, as in this example:</p>
<blockquote>
<pre class="literal-block">
$ python test.py myfirstscript.py mysecondscript.py
</pre>
</blockquote>
<p>The output of both scripts will still be placed in the file &quot;output.txt&quot;.
Notice that if you give an argument which is not the name of a script in the
book, it will be simply ignored. Morever, if you will not give any argument,
&quot;test.py&quot; will automatically executes all the tutorial scripts, writing their 
output in &quot;output.txt&quot; <a class="footnote-reference" href="#id4" id="id3" name="id3">[2]</a> . You may want to give a look at this file, once 
you have finished the tutorial. It also contains the source code of 
the scripts, for better readability.</p>
<p>Many examples of this tutorial depend on utility functions defined
in a external module called <tt class="literal"><span class="pre">oopp</span></tt> (<tt class="literal"><span class="pre">oopp</span></tt> is an obvious abbreviation 
for the title of the tutorial). The module <tt class="literal"><span class="pre">oopp</span></tt> is automatically generated 
by &quot;test.py&quot;, which works by extracting from the tutorial 
text blocks of code of the form <tt class="literal"><span class="pre">#&lt;oopp.py&gt;</span> <span class="pre">something</span> <span class="pre">#&lt;/oopp.py&gt;</span></tt> 
and saving them in a file called &quot;oopp.py&quot;. 
Let me give an example. A very recent enhancement to Python (in 
Python 2.3) has been the addition of a built-in boolean type with
values True and False:</p>
<blockquote>
<pre class="literal-block">
$ python
Python 2.3a1 (#1, Jan  6 2003, 10:31:14)
[GCC 2.96 20000731 (Red Hat Linux 7.2 2.96-108.7.2)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; 1+1==2
True
&gt;&gt;&gt; 1+1==3
False
&gt;&gt;&gt; type(True)
&lt;type 'bool'&gt;
&gt;&gt;&gt; type(False)
&lt;type 'bool'&gt;
</pre>
</blockquote>
<p>However, previous version of Python use the integers 1 and 0 for 
True and False respectively.</p>
<blockquote>
<pre class="literal-block">
$ python
Python 2.2 (#1, Apr 12 2002, 15:29:57)
[GCC 2.96 20000731 (Red Hat Linux 7.2 2.96-109)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; 1+1==2
1
&gt;&gt;&gt; 1+1==3 
0
</pre>
</blockquote>
<p>Following the 2.3 convension, in this tutorial I will use the names 
<tt class="literal"><span class="pre">True</span></tt> and <tt class="literal"><span class="pre">False</span></tt> to denotes the numbers 1 and 0 respectively. 
This is automatic in Python 2.2.1+, but not in Python 2.2. Therefore, 
for sake of compatibility, it is convenient to set the values <tt class="literal"><span class="pre">True</span></tt> 
and <tt class="literal"><span class="pre">False</span></tt> in our utility module:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

import __builtin__
try: 
    __builtin__.True   #look if True is already defined
except AttributeError: # if not add True and False to the builtins
    __builtin__.True = 1
    __builtin__.False = 0

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here there is an example of usage:</p>
<blockquote>
<pre class="literal-block">
#&lt;mysecondscript.py&gt;

import oopp
print &quot;True =&quot;,True,
print &quot;False =&quot;,False

#&lt;/mysecondscript.py&gt;
</pre>
</blockquote>
<p>The output is &quot;True = 1 False = 0&quot; under Python 2.2 and 
&quot;True = True False = False&quot; under Python 2.3+.</p>
<table class="footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id4">[2]</a></td><td>&quot;test.py&quot;, invoked without arguments, does not create '.py' files, 
since I don't want to kludge the distribution with dozens of ten-line
scripts. I expect you may want to save only few scripts as standalone
programs, and cut and paste the others.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="conventions-used-in-this-book">
<h2><a class="toc-backref" href="#id53" name="conventions-used-in-this-book">Conventions used in this book</a></h2>
<p>Python expressions are denoted with monospaced fonts when in the text.
Sections marked with an asterisk can be skipped in a first reading.
Typically they have the purpose of clarifying some subtle point and
are not needed for the rest of the book. These sections are intended
for the advanced reader, but could confuse the beginner.
An example is the section about the difference between methods and
functions, or the difference between the inheritance constraint and
the metaclass constraint.</p>
</div>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id54" name="introduction">Introduction</a></h1>
<blockquote>
<pre class="line-block">
<em>A language that doesn't affect the way you think about programming,
is not worth knowing.</em> -- Alan Perlis
</pre>
</blockquote>
<div class="section" id="why-oop">
<h2><a class="toc-backref" href="#id55" name="why-oop">Why OOP ?</a></h2>
<p>I guess some of my readers, like me, have started programming in the mid-80's,
when traditional (i.e. non object-oriented) Basic and Pascal where popular as 
first languages. At the time OOP was not as pervasive in software development 
how it is now, most of the mainstream languages were non-object-oriented and 
C++ was just being released. That was a time when the transition from 
spaghetti-code to structured code was already well accomplished, but 
the transition from structured programming to (the first phase of) 
OOP was at the beginning.</p>
<p>Nowaydays, we live in a similar time of transition . Today, the transition 
to (the first phase of) OOP is well accomplished and essentially all 
mainstream
languages support some elementary form of OOP. To be clear, when I say
mainstream langauges, I have in mind Java and C++: C is a remarkable 
exception to the  rule, since it is mainstream but not object-oriented.</p>
<p>However, both Java an C++ (I mean standard Java and C++, not special
extension like DTS C++, that have quite powerful object oriented features)
are quite poor object-oriented languages: they provides only the most 
elementary aspects of OOP, the features of the <em>first phase</em> of OOP.</p>
<p>Hence, today the transition to the <em>second phase</em> of OOP is only at the 
beginning, i.e mainstream language are not yet really OO, but they will
become OOP in the near future.</p>
<p>By second phase of OOP I mean the phase in which the primary
objects of concern for the programmer are no more the objects, but the
metaobjects. In elementary OOP one works on objects, which have attributes
and methods (the evolution of old-fashioned data and functions)  defined
by their classes; in the second phase of OOP one works on classes 
which behavior is described by metaclasses. We no more modify objects 
trough classes: nowadays we modify classes and class hierarchies 
through metaclasses and multiple inheritance.</p>
<p>It would be tempting to represent the history of programming in the last
quarter of century with an evolutionary table like that:</p>
<table border class="table">
<colgroup>
<col width="33%" />
<col width="27%" />
<col width="30%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th>~1975</th>
<th>~1985</th>
<th>~1995</th>
<th>~2005</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>procedural programming</td>
<td>OOP1</td>
<td>OOP2</td>
<td>?</td>
</tr>
<tr><td>data,functions</td>
<td>objects,classes</td>
<td>classes,metaclasses</td>
<td>?</td>
</tr>
</tbody>
</table>
<p>The problem is that table would be simply wrong, since in truth
Smalltalk had metaclasses already 25 years ago! And also Lisp
had <em>in nuce</em> everything a long <em>long</em> time ago.
The truth is that certains languages where too much ahead of their 
time ;-)</p>
<p>Therefore, today we already have all the ideas 
and the conceptual tools to go beyond the first phase of OOP 
(they where invented 20-30 years ago), nevertheless those ideas are  
not yet universally known, nor implemented in mainstream languages.</p>
<p>Fortunately, there are good languages
where you can access the bonus of the second phase of OOP (Smalltalk, CLOS,
Dylan, ...): unfortunately
most of them are academic and/or little known in the real world
(often for purely commercial reasons, since typically languages are not
chosen accordingly to their merits, helas!). Python is an exception to this
rule, in the sense that it is an eminently practical language (it started
as a scripting language to do Operating System administrative jobs), 
which is relatively known and used in that application niche (even if some
people <em>wrongly</em> think that should not be used for 'serious' things).</p>
<p>There are various reasons why most mainstream languages are rather
poor languages, i.e. underfeatured languages (as Java) or powerful, but too
tricky to use, as C++. Some are good reasons (for instance <em>efficiency</em>: if
efficiency is the first concern, then poor languages can be much
better suited to the goal: for instance Fortran for number crunching
and C for system programming), some are less good (economical 
monopoly). There is nothing to do against these reasons: if you
need efficiency, or if you are forced to use a proprietary language
because it is the language used by your employer. However, if you
are free from these restrictions, there is another reason why you
could not choose to use a poweful language. The reason is that, 
till now, programmers working in the industrial world mostly had simple 
problems (I mean conceptually simple problems). In order to solve
simple problems one does not need a powerful language, and the effort
spent in learning it is not worth.</p>
<p>However, nowadays the situations has changed. Now, with Internet and graphics
programming everywhere, and object-oriented languages so widespread,
now it is the time when actually people <em>needs</em> metaprogramming, the
ability to changing classes and programs. Now everybody is programming
in the large.</p>
<p>In this situation, it is justified to spend some time to learn better
way of programming. And of course, it is convenient to start from
the language with the flattest learning curve of all.</p>
</div>
<div class="section" id="why-python">
<h2><a class="toc-backref" href="#id56" name="why-python">Why Python ?</a></h2>
<blockquote>
<pre class="line-block">
<em>In many ways, it's a dull language, borrowing solid old concepts from 
many other languages &amp; styles:  boring syntax, unsurprising semantics,
few automatic coercions, etc etc.  But that's one of the things I like
about it.</em>  --Tim Peters on Python, 16 Sep 93
</pre>
</blockquote>
<p>If you are reading this book, I assume you already  have some experience
with Python. If this is the case, you already know the obvious advantages
of Python such as readability, easy of use and short development time.
Nevertheless, you could only have used Python as a fast and simple
scripting language. If you are in this situation, then your risk to
have an incorrect opinion on the language like &quot;it is a nice little
language, but too simple to be useful in 'real' applications&quot;. The
truth is that Python is designed to be <em>simple</em>, and actually it
is; but by no means it is a &quot;shallow&quot; language. Actually, it goes
quite <em>deep</em>, but it takes some time to appreciate this fact.</p>
<p>Let me contrast Python with Lisp, for instance. From the beginning,
Lisp was intended to be a language for experts, for people with difficult 
problems to solve. The first
users of Lisp were academicians, professors of CS and scientists.
On the contrary, from the beginning Python 
was intended to be language for everybody (Python predecessor was ABC, 
a language invented to teach CS to children). Python makes great a first 
language for everybody, whereas Lisp would require especially
clever and motivated students (and we all know that there is lack
of them ;-)</p>
<p>From this difference of origins, Python inherits an easy to learn syntax,
whereas Lisp syntax is horrible for the beginner (even if not as
horrible as C++ syntax ;-)</p>
<blockquote>
<pre class="line-block">
<em>Macros are a powerful extension to weak languages.
Powerful languages don't need macros by definition.</em> 
-- Christian Tismer on c.l.p. (referring to C)
</pre>
</blockquote>
<p>Despite the differences, Python borrows quite a lot from Lisp and it
is nearly as expressive as it (I say nearly since Python is 
not as powerful as Lisp: by tradition, Lisp has always been on the top of 
hierarchy of programming language with respect to power of abstraction).
It is true that Python lacks some powerful Lisp features: for instance 
Python object model lacks multiple dispatching (for the time being ;-) 
and the language lacks Lisp macros (but this unlikely to change in the 
near future since Pythonistas see the lack of macro as a Good Thing <a class="footnote-reference" href="#id6" id="id5" name="id5">[3]</a>): 
nevertheless, the point is that Python is much <em>much</em> easier to learn. 
You have (nearly) all the power, but without the complexity.</p>
<p>One of the reasons, is that Python
try to be as <em>less</em> innovative as
possible: it takes the proven good things from others, more innovative
languages, and avoids their pitfalls. If you are an experienced
programmer , it will be even  easier to you to learn Python, since
there is more or less nothing which is really original to Python.
For instance:</p>
<ol class="arabic simple">
<li>the object model is took from languages that are good at it, such
as Smalltalk;</li>
<li>multiple inheritance has been modeled from languages good in it. such
as CLOS and Dylan;</li>
<li>regular expression follows the road opened by Perl;</li>
<li>functional features are borrowed from functional languages;</li>
<li>the idea of documentation strings come from Lisp;</li>
<li>list comprehension come from Haskell;</li>
<li>iterators and generators come from Icon;</li>
<li>etc. etc. (many other points here)</li>
</ol>
<p>I thinks the really distinctive feature of Python with respect to
any other serious language I know, is that Python is <em>easy</em>. You have the 
power (I mean power in conceptual sense, not computational power: in
the sense of computational power the best languages are
non-object-oriented ones) 
of the most powerful languages with a very little investement.
In addition to that, Python has a relatively large user base 
(as compared to Smalltalk or Ruby, or the various fragmented Lisp
communities). Of course, 
there is quite a difference between the user base of Python with
respect to the user base of, let say, VisualBasic or Perl. But 
I would never take in consideration VisualBasic for anything serious, 
whereas Perl is too ugly for my taste ;-).  
Finally, Python is <em>practical</em>. With this I mean the fact that 
Python has libraries that
allow the user to do nearly everything, since you can access all the C/C++ 
libraries with little or no effort, and all the Java libraries, though the
Python implementation known as Jython. In particular, one has the choice
between many excellent GUI's trough PyQt, wxPython, Tkinter, etc.</p>
<p>Python started as an Object Oriented Programming
Languages from the beginning, nevertheless is was never intended to be
a <em>pure</em> OOPL as SmallTalk or, more recently, Ruby. Python is a 
<em>multiparadigm</em>
language such a Lisp, that you choose your programming style according
to your problem: spaghetti-code, structured programming, functional
programming, object-oriented programming are all supported. You can
even write bad code in Python, even if it is less simple than in other
languages ;-). Python is a language which has quite evolved in its twelve
years of life (the first public release was released in February 1991)
and many new features have been integrated in the language with time. 
In particular, Python 2.2 (released in 2002) was a major breakthrough 
in the history of the language
for what concerns support to Object Oriented Programming (OOP). 
Before the 2.2 revolution, Python Object
Orientation was good; now it is <em>excellent</em>. All the fundamental features
of OOP, including pretty sophisticated ones, as metaclasses and multiple
inheritance, have now a very good support (the only missing thing is
multiple dispatching).</p>
<table class="footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="id6">[3]</a></td><td>Python lacks macros for an intentional design choice: many people
in the community (including Guido itself) feel that macros are 
&quot;too powerful&quot;. If you give the user the freedom to create her
own language, you must face at least three problems: i) the risk
to split the original language in dozens of different dialects;
ii) in collaborative projects, the individual programmer must 
spend an huge amount of time and effort would be spent in learning
macro systems written by others; iii) not all users are good
language designers: the programmer will have to fight with badly
designed macro systems. Due to these problems, it seems unlikely
that macros will be added to Python in the future.</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8" name="id7">[4]</a></td><td>For a good comparison between Python and Lisp I remind the reader to
the excellent Peter Norvig's article in
<a class="reference" href="http://www.norvig.com/python-lisp.html">http://www.norvig.com/python-lisp.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="further-thoughts">
<h2><a class="toc-backref" href="#id57" name="further-thoughts">Further thoughts</a></h2>
<p>Actually, the principal reasons why I begun studying 
Python was the documentation and the newsgroup: Python has an outstanding 
freely available documentation and an incredibly helpful newsgroup that
make extremely easy to learn the language. If I had found a comparable 
free documentation/newsgroup for C++ or Lisp, I would have studied that
languages instead.</p>
<p>Unfortunately, the enormous development at the software level, had no
correspondence with with an appropriate development of documentation.
As a consequence, the many beatiful, powerful and extremely <em>useful</em>
new features of Python 2.2+ object orientation are mostly remained
confined to developers and power users: the average Python programmer
has remained a little a part from the rapid development and she
<em>wrongly</em> thinks she has no use for the new features. There have
also been <em>protestations</em> of the users against developers of the
kind &quot;please, stop adding thousands of complicated new extensions
to the language for which we have no use&quot; !</p>
<p>Extending a language is always a delicate thing to do, for a whole
bunch of reasons:</p>
<ol class="arabic simple">
<li>once one extension is done, it is there <em>forever</em>.</li>
</ol>
<p>My experience has been the following.</p>
<p>When I first read about metaclasses, in Guido's essay
&quot;Unifying types and classes in Python 2.2&quot;, I thought &quot;Wow,
classes of classes, cool concept, but how useful is it?  
Are metaclasses really providing some new functionality?  
What can I do with metaclasses that I cannot do without?&quot;</p>
<p>Clearly, in these terms, the question is rather retorical, since in principle
any Turing-complete programming languages contains all the features provided 
by metaclasses. Python metaclasses themselves are implemented in C, that has 
no metaclasses. Therefore, my real question was not &quot;What can I do 
with metaclasses that I cannot do without?&quot; but &quot;How big is the convenience 
provided by metaclasses, with respect to my typical applications?&quot;.</p>
<p>The answer depends on the kind of problem you are considering. For certain
classes of problems it can be <em>very</em> large, as I will show in this and in
the next chapters.</p>
<p>I think the biggest advantage of metaclasses is <em>elegance</em>. Altough it
is true that most of what you can do with metaclasses, can be done without 
metaclasses, not using metaclasses can result in a much <em>uglier</em> solution.</p>
<p>One needs difficult problems in order to appreciate the advantage
of powerful methods.</p>
<p>If all you need is to write few scripts for copying two or three files,
there is no point in learning OOP.On the other hand, if you only
write simple programs where you define only one of two classes, there
is no point in using metaclasses. Metaclasses becomes relevant only
when you have many classes, whole classes of classes with similar
features that you want to modify.</p>
<p>In this sense, metaprogramming is for experts only, i.e. with people
with difficult problems. The point however, is that nowaydays,
many persons have difficult problems.</p>
<p>Finally, let me conclude this preface by recalling the
gist of Python wisdom.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters
.
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</pre>
</blockquote>
</div>
</div>
<div class="section" id="first-things-first">
<h1><a class="toc-backref" href="#id58" name="first-things-first">FIRST THINGS, FIRST</a></h1>
<p>This is an introductory chapter, with the main purpose of fixing the 
terminology used in the sequel. In particular, I give the definitions 
of objects, classes, attributes and methods. I discuss a few examples 
and I show some of the most elementary Python introspection features.</p>
<div class="section" id="what-s-an-object">
<h2><a class="toc-backref" href="#id59" name="what-s-an-object">What's an object?</a></h2>
<blockquote>
<pre class="line-block">
<em>So Everything Is An object.  
I'm sure the Smalltalkers are very happy :)</em>

-- Michael Hudson on comp.lang.python
</pre>
</blockquote>
<p>&quot;What's an object&quot; is the obvious question raised by anybody starting 
to learn Object Oriented Programming. The answer is simple: in Python, 
everything in an object!</p>
<p>An operative definition is the following: an <em>object</em>
is everything that can be labelled with an <em>object reference</em>.</p>
<p>In practical terms, the object reference is implemented as 
the object memory address, that is an integer number which uniquely
specify the object. There is a simple way to retrieve the object reference:
to use the builtin <tt class="literal"><span class="pre">id</span></tt> function. Informations on <tt class="literal"><span class="pre">id</span></tt> can be retrieved 
via the <tt class="literal"><span class="pre">help</span></tt> function <a class="footnote-reference" href="#id7" id="id8" name="id8">[4]</a>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; help(id)
Help on built-in function id:
id(...)
id(object) -&gt; integer
Return the identity of an object. This is guaranteed to be unique among
simultaneously existing objects. (Hint: it's the object's memory address.)
</pre>
</blockquote>
<p>The reader is strongly encouraged to try the help function on everything
(including help(help) ;-). This is the best way to learn how Python works,
even <em>better</em> than reading the standard documentation, since the on-line
help is often more update.</p>
<p>Suppose for instance we wonder if the number <tt class="literal"><span class="pre">1</span></tt> is an object: 
it is easy enough to ask Python for the answer:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id(1)
135383880
</pre>
</blockquote>
<p>Therefore the number 1 is a Python object and it is stored at the memory 
address 135383880, at least in my computer and during the current session.
Notice that the object reference is a dynamic thing; nevertheless it
is guaranteed to be unique and constant for a given object during its 
lifetime (two objects whose lifetimes are disjunct may have the same id() 
value, though).</p>
<p>Here there are other examples of built-in objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id(1L) # long
1074483312
&gt;&gt;&gt; id(1.0) #float
135682468
&gt;&gt;&gt; id(1j) # complex
135623440
&gt;&gt;&gt; id('1') #string
1074398272
&gt;&gt;&gt; id([1]) #list
1074376588
&gt;&gt;&gt; id((1,)) #tuple
1074348844
&gt;&gt;&gt; id({1:1}) # dict
1074338100
</pre>
</blockquote>
<p>Even functions are objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def f(x): return x #user-defined function
&gt;&gt;&gt; id(f)
1074292020
&gt;&gt;&gt; g=lambda x: x #another way to define functions
&gt;&gt;&gt; id(g)
1074292468
&gt;&gt;&gt; id(id) #id itself is a built-in function
1074278668
</pre>
</blockquote>
<p>Modules are objects, too:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import math 
&gt;&gt;&gt; id(math) #module of the standard library
1074239068
&gt;&gt;&gt; id(math.sqrt) #function of the standard library
1074469420
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">help</span></tt> itself is an object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id(help)
1074373452
</pre>
</blockquote>
<p>Finally, we may notice that the reserved keywords are not objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id(print) #error
File &quot;&lt;string&gt;&quot;, line 1
  id(print)       ^
SyntaxError: invalid syntax
</pre>
</blockquote>
<p>The operative definition is convenient since it gives a practical way
to check if something is an object and, more importantly, if two
objects are the same or not:</p>
<blockquote>
<!-- doctest -->
<pre class="doctest-block">
&gt;&gt;&gt; s1='spam'
&gt;&gt;&gt; s2='spam'
&gt;&gt;&gt; s1==s2
True
&gt;&gt;&gt; id(s1)==id(s2)
True
</pre>
</blockquote>
<p>A more elegant way of spelling <tt class="literal"><span class="pre">id(obj1)==id(obj2)</span></tt> is to use the
keyword <tt class="literal"><span class="pre">is</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; s1 is s2
True
</pre>
</blockquote>
<p>However, I should warn the reader that sometimes <tt class="literal"><span class="pre">is</span></tt> can be surprising:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id([]) == id([])
True
&gt;&gt;&gt; [] is []
False
</pre>
</blockquote>
<p>This is happening because writing <tt class="literal"><span class="pre">id([])</span></tt> dynamically creates an unique
object (a list) which goes away when you're finished with it.  So when an
expression needs both at the same time (<tt class="literal"><span class="pre">[]</span> <span class="pre">is</span> <span class="pre">[]</span></tt>), two unique objects
are created, but when an expression doesn't need both at the same time
(<tt class="literal"><span class="pre">id([])</span> <span class="pre">==</span> <span class="pre">id([])</span></tt>), an object gets created with an ID, is destroyed,
and then a second object is created with the same ID (since the last one
just got reclaimed) and their IDs compare equal. In other words, &quot;the 
ID is guaranteed to be unique <em>only</em> among simultaneously existing objects&quot;.</p>
<p>Another surprise is the following:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a=1
&gt;&gt;&gt; b=1
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a=556
&gt;&gt;&gt; b=556
&gt;&gt;&gt; a is b
False
</pre>
</blockquote>
<p>The reason is that integers between 0 and 99 are pre-instantiated by the
interpreter, whereas larger integers are recreated each time.</p>
<p>Notice the difference between '==' and 'is':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 1L==1
True
</pre>
</blockquote>
<p>but</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 1L is 1
False 
</pre>
</blockquote>
<p>since they are different objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id(1L) # long 1 
135625536
&gt;&gt;&gt; id(1)  # int 1
135286080
</pre>
</blockquote>
<p>The disadvantage of the operative definition is that it gives little 
understanding of what an object can be used for. To this aim, I must
introduce the concept of <em>class</em>.</p>
<table class="footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10" name="id9">[5]</a></td><td>Actually <tt class="literal"><span class="pre">help</span></tt> is not a function but a callable object. The
difference will be discussed in a following chapter.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="objects-and-classes">
<h2><a class="toc-backref" href="#id60" name="objects-and-classes">Objects and classes</a></h2>
<p>It is convenient to think of an object as an element of a set.</p>
<p>It you think a bit, this is the most general definition that actually 
grasps what we mean by object in the common language.
For instance, consider this book, &quot;Object Oriented Programming in Python&quot;:
this book is an object, in the sense that it is a specific representative 
of the <em>class</em> of all possible books.
According to this definition, objects are strictly related to classes, and
actually we say that objects are <em>instances</em> of classes.</p>
<p>Classes are nested: for
instance this book belongs to the class of books about programming
language, which is a subset of the class of all possible books;
moreover we may further specify this book as a Python book; moreover
we may specify this book as a Python 2.2+ book. There is no limit
to the restrictions we may impose to our classes.
On the other hand. it is convenient to have a &quot;mother&quot; class,
such that any object belongs to it. All strongly Object Oriented
Language have such a class <a class="footnote-reference" href="#id9" id="id10" name="id10">[5]</a>; in Python it is called <em>object</em>.</p>
<p>The relation between objects and classes in Python can be investigated
trough the built-in function <tt class="literal"><span class="pre">type</span></tt> <a class="footnote-reference" href="#id12" id="id11" name="id11">[6]</a> that gives the class of any 
Python object.</p>
<p>Let me give some example:</p>
<ol class="arabic simple">
<li>Integers numbers are instances of the class <tt class="literal"><span class="pre">int</span></tt> or <tt class="literal"><span class="pre">long</span></tt>:</li>
</ol>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(1)
&lt;type 'int'&gt;
&gt;&gt;&gt; type(1L)
&lt;type 'long'&gt;
</pre>
</blockquote>
<ol class="arabic simple" start="2">
<li>Floating point numbers are instances of the class <tt class="literal"><span class="pre">float</span></tt>:</li>
</ol>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(1.0)
&lt;type 'float'&gt;
</pre>
</blockquote>
<ol class="arabic simple" start="3">
<li>Complex numbers are instances of the class <tt class="literal"><span class="pre">complex</span></tt>:</li>
</ol>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(1.0+1.0j)
&lt;type 'complex'&gt;
</pre>
</blockquote>
<ol class="arabic simple" start="4">
<li>Strings are instances of the class <tt class="literal"><span class="pre">str</span></tt>:</li>
</ol>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type('1')
&lt;type 'str'&gt;
</pre>
</blockquote>
<ol class="arabic simple" start="5">
<li>List, tuples and dictionaries are instances of <tt class="literal"><span class="pre">list</span></tt>, <tt class="literal"><span class="pre">tuple</span></tt> and
<tt class="literal"><span class="pre">dict</span></tt> respectively:</li>
</ol>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type('1')
&lt;type 'str'&gt;
&gt;&gt;&gt; type([1])
&lt;type 'list'&gt;
&gt;&gt;&gt; type((1,))
&lt;type 'tuple'&gt;
&gt;&gt;&gt; type({1:1})
&lt;type 'dict'&gt;
</pre>
</blockquote>
<ol class="arabic simple" start="6">
<li>User defined functions are instances of the <tt class="literal"><span class="pre">function</span></tt> built-in type</li>
</ol>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(f)
&lt;type 'function'&gt;
&gt;&gt;&gt; type(g)
&lt;type 'function'&gt;
</pre>
</blockquote>
<p>All the previous types are subclasses of object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for cl in int,long,float,str,list,tuple,dict: issubclass(cl,object)
True
True
True
True
True
True
True
</pre>
</blockquote>
<p>However, Python is not a 100% pure Object
Oriented Programming language and its object model has still some minor
warts, due to historical accidents.</p>
<p>Paraphrasing George Orwell, we may say that in Python 2.2-2.3, 
all objects are equal, but some objects are more equal than others.
Actually, we may distinguish Python objects in new style objects, 
or rich man objects, and old style objects, or poor man objects. 
New style objects are instances of new style classes whereas old
style objects are instances of old style classes.
The difference is that new style classes are subclasses of object whereas
old style classes are not.</p>
<p>Old style classes are there for sake of compatibility with previous 
releases of Python, but starting from Python 2.2 practically all built-in 
classes are new style classes.</p>
<p>Instance of old style classes are called old style objects. I will give
few examples of old style objects in the future.</p>
<p>In this tutorial with the term
object <em>tout court</em> we will mean new style objects, unless the contrary 
is explicitely stated.</p>
<table class="footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11" name="id12">[6]</a></td><td>one may notice that C++ does not have such a class, but C++
is <em>not</em> a strongly object oriented language ;-)</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14" name="id13">[7]</a></td><td>Actually <tt class="literal"><span class="pre">type</span></tt> is not a function, but a metaclass; nevertheless, 
since this is an advanced concept, discussed in the fourth chapter; 
for the time being it is better to think of <tt class="literal"><span class="pre">type</span></tt> as a built-in 
function analogous to <tt class="literal"><span class="pre">id</span></tt>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="objects-have-attributes">
<h2><a class="toc-backref" href="#id61" name="objects-have-attributes">Objects have attributes</a></h2>
<p>All objects have attributes describing their characteristics, that may
be accessed via the dot notation</p>
<blockquote>
<pre class="literal-block">
objectname.objectattribute
</pre>
</blockquote>
<p>The dot notation is common to most Object Oriented programming languages,
therefore the reader with a little of experience should find it not surprising 
at all (Python strongly believes in the Principle of Least Surprise). However,
Python objects also have special attributes denoted by the double-double
underscore notation</p>
<blockquote>
<pre class="literal-block">
objectname.__specialattribute__
</pre>
</blockquote>
<p>with the aim of helping the wonderful Python introspection features, that
does not have correspondence in all OOP language.</p>
<p>Consider for example the string literal &quot;spam&quot;. We may discover its
class by looking at its special attribute <em>__class__</em>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 'spam'.__class__
&lt;type 'str'&gt;
</pre>
</blockquote>
<p>Using the <tt class="literal"><span class="pre">__class__</span></tt> attribute is not always equivalent to using the 
<tt class="literal"><span class="pre">type</span></tt> function, but it works for all built-in types. Consider for instance 
the number <em>1</em>: we may extract its class as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; (1).__class__
&lt;type 'int'&gt;
</pre>
</blockquote>
<p>Notice that the parenthesis are needed to avoid confusion between the integer
1 and the float (1.).</p>
<p>The non-equivalence type/class is the key to distinguish new style objects from
old style, since for old style objects <tt class="literal"><span class="pre">type(obj)&lt;&gt;obj.__class__</span></tt>.
We may use this knowledge to make and utility function that discovers
if an object is a &quot;real&quot; object (i.e. new style) or a poor man object:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def isnewstyle(obj):
    try: #some objects may lack a __class__ attribute 
        obj.__class__
    except AttributeError:
        return False
    else: #look if there is unification type/class
        return type(obj) is obj.__class__
#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Let us check this with various examples:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import isnewstyle
&gt;&gt;&gt; isnewstyle(1)
True
&gt;&gt;&gt; isnewstyle(lambda x:x)
True
&gt;&gt;&gt; isnewstyle(id)
True
&gt;&gt;&gt; isnewstyle(type)
True
&gt;&gt;&gt; isnewstyle(isnewstyle)
True
&gt;&gt;&gt; import math
&gt;&gt;&gt; isnewstyle(math)
True
&gt;&gt;&gt; isnewstyle(math.sqrt)
True
&gt;&gt;&gt; isnewstyle('hello')
True
</pre>
</blockquote>
<p>It is not obvious to find something which is not a real object,
between the built-in objects, however it is possible. For instance, 
the <tt class="literal"><span class="pre">help</span></tt> &quot;function&quot; is an old style object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; isnewstyle(help)
False
</pre>
</blockquote>
<p>since</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; help.__class__
&lt;class site._Helper at 0x8127c94&gt;
</pre>
</blockquote>
<p>is different from</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(help)
&lt;type 'instance'&gt;
</pre>
</blockquote>
<p>Regular expression objects are even poorer objects with no <tt class="literal"><span class="pre">__class__</span></tt> 
attribute:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import re
&gt;&gt;&gt; reobj=re.compile('somestring')
&gt;&gt;&gt; isnewstyle(reobj)
False
&gt;&gt;&gt; type(reobj)
&lt;type '_sre.SRE_Pattern'&gt;
&gt;&gt;&gt; reobj.__class__ #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: __class__
</pre>
</blockquote>
<p>There other special attributes other than <tt class="literal"><span class="pre">__class__</span></tt>; a particularly useful
one is <tt class="literal"><span class="pre">__doc__</span></tt>, that contains informations on the class it
refers to. Consider for instance the <tt class="literal"><span class="pre">str</span></tt> class: by looking at its
<tt class="literal"><span class="pre">__doc__</span></tt> attribute we can get information on the usage of this class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str.__doc__
str(object) -&gt; string
Return a nice string representation of the object.
If the argument is a string, the return value is the same object.
</pre>
</blockquote>
<p>From that docstring we learn how to convert generic objects in strings;
for instance we may convert numbers, lists, tuples and dictionaries:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str(1)
'1'
&gt;&gt;&gt; str([1])
'[1]'
&gt;&gt;&gt; str((1,))
(1,)'
&gt;&gt;&gt; str({1:1})
'{1: 1}'
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">str</span></tt> is implicitely called each time we use the <tt class="literal"><span class="pre">print</span></tt> statement, since
<tt class="literal"><span class="pre">print</span> <span class="pre">obj</span></tt> is actually syntactic sugar for <tt class="literal"><span class="pre">print</span> <span class="pre">str(obj)</span></tt>.</p>
<p>Classes and modules have another interesting special attribute, the 
<tt class="literal"><span class="pre">__dict__</span></tt> attribute that gives the content of the class/module.
For instance, the contents of the standard <tt class="literal"><span class="pre">math</span></tt> module can be retrieved 
as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import math
&gt;&gt;&gt; for key in math.__dict__: print key,
...
fmod atan pow __file__ cosh ldexp hypot sinh __name__ tan ceil asin cos 
e log fabs floor tanh sqrt __doc__ frexp atan2 modf exp acos pi log10 sin
</pre>
</blockquote>
<p>Alternatively, one can use the built-in function <tt class="literal"><span class="pre">vars</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; vars(math) is math.__dict__
True
</pre>
</blockquote>
<p>This identity is true for any object with a <tt class="literal"><span class="pre">__dict__</span></tt> attribute. 
Two others interesting special attributes are <tt class="literal"><span class="pre">__doc__</span></tt></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print math.__doc__
This module is always available.  It provides access to the
mathematical functions defined by the C standard. 
</pre>
</blockquote>
<p>and <tt class="literal"><span class="pre">__file__</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; math.__file__ #gives the file associated with the module
'/usr/lib/python2.2/lib-dynload/mathmodule.so'
</pre>
</blockquote>
</div>
<div class="section" id="objects-have-methods">
<h2><a class="toc-backref" href="#id62" name="objects-have-methods">Objects have methods</a></h2>
<p>In addition to attributes, objects also have <em>methods</em>, i.e. 
functions attached to their classes <a class="footnote-reference" href="#id13" id="id14" name="id14">[7]</a>.
Methods are also invoked with the dot notation, but
they can be distinguished by attributes because they are typically
called with parenthesis (this is a little simplistic, but it is enough for
an introductory chapter). As a simple example, let me show the
invocation of the <tt class="literal"><span class="pre">split</span></tt> method for a string object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; s='hello world!'
&gt;&gt;&gt; s.split()
['hello', 'world!']
</pre>
</blockquote>
<p>In this example <tt class="literal"><span class="pre">s.split</span></tt> is called a <em>bount method</em>, since it is
applied to the string object <tt class="literal"><span class="pre">s</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; s.split
&lt;built-in method split of str object at 0x81572b8&gt;
</pre>
</blockquote>
<p>An <em>unbound method</em>, instead, is applied to the class: in this case the
unbound version of <tt class="literal"><span class="pre">split</span></tt> is applied to the <tt class="literal"><span class="pre">str</span></tt> class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str.split
&lt;method 'split' of 'str' objects&gt;
</pre>
</blockquote>
<p>A bound method is obtained from its corresponding unbound 
method by providing the object to the unbound method: for instance 
by providing <tt class="literal"><span class="pre">s</span></tt> to <tt class="literal"><span class="pre">str.split</span></tt> we obtain the same effect of <cite>s.split()</cite>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str.split(s)
['hello', 'world!']
</pre>
</blockquote>
<p>This operation is called <em>binding</em>  in the Python literature: when write
<tt class="literal"><span class="pre">str.split(s)</span></tt> we bind the unbound method <tt class="literal"><span class="pre">str.split</span></tt> to the object <tt class="literal"><span class="pre">s</span></tt>.
It is interesting to recognize that the bound and unbound methods are
<em>different</em> objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id(str.split) # unbound method reference
135414364
&gt;&gt;&gt; id(s.split) # this is a different object!
135611408
</pre>
</blockquote>
<p>The unbound method (and therefore the bound method) has a <tt class="literal"><span class="pre">__doc__</span></tt> 
attribute explaining how it works:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print str.split.__doc__
S.split([sep [,maxsplit]]) -&gt; list of strings
Return a list of the words in the string S, using sep as the
delimiter string.  If maxsplit is given, at most maxsplit
splits are done. If sep is not specified or is None, any
whitespace string is a separator.
</pre>
</blockquote>
<table class="footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17" name="id15">[8]</a></td><td>A precise definition will be given in chapter 5 that introduces the
concept of attribute descriptors. There are subtle
differences between functions and methods.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="summing-objects">
<h2><a class="toc-backref" href="#id63" name="summing-objects">Summing objects</a></h2>
<p>In a pure object-oriented world, there are no functions and everything is 
done trough methods. Python is not a pure OOP language, however quite a
lot is done trough methods. For instance, it is quite interesting to analyze 
what happens when an apparently trivial statement such as</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 1+1
2
</pre>
</blockquote>
<p>is executed in an object-oriented world.</p>
<p>The key to understand, is to notice that the number 1 is an object, specifically
an instance of class <tt class="literal"><span class="pre">int</span></tt>: this means that that 1 inherits all the methods
of the <tt class="literal"><span class="pre">int</span></tt> class. In particular it inherits a special method called 
<tt class="literal"><span class="pre">__add__</span></tt>: this means 1+1 is actually syntactic sugar for</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; (1).__add__(1)
2
</pre>
</blockquote>
<p>which in turns is syntactic sugar for</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; int.__add__(1,1)
2
</pre>
</blockquote>
<p>The same is true for subtraction, multiplication, division and other 
binary operations.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 'hello'*2
'hellohello'
&gt;&gt;&gt; (2).__mul__('hello')
'hellohello'
&gt;&gt;&gt; str.__mul__('hello',2)
'hellohello'
</pre>
</blockquote>
<p>However, notice that</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str.__mul__(2,'hello') #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: descriptor '__mul__' requires a 'str' object but received a 'int'
</pre>
</blockquote>
<p>The fact that operators are implemented as methods, is the key to
<em>operator overloading</em>: in Python (as well as in other OOP languages)
the user can redefine the operators. This is already done by default
for some operators: for instance the operator <tt class="literal"><span class="pre">+</span></tt> is overloaded
and works both for integers, floats, complex  numbers and for strings.</p>
</div>
<div class="section" id="inspecting-objects">
<h2><a class="toc-backref" href="#id64" name="inspecting-objects">Inspecting objects</a></h2>
<p>In Python it is possible to retrieve most of the attributes and methods 
of an object by using the built-in function <tt class="literal"><span class="pre">dir()</span></tt>
(try <tt class="literal"><span class="pre">help(dir)</span></tt> for more information).</p>
<p>Let me consider the simplest case of a generic object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; obj=object()
&gt;&gt;&gt; dir(obj)
['__class__', '__delattr__', '__doc__', '__getattribute__', 
 '__hash__', '__init__', '__new__', '__reduce__', '__repr__', 
 '__setattr__', '__str__']
</pre>
</blockquote>
<p>As we see, there are plenty of attributes available
even to a do nothing object; many of them are special attributes
providing introspection capabilities which are not 
common to all programming languages. We have already discussed the
meaning of some of the more obvious special attributes.
The meaning of some of  the others is quite non-obvious, however.
The docstring is invaluable in providing some clue.</p>
<p>Notice that  there are special <em>hidden</em> attributes that cannot be retrieved
with <tt class="literal"><span class="pre">dir()</span></tt>. For instance the <tt class="literal"><span class="pre">__name__</span></tt> attribute, returning the 
name of the object (defined for classes, modules and functions) 
and the <tt class="literal"><span class="pre">__subclasses__</span></tt> method, defined for classes and returning the 
list of immediate subclasses of a class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str.__name__
'str'
&gt;&gt;&gt; str.__subclasses__.__doc__
'__subclasses__() -&gt; list of immediate subclasses'
&gt;&gt;&gt; str.__subclasses__() # no subclasses of 'str' are currently defined
[]
</pre>
</blockquote>
<p>For instance by doing</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; obj.__getattribute__.__doc__
&quot;x.__getattribute__('name') &lt;==&gt; x.name&quot;
</pre>
</blockquote>
<p>we discover that the expression <tt class="literal"><span class="pre">x.name</span></tt> is syntactic sugar for</p>
<blockquote>
<tt class="literal"><span class="pre">x.__getattribute__('name')</span></tt></blockquote>
<p>Another equivalent form which is more often used is</p>
<blockquote>
<tt class="literal"><span class="pre">getattr(x,'name')</span></tt></blockquote>
<p>We may use this trick to make a function that retrieves all the
attributes of an object except the special ones:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def special(name): return name.startswith('__') and name.endswith('__')

def attributes(obj,condition=lambda n,v: not special(n)):
    &quot;&quot;&quot;Returns a dictionary containing the accessible attributes of 
    an object. By default, returns the non-special attributes only.&quot;&quot;&quot;
    dic={}
    for attr in dir(obj):
        try: v=getattr(obj,attr)
        except: continue #attr is not accessible
        if condition(attr,v): dic[attr]=v
    return dic

getall = lambda n,v: True

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Notice that certain attributes may be unaccessible (we will see how
to make attributes unaccessible in a following chapter) 
and in this case they are simply ignored.
For instance you may retrieve the regular (i.e. non special)
attributes of the built-in functions:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import attributes
&gt;&gt;&gt; attributes(f).keys()
['func_closure', 'func_dict', 'func_defaults', 'func_name', 
 'func_code', 'func_doc', 'func_globals']
</pre>
</blockquote>
<p>In the same vein of the <tt class="literal"><span class="pre">getattr</span></tt> function, there is a built-in
<tt class="literal"><span class="pre">setattr</span></tt> function (that actually calls the <tt class="literal"><span class="pre">__setattr__</span></tt> built-in
method), that allows the user to change the attributes and methods of
and object. Informations on <tt class="literal"><span class="pre">setattr</span></tt> can be retrieved from the help 
function:</p>
<blockquote>
<pre class="literal-block">
&gt;&gt;&gt; help(setattr)
Help on built-in function setattr:
setattr(...)
setattr(object, name, value)
Set a named attribute on an object; setattr(x, 'y', v) is equivalent to
``x.y = v''.
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">setattr</span></tt> can be used to add attributes to an object:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

import sys

def customize(obj,errfile=None,**kw):
    &quot;&quot;&quot;Adds attributes to an object, if possible. If not, writes an error
    message on 'errfile'. If errfile is None, skips the exception.&quot;&quot;&quot;
    for k in kw:
        try: 
            setattr(obj,k,kw[k])
        except: # setting error
            if errfile:
                print &gt;&gt; errfile,&quot;Error: %s cannot be set&quot; % k

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>The attributes of built-in objects cannot be set, however:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import customize,sys
&gt;&gt;&gt; customize(object(),errfile=sys.stdout,newattr='hello!') #error
AttributeError: newattr cannot be set
</pre>
</blockquote>
<p>On the other hand, the attributes of modules can be set:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import time
&gt;&gt;&gt; customize(time,newattr='hello!')
&gt;&gt;&gt; time.newattr
'hello!'
</pre>
</blockquote>
<p>Notice that this means we may enhances modules at run-time, but adding
new routines, not only new data attributes.</p>
<p>The <tt class="literal"><span class="pre">attributes</span></tt> and <tt class="literal"><span class="pre">customize</span></tt> functions work for any kind of objects; 
in particular, since classes are a special kind of objects, they work 
for classes, too. Here are the attributes of the <tt class="literal"><span class="pre">str</span></tt>, <tt class="literal"><span class="pre">list</span></tt> and 
<tt class="literal"><span class="pre">dict</span></tt> built-in types:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import attributes
&gt;&gt;&gt; attributes(str).keys()
['startswith', 'rjust', 'lstrip', 'swapcase', 'replace','encode',
 'endswith', 'splitlines', 'rfind', 'strip', 'isdigit', 'ljust', 
 'capitalize', 'find', 'count', 'index', 'lower', 'translate','join', 
 'center', 'isalnum','title', 'rindex', 'expandtabs', 'isspace', 
 'decode', 'isalpha', 'split', 'rstrip', 'islower', 'isupper', 
 'istitle', 'upper']
&gt;&gt;&gt; attributes(list).keys()
['append', 'count', 'extend', 'index', 'insert', 'pop', 
 'remove', 'reverse', 'sort']
&gt;&gt;&gt; attributes(dict).keys()
['clear','copy','fromkeys', 'get', 'has_key', 'items','iteritems',
 'iterkeys', 'itervalues', 'keys', 'pop', 'popitem', 'setdefault', 
 'update', 'values']
</pre>
</blockquote>
<p>Classes and modules have a special attribute <tt class="literal"><span class="pre">__dict__</span></tt> giving the 
dictionary of their attributes. Since it is often a quite large dictionary, 
it is convenient to define an utility function printing this dictionary in a 
nice form:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def pretty(dic):
    &quot;Returns a nice string representation for the dictionary&quot;
    keys=dic.keys(); keys.sort() # sorts the keys
    return '\n'.join(['%s = %s' % (k,dic[k]) for k in keys])

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>I encourage the use of this function in order to retrieve more 
information about the modules of the standard library:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import pretty
&gt;&gt;&gt; import time #look at the 'time' standard library module
&gt;&gt;&gt; print pretty(vars(time))
__doc__ = This module provides various functions to manipulate time values.
There are two standard representations of time.  One is the number
of seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer
or a floating point number (to represent fractions of seconds).
The Epoch is system-defined; on Unix, it is generally January 1st, 1970.
The actual value can be retrieved by calling gmtime(0).
The other representation is a tuple of 9 integers giving local time.
The tuple items are:
  year (four digits, e.g. 1998)
  month (1-12)
  day (1-31)
  hours (0-23)
  minutes (0-59)
  seconds (0-59)
  weekday (0-6, Monday is 0)
  Julian day (day in the year, 1-366)
  DST (Daylight Savings Time) flag (-1, 0 or 1)
If the DST flag is 0, the time is given in the regular time zone;
if it is 1, the time is given in the DST time zone;
if it is -1, mktime() should guess based on the date and time.
Variables:
timezone -- difference in seconds between UTC and local standard time
altzone -- difference in  seconds between UTC and local DST time
daylight -- whether local time should reflect DST
tzname -- tuple of (standard time zone name, DST time zone name)
Functions:
time() -- return current time in seconds since the Epoch as a float
clock() -- return CPU time since process start as a float
sleep() -- delay for a number of seconds given as a float
gmtime() -- convert seconds since Epoch to UTC tuple
localtime() -- convert seconds since Epoch to local time tuple
asctime() -- convert time tuple to string
ctime() -- convert time in seconds to string
mktime() -- convert local time tuple to seconds since Epoch
strftime() -- convert time tuple to string according to format specification
strptime() -- parse string to time tuple according to format specification
__file__ = /usr/local/lib/python2.3/lib-dynload/time.so
__name__ = time
accept2dyear = 1
altzone = 14400
asctime = &lt;built-in function asctime&gt;
clock = &lt;built-in function clock&gt;
ctime = &lt;built-in function ctime&gt;
daylight = 1
gmtime = &lt;built-in function gmtime&gt;
localtime = &lt;built-in function localtime&gt;
mktime = &lt;built-in function mktime&gt;
newattr = hello!
sleep = &lt;built-in function sleep&gt;
strftime = &lt;built-in function strftime&gt;
strptime = &lt;built-in function strptime&gt;
struct_time = &lt;type 'time.struct_time'&gt;
time = &lt;built-in function time&gt;
timezone = 18000
tzname = ('EST', 'EDT')
</pre>
</blockquote>
<p>The list of the built-in Python types can be found in the <tt class="literal"><span class="pre">types</span></tt> module:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import types
&gt;&gt;&gt; t_dict=dict([(k,v) for (k,v) in vars(types).iteritems() 
... if k.endswith('Type')])
&gt;&gt;&gt; for t in t_dict: print t,
...
DictType IntType TypeType FileType CodeType XRangeType EllipsisType 
SliceType BooleanType ListType MethodType TupleType ModuleType FrameType 
StringType LongType BuiltinMethodType BufferType FloatType ClassType 
DictionaryType BuiltinFunctionType UnboundMethodType UnicodeType 
LambdaType DictProxyType ComplexType GeneratorType ObjectType 
FunctionType InstanceType NoneType TracebackType
</pre>
</blockquote>
<p>For a pedagogical account of the most elementary 
Python introspection features,
Patrick O' Brien:
<a class="reference" href="http://www-106.ibm.com/developerworks/linux/library/l-pyint.html">http://www-106.ibm.com/developerworks/linux/library/l-pyint.html</a></p>
</div>
<div class="section" id="built-in-objects-iterators-and-generators">
<h2><a class="toc-backref" href="#id65" name="built-in-objects-iterators-and-generators">Built-in objects: iterators and generators</a></h2>
<p>At the end of the last section , I have used the <tt class="literal"><span class="pre">iteritems</span></tt> method 
of the dictionary, which returns an iterator:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; dict.iteritems.__doc__
'D.iteritems() -&gt; an iterator over the (key, value) items of D'
</pre>
</blockquote>
<p>Iterators (and generators) are new features of Python 2.2 and could not be
familiar to all readers. However, since they are unrelated to OOP, they 
are outside the scope of this book and will not be discussed here in detail. 
Nevertheless, I will give a typical example of use of a generator, since
this construct will be used in future chapters.</p>
<p>At the syntactical level, a generator is a &quot;function&quot; with (at least one) 
<tt class="literal"><span class="pre">yield</span></tt> statement (notice that in Python 2.2 the <tt class="literal"><span class="pre">yield</span></tt> statement is
enabled trough the <tt class="literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generators</span></tt> syntax):</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

import re

def generateblocks(regexp,text):
    &quot;Generator splitting text in blocks according to regexp&quot;
    start=0
    for MO in regexp.finditer(text):
        beg,end=MO.span()
        yield text[start:beg] # actual text
        yield text[beg:end] # separator
        start=end
    lastblock=text[start:] 
    if lastblock: yield lastblock; yield ''

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>In order to understand this example, the reader my want to refresh his/her 
understanding of regular expressions; since this is not a subject for 
this book, I simply remind the meaning of <tt class="literal"><span class="pre">finditer</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import re
&gt;&gt;&gt; help(re.finditer)
finditer(pattern, string)
    Return an iterator over all non-overlapping matches in the
    string.  For each match, the iterator returns a match object.
    Empty matches are included in the result.
</pre>
</blockquote>
<p>Generators can be thought of as resumable functions that stop at the
<tt class="literal"><span class="pre">yield</span></tt> statement and resume from the point where they left.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import generateblocks
&gt;&gt;&gt; text='Python_Rules!'
&gt;&gt;&gt; g=generateblocks(re.compile('_'),text)
&gt;&gt;&gt; g
&lt;generator object at 0x401b140c&gt;
&gt;&gt;&gt; dir(g)
['__class__', '__delattr__', '__doc__', '__getattribute__', '__hash__', 
 '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', 
 '__repr__', '__setattr__', '__str__', 'gi_frame', 'gi_running', 'next']
</pre>
</blockquote>
<p>Generator objects can be used as iterators in a <tt class="literal"><span class="pre">for</span></tt> loop.
In this example the generator takes a text and a regular expression
describing a fixed delimiter; then it splits the text in blocks
according to the delimiter. For instance, if the delimiter is
'_', the text 'Python Rules!' is splitted as 'Python', '_' and 'Rules!':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for n, block in enumerate(g): print n, block
...
0 Python
1 
2 Rules!
3
</pre>
</blockquote>
<p>This example also show the usage of the new Python 2.3 built-in <tt class="literal"><span class="pre">enumerate</span></tt>.</p>
<p>Under the hood the <tt class="literal"><span class="pre">for</span></tt> loop is calling the generator via its 
<tt class="literal"><span class="pre">next</span></tt> method, until the <tt class="literal"><span class="pre">StopIteration</span></tt> exception is raised.
For this reason a new call to the <tt class="literal"><span class="pre">for</span></tt> loop will have no effect:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for n, block in enumerate(g): print n, block
...
</pre>
</blockquote>
<p>The point is that the generator has already yield its last element:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; g.next() # error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
StopIteration
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">generateblocks</span></tt> always returns an even number of blocks; odd blocks
are delimiters whereas even blocks are the intertwining text; there may be 
empty blocks, corresponding to the null string ''.</p>
<p>It must be remarked the difference with the 'str.split' method</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; 'Python_Rules!'.split('_')
['Python', 'Rules!']
</pre>
</blockquote>
<p>and the regular expression split method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; re.compile('_').split('Python_Rules!')
['Python', 'Rules!']
</pre>
</blockquote>
<p>both returns lists with an odd number of elements and both miss the separator. 
The regular expression split method can catch the separator, if wanted,</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; re.compile('(_)').split('Python_Rules!')
['Python', '_', 'Rules!']
</pre>
</blockquote>
<p>but still is different from the generator, since it returns a list. The
difference is relevant if we want to split a very large text, since 
the generator avoids to build a very large list and thus it is much more
memory efficient (it is faster, too). Moreover, <tt class="literal"><span class="pre">generateblocks</span></tt>
works differently in the case of multiple groups:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; delim=re.compile('(_)|(!)') #delimiter is space or exclamation mark
&gt;&gt;&gt; for n, block in enumerate(generateblocks(delim,text)): 
...     print n, block
0 Python
1 _
2 Rules
3 !
</pre>
</blockquote>
<p>whereas</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; delim.split(text)
['Python', '_', None, 'Rules', None, '!', '']
</pre>
</blockquote>
<p>gives various unwanted <tt class="literal"><span class="pre">None</span></tt> (which could be skipped with 
<tt class="literal"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">delim.split(text)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None]</span></tt>); notice, that
there are no differences (apart from the fact that <tt class="literal"><span class="pre">delim.split(text)</span></tt>
has an odd number of elements) when one uses a single group regular expression:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; delim=re.compile('(_|!)')
&gt;&gt;&gt; delim.split(text)
['Python', '_', 'Rules', '!', '']
</pre>
</blockquote>
<p>The reader unfamiliar with iterators and generators is encouraged
to look at the standard documentation and other 
references. For instance, there are Alex Martelli's notes on iterators at 
<a class="reference" href="http://www.strakt.com/dev_talks.html">http://www.strakt.com/dev_talks.html</a>
and there is a good article on generators by David Mertz
<a class="reference" href="http://www-106.ibm.com/developerworks/linux/library/l-pycon.html">http://www-106.ibm.com/developerworks/linux/library/l-pycon.html</a></p>
</div>
</div>
<div class="section" id="the-convenience-of-functions">
<h1><a class="toc-backref" href="#id66" name="the-convenience-of-functions">THE CONVENIENCE OF FUNCTIONS</a></h1>
<p>Functions are the most basic Python objects. They are also the simplest
objects where one can apply the  metaprogramming techniques that are
the subject of this book. The tricks used in this chapter and the utility
functions defined here will be used over all the book. Therefore this
is an <em>essential</em> chapter.</p>
<p>Since it is intended to be a gentle introduction, the tone will be
informal.</p>
<div class="section" id="id16">
<h2><a class="toc-backref" href="#id67" name="id16">Introduction</a></h2>
<p>One could be surprised that a text on OOP begins with a chapter on the
well known old-fashioned functions. In some sense, this is also
against the spirit of an important trend in OOP, which tries to
shift the focus from functions to data. In pure OOP languages,
there are no more functions, only methods. <a class="footnote-reference" href="#id15" id="id17" name="id17">[8]</a></p>
<p>However, there are good reasons for that:</p>
<ol class="arabic simple">
<li>In Python,  functions  <em>are</em> objects. And particularly useful ones.</li>
<li>Python functions are pretty powerful and all their secrets are probably
<em>not</em> well known to the average Python programmer.</li>
<li>In the solutions of many problems, you don't need the full apparatus
of OOP: good old functions can be enough.</li>
</ol>
<p>Moreover, I am a believer in the multiparadigm approach to programming, 
in which you choose your tools according to your problem. 
With a  bazooka you can kill a mosquito, yes, but this does not mean 
that you must use the bazooka <em>always</em>. 
In certain languages, you have no choice, and you must define
a class (involving a lot of boiler plate code) even for the most trivial
application. Python's philosophy is to keep simple things simple, but
having the capability of doing even difficult things with a reasonable
amount of effort. The message of this chapter will be: &quot;use functions when 
you don't need classes&quot;. Functions are good because:</p>
<ol class="arabic simple">
<li>They are easy to write (no boiler plate);</li>
<li>They are easy to understand;</li>
<li>They can be reused in your code;</li>
<li>Functions are an essential building block in the construction of objects.</li>
</ol>
<p>Even if I think that OOP is an extremely effective strategy, with
enormous advantages on design, maintanibility and reusability of code,
nevertheless this book is <em>not</em> intended to be a panegyric of OOP. There
are cases in which you don't need OOP. I think the critical parameter is
the size of the program. These are the rules I follows usually (to be
taken as indicative):</p>
<ol class="arabic simple">
<li>If I have to write a short script of 20-30 lines, that copies two or 
three files and prints some message, I use fast and dirty spaghetti-code; 
there is no use for OOP.</li>
<li>If your script grows to one-hundred lines or more, I structure
it  write a few routines and a main program: but still I can live
without OOP.</li>
<li>If the script goes beyond the two hundred lines, I start
collecting my routines in few classes.</li>
<li>If the script goes beyond the five hundred lines, I split the program
in various files and modules and convert it to a package.</li>
<li>I never write a function longer than 50 lines, since 50 lines is more
or less the size of a page in my editor, and I need to be able to
see the entire function in a page.</li>
</ol>
<p>Of course your taste could be different and you could prefer to write a 
monolitic program of five thousand lines; however the average size of 
the modules in the Python standard library is of 111 lines.
I think this is a <em>strong</em> suggestion towards 
a modular style of programming, which
is <em>very</em> well supported in Python.</p>
<p>The point is that OOP is especially useful for <em>large</em> programs: if you
only use Python for short system administration scripts you may well
live without OOP. Unfortunaly, as everybody knows, short scripts have
an evil tendency to become medium size scripts, and medium size scripts
have the even more evil tendency to become large scripts and possible
even full featured applications ! For this reason it is very probable
that at a certain moment you will feel the need for OOP.</p>
<p>I remember my first big program, a long time ago: I wrote a program
to draw mathematical functions in AmigaBasic. It was good and nice
until it had size of few hundred lines; but when it passed a thousand
of lines, it became rapidly unmanageable and unmaintenable. There where
three problems:</p>
<ol class="arabic simple">
<li>I could not split the program in modules, as I wanted, due to the
limitations of AmigaBasic;</li>
<li>I was missing OOP to keep the logic of the program all together, but
at the time I didn't know that;</li>
<li>I was missing effective debugging techniques.</li>
<li>I was missing effective refactoring tools.</li>
</ol>
<p>I am sure anybody who has ever written a large program has run in these
limitations: and the biggest help of OOP is in overcoming these limitations.
Obviously, miracles are impossible, and even object oriented programs can
grow to a size where they become unmaintanable: the point is that the
critical limit is much higher than the thousand lines of structured programs.
I haven't yet reached the limit of unmanageability with Python. The fact
that the standard library is 66492 lines long (as result from the total
number of lines in <tt class="literal"><span class="pre">/usr/local/lib/python2.2/</span></tt>), but it is still manageable,
give me an hope ;-)</p>
<blockquote>
<table class="footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19" name="id18">[9]</a></td><td>However, one could argue that having functions distinguished from 
methods is the best thing to do, even in a strongly object-oriented 
world. For instance, generic functions can be used to implement 
multimethods. See for instance Lisp, Dylan and MultiJava. This latter 
is forced to introduce the concept of function outside a class, 
foreign to traditional Java, just to implement multimethods.</td></tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="a-few-useful-functions">
<h2><a class="toc-backref" href="#id68" name="a-few-useful-functions">A few useful functions</a></h2>
<p>It is always a good idea to have a set of useful function collected in
a user defined module. The first function we want to have in our module
is the <tt class="literal"><span class="pre">do_nothing</span></tt> function:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def do_nothing(*args,**kw): pass

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>This function accept a variable number of arguments and keywords (I
defer the reader to the standard documentation if she is unfamiliar
with these concept; this is <em>not</em> another Python tutorial ;-) and
return <tt class="literal"><span class="pre">None</span></tt>. It is very useful for debugging purposes, when in a
complex program you may want concentrate your attention to few crucial
functions and set the non-relevant functions to <tt class="literal"><span class="pre">do_nothing</span></tt> functions.</p>
<p>A second function which is useful in developing programs is a timer
function. Very ofter indeed,  we may want to determine the bottleneck
parts of a program, we are interested in profiling them and in seeing 
if we can improve the speed by improving the algorithm, or by using
a Python &quot;compiler&quot; such as Psyco, or if really we need to write a C 
extension. In my experience, I never needed to write a C extension,
since Python is fast enough. Nevertheless, to profile a program is
always a good idea and Python provides a profiler module in the 
stardard library with this aim. Still, it is convenient to have
a set of user defined functions to test the execution speed of
few selected routines (whereas the standard profiler profiles everything).</p>
<p>We see from the standard library documentation that
the current time can be retrieved from the <tt class="literal"><span class="pre">time</span></tt> module: <a class="footnote-reference" href="#id18" id="id19" name="id19">[9]</a></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import time
&gt;&gt;&gt; time.asctime()
'Wed Jan 15 12:46:03 2003'
</pre>
</blockquote>
<p>Since we are not interested in the date but only in the time, we need
a function to extract it. This is easily implemented:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

import time

def get_time():
    &quot;Return the time of the system in the format HH:MM:SS&quot;
    return time.asctime().split()[3]

#&lt;/oopp.py&gt;

&gt;&gt;&gt; from oopp import get_time
&gt;&gt;&gt; get_time()
'13:03:49'
</pre>
</blockquote>
<p>Suppose, for instance, we want to know how much it takes to Python
to write a Gigabyte of data. This can be a quite useful benchmark
to have an idea of the I/O bottlenecks in our system. Since to take in memory
a file of a Gigabyte can be quite problematic, let me compute the
time spent in writing 1024 files of one Megabyte each. To this
aim we need a <tt class="literal"><span class="pre">writefile</span></tt> function</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def writefile(fname,data):
    f=file(fname,'w')
    f.write(data)
    f.close()

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>and timing function. The idea is to wrap the <tt class="literal"><span class="pre">writefile</span></tt> function in
a <tt class="literal"><span class="pre">with_clock</span></tt> function as follows:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def with_clock(func,n=1):
    def _(*args,**kw): # this is a closure
        print &quot;Process started on&quot;,get_time()
        print ' .. please wait ..'
        for i in range(n): func(*args,**kw)
        print &quot;Process ended on&quot;,get_time()
    return _

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>The wrapper function <tt class="literal"><span class="pre">with_clock</span></tt> has converted the function <tt class="literal"><span class="pre">writefile</span></tt> 
in a function <tt class="literal"><span class="pre">with_clock(writefile)</span></tt> which has the same arguments
of <tt class="literal"><span class="pre">writefile</span></tt>, but contains additional features: in this case
timing capabilities. Technically speaking, the internal function <tt class="literal"><span class="pre">_</span></tt>
is called a <em>closure</em>. Closures are very common in functional languages 
and can be used in Python too, with very little effort <a class="footnote-reference" href="#id21" id="id20" name="id20">[10]</a>.</p>
<p>I will use closures very often in the following, and I will use
the convention of denoting with &quot;_&quot; the inner 
function in the closure, since there is no reason of giving to it a 
descriptive name (the name 'with_clock' in the outer function 
is descriptive enough). For the same, reason I do not use a 
docstring for &quot;_&quot;. If Python would allow multistatement lambda
functions, &quot;_&quot; would be a good candidate for an anonymous function.</p>
<p>Here is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; data='*'*1024*1024 #one megabyte
&gt;&gt;&gt; with_clock(writefile,n=1024)('datafile',data) #.
Process started on 21:20:01
 .. please wait ..
Process ended on 21:20:57
</pre>
</blockquote>
<p>This example shows that Python has written one Gigabyte of data (splitted in
1024 chunks of one Megabyte each) in less than a minute. However,the 
result depends very much on the filesystem. I always suggest people
to profile their programs, since one <em>always</em> find surprises.
For instance, I have checked the performance of my laptop, 
a dual machine Windows 98 SE/ Red Hat Linux 7.3.
The results are collected in the following table:</p>
<blockquote>
<table border class="table">
<colgroup>
<col width="27%" />
<col width="34%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th>Linux ext-3</th>
<th>FAT under Linux</th>
<th>FAT under Windows 98</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>24-25 s</td>
<td>56-58 s</td>
<td>86-88 s</td>
</tr>
</tbody>
</table>
</blockquote>
<p>We see that Linux is <em>much</em> faster: more than three times faster than
Windows, using the same machine! Notice that the FAT filesystem under
Linux (where it is <em>not</em> native) is remarkably faster than the FAT
under Windows 98, where it is native !! I think that now my readers
can begin to understand why this book has been written under Linux 
and why I <em>never</em> use Windows for programming (actually I use it only 
to see the DVD's ;-).</p>
<p>I leave as an exercise for the reader to check the results on this
script on their machine. Since my laptop is quite old, you will probably
have much better performances (for instance on my linux desktop I can
write a Gigabyte in less than 12 seconds!). However, there are <em>always</em>
surprises: my desktop is a dual Windows 2000 machine with three different
filesystems, Linux ext-2, FAT and NTFS. Surprisingly enough, the NT
filesystem is the more inefficient for writing, <em>ten times slower</em> 
than Linux!</p>
<blockquote>
<table border class="table">
<colgroup>
<col width="27%" />
<col width="34%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th>Linux ext-2</th>
<th>FAT under Win2000</th>
<th>NTFS under Win2000</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>11-12 s</td>
<td>95-97 s</td>
<td>117-120 s</td>
</tr>
</tbody>
</table>
</blockquote>
<table class="footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20" name="id21">[10]</a></td><td>Users of Python 2.3 can give a look to the new <tt class="literal"><span class="pre">datetime</span></tt> module,
if they are looking for a sophisticated clock/calendar.</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23" name="id22">[11]</a></td><td>There are good references on functional programming in Python; 
I suggest the Python Cookbook and the articles by David Mertz
www.IBM.dW.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="functions-are-objects">
<h2><a class="toc-backref" href="#id69" name="functions-are-objects">Functions are objects</a></h2>
<p>As we said in the first chapter, objects have attributes accessible with the 
dot notation. This is not surprising at all. However, it could be
surprising to realize that since Python functions are objects, they
can have attributes, too. This could be surprising since this feature is quite 
uncommon: typically or i) the language is
not object-oriented, and therefore functions are not objects, or ii)
the language is strongly object-oriented and does not have functions, only 
methods. Python is a multiparadigm language (which I prefer to the
term &quot;hybrid&quot; language), therefore it has functions that are objects,
as in Lisp and other functional languages. 
Consider for instance the <tt class="literal"><span class="pre">get_time</span></tt> function.
That function has at least an useful attribute, its doctring:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import get_time
&gt;&gt;&gt; print get_time.func_doc
Return the time of the system in the format HH:MM:SS
</pre>
</blockquote>
<p>The docstring can also be obtained with the <tt class="literal"><span class="pre">help</span></tt> function:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; help(get_time)
Help on function get_time in module oopp:
get_time()
    Return the time of the system in the format HH:MM:SS
</pre>
</blockquote>
<p>Therefore <tt class="literal"><span class="pre">help</span></tt> works on user-defined functions, too, not only on
built-in functions. Notice that <tt class="literal"><span class="pre">help</span></tt> also returns the argument list of 
the function. For instance, this is
the help message on the <tt class="literal"><span class="pre">round</span></tt> function that we will use in the
following:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; help(round)
Help on built-in function round:
round(...)
    round(number[, ndigits]) -&gt; floating point number
    Round a number to a given precision in decimal digits (default 0 
    digits).This always returns a floating point number.  Precision may 
    be negative.
</pre>
</blockquote>
<p>I strongly recommend Python programmers to use docstrings, not
only for clarity sake during the development, but especially because
it is possible to automatically generate nice HTML documentation from 
the docstrings, by using the standard tool &quot;pydoc&quot;.</p>
<p>One can easily add attributes to a function. For instance:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; get_time.more_doc='get_time invokes the function time.asctime'
&gt;&gt;&gt; print get_time.more_doc
get_time invokes the function time.asctime
</pre>
</blockquote>
<p>Attributes can be functions, too:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def IamAfunction(): print &quot;I am a function attached to a function&quot;
&gt;&gt;&gt; get_time.f=IamAfunction
&gt;&gt;&gt; get_time.f()
I am a function attached to a function
</pre>
</blockquote>
<p>This is a quite impressive potentiality of Python functions, which has
no direct equivalent in most other languages.</p>
<p>One possible application is to fake C &quot;static&quot; variables. Suppose
for instance we need a function remembering how may times it is
called: we can simply use</p>
<blockquote>
<pre class="literal-block">
#&lt;double.py&gt;

def double(x):
    try: #look if double.counter is defined
        double.counter
    except AttributeError:
        double.counter=0 #first call
    double.counter+=1
    return 2*x

double(double(2))
print &quot;double has been called %s times&quot; % double.counter

#&lt;/double.py&gt;
</pre>
</blockquote>
<p>with output <tt class="literal"><span class="pre">double</span> <span class="pre">has</span> <span class="pre">been</span> <span class="pre">called</span> <span class="pre">2</span> <span class="pre">times</span></tt>.
A more elegant approach involves closures. A closure can enhance an
ordinary function, providing to it the capability of remembering 
the results of its previous calls and avoiding the duplication of
computations:</p>
<pre class="literal-block">
#&lt;oopp.py&gt;

def withmemory(f):
    &quot;&quot;&quot;This closure invokes the callable object f only if need there is&quot;&quot;&quot;
    argskw=[]; result=[]
    def _(*args,**kw): 
        akw=args,kw
        try: # returns a previously stored result
            i=argskw.index(akw)
        except ValueError: # there is no previously stored result
            res=f(*args,**kw)  # returns the new result
            argskw.append(akw) # update argskw
            result.append(res) # update result
            return res
        else:
            return result[i]  
    _.argskw=argskw #makes the argskw list accessible outside
    _.result=result #makes the result list accessible outside
    return _

def memoize(f):
    &quot;&quot;&quot;This closure remembers all f invocations&quot;&quot;&quot;
    argskw,result = [],[]
    def _(*args,**kw): 
        akw=args,kw
        try: # returns a previously stored result
            return result[argskw.index(akw)]
        except ValueError: # there is no previously stored result
            argskw.append(akw) # update argskw
            result.append(f(*args,**kw)) # update result
            return result[-1] # return the new result
    _.argskw=argskw #makes the argskw list accessible outside
    _.result=result #makes the result list accessible outside
    return _

#&lt;/oopp.py&gt;
</pre>
<p>Now, if we call the wrapped function <tt class="literal"><span class="pre">f</span></tt>  twice with the same arguments, 
Python can give the result without repeating the (possibly very long) 
computation.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def f(x):
...    print 'called f'
...    return x*x
&gt;&gt;&gt; wrapped_f=withmemory(f)
&gt;&gt;&gt; wrapped_f(2) #first call with the argument 2; executes the computation
called f
4
&gt;&gt;&gt; wrapped_f(2) #does not repeat the computation
4
&gt;&gt;&gt; wrapped_f.result
[4]
&gt;&gt;&gt; wrapped_f.argskw
[((2,), {})]
</pre>
</blockquote>
</div>
<div class="section" id="profiling-functions">
<h2><a class="toc-backref" href="#id70" name="profiling-functions">Profiling functions</a></h2>
<p>The <tt class="literal"><span class="pre">with_clock</span></tt> function provided before was intended to be
pedagogical; as such it is a quite poor solution to the
problem of profiling a Python routine. A better solution involves
using two others functions in the time library, <tt class="literal"><span class="pre">time.time()</span></tt> 
that gives that time in seconds elapsed from a given date, and 
<tt class="literal"><span class="pre">time.clock()</span></tt> that gives the time spent by the CPU in a given 
computation. Notice that <tt class="literal"><span class="pre">time.clock()</span></tt> has not an infinite
precision (the precision depends on the system) and one 
should expect relatively big errors if the function runs in
a very short time. That's the reason why it is convenient
to execute multiple times short functions and divide the total
time by the number of repetitions. Moreover, one should subtract the
overhead do to the looping. This can be computed with the following
routine:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def loop_overhead(N):
    &quot;Computes the time spent in empty loop of N iterations&quot;
    t0=time.clock()
    for i in xrange(N): pass
    return time.clock()-t0

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>For instance, on my laptop an empty loop of one million of iterations
is performed in 1.3 seconds. Typically the loop overhead is negligible,
whereas the real problem is the function overhead.</p>
<p>Using the attribute trick discussed above, we may
define a <tt class="literal"><span class="pre">with_timer</span></tt> function that enhances quite a bit 
<tt class="literal"><span class="pre">with_clock</span></tt>:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def with_timer(func, modulename='__main__', n=1, logfile=sys.stdout):
    &quot;&quot;&quot;Wraps the function func and executes it n times (default n=1). 
    The average time spent in one iteration, express in milliseconds, 
    is stored in the attributes func.time and func.CPUtime, and saved 
    in a log file which defaults to the standard output.
    &quot;&quot;&quot;
    def _(*args,**kw): # anonymous function
        time1=time.time()
        CPUtime1=time.clock()
        print 'Executing %s.%s ...' % (modulename,func.__name__),
        for i in xrange(n): res=func(*args,**kw) # executes func n times
        time2=time.time()
        CPUtime2=time.clock()
        func.time=1000*(time2-time1)/n
        func.CPUtime=1000*(CPUtime2-CPUtime1-loop_overhead(n))/n
        if func.CPUtime&lt;10: r=3 #better rounding
        else: r=1 #default rounding
        print &gt;&gt; logfile, 'Real time: %s ms' % round(func.time,r),
        print &gt;&gt; logfile, ' CPU time: %s ms' % round(func.CPUtime,r)
        return res
    return _

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here it is an example of application:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import with_timer,writefile
&gt;&gt;&gt; data='*'*1024*1024 #one megabyte
&gt;&gt;&gt; with_timer(writefile,n=1024)('datafile',data) #.
Executing writefile ... Real time: 60.0 ms  CPU time: 42.2 ms
</pre>
</blockquote>
<p>The CPU time can be quite different from the real time, 
as you can see in the following example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import time
&gt;&gt;&gt; def sleep(): time.sleep(1)
...
&gt;&gt;&gt; with_timer(sleep)() #.
Executing sleep ... Real time: 999.7 ms  CPU time: 0.0 ms
</pre>
</blockquote>
<p>We see that Python has run for 999.7 ms (i.e. 1 second, up to
approximation errors in the system clock) during which the CPU has 
worked for 0.0 ms (i.e. the CPU took a rest ;-).
The CPU time is the relevant time to use with the purpose of
benchmarking Python speed.</p>
<p>I should notice that the approach pursued in <tt class="literal"><span class="pre">with_timer</span></tt> is still
quite simple. A better approach would be to
plot the time versus the number of iteration, do a linear interpolation
and extract the typical time for iteration from that. This allows
to check visually that the machine is not doing something strange
during the execution time and it is what
I do in my personal benchmark routine; doing something similar is
left as an exercise for the reader ;-).</p>
<p>Another approach is to use the <tt class="literal"><span class="pre">timeit.py</span></tt> module (new in Python 2.3,
but works also with Python 2.2):</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

import timeit,__main__,warnings

warnings.filterwarnings('ignore',
'import \* only allowed at module level',SyntaxWarning)

def timeit_(stmt,setup='from __main__ import *',n=1000):
    t=timeit.Timer(stmt,setup)
    try: print t.repeat(number=n) # class timeit 3 times
    except: t.print_exc()

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>It is often stated that Python is slow and quite ineffective
in application involving hard computations. This is generally speaking
true, but how bad is the situation ? To test the (in)efficiency of
Python on number crunching, let me give a function to compute the
Mandelbrot set, which I have found in the Python Frequently Asked
Question (FAQ 4.15. <em>Is it possible to write obfuscated one-liners 
in Python?</em>).
This function is due to Ulf Bartelt and you should ask him to know how
does it work ;-)</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def mandelbrot(row,col):
    &quot;Computes the Mandelbrot set in one line&quot;
    return (lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(
        lambda x,y:x+y,map(lambda y,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=
        lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM, Sx=Sx,Sy=Sy:reduce(
        lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro, i=i,
        Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k&lt;=0)
        or (x*x+y*y&gt;=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):
        f(xc,yc,x,y,k,f):chr(64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),
        range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy))))(
        -2.1, 0.7, -1.2, 1.2, 30, col, row)
    #    \___ ___/  \___ ___/  |   |    |_ lines on screen
    #        V          V      |   |______ columns on screen
    #        |          |      |__________ maximum of &quot;iterations&quot;
    #        |          |_________________ range on y axis
    #        |____________________________ range on x axis
    
#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here there is the benchmark on my laptop:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import mandelbrot,with_timer
&gt;&gt;&gt; row,col=24,75
&gt;&gt;&gt; output=with_timer(mandelbrot,n=1)(row,col)
Executing __main__.mandelbrot ... Real time: 427.9 ms  CPU time: 410.0 ms
&gt;&gt;&gt; for r in range(row): print output[r*col:(r+1)*col]
...
BBBBBBBBBBBBBBCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDCCCCCCCCCCCCCC
BBBBBBBBBBBBCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDEEEEEEFGYLFFFEEEEEDDDDDCCCCCCCCC
BBBBBBBBBBCCCCCCCDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEFFFGIKNJLLGEEEEEEDDDDDDCCCCC
BBBBBBBBBCCCCCDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEFFFFGHJJR^QLIHGFFEEEEEEDDDDDDCC
BBBBBBBBCCCDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEFFFGGGHIK_______LHGFFFFFEEEEDDDDDD
BBBBBBBCCDDDDDDDDDDDDDDDDDDDDEEEEEEEFFFGHILIIIJJKMS_____PLJJIHGGGHJFEEDDDDD
BBBBBBCDDDDDDDDDDDDDDDDDDEEEEEFFFFFFGGGHMQ__T________________QLOUP[OGFEDDDD
BBBBBCDDDDDDDDDDDDDDDEEEFFFFFFFFFGGGGHJNM________________________XLHGFFEEDD
BBBBCDDDDDDDDDEEEEEFFGJKHHHHHHHHHHHHIKN[__________________________MJKGFEEDD
BBBBDDDDEEEEEEEEFFFFGHIKPVPMNU_QMJJKKZ_____________________________PIGFEEED
BBBCDEEEEEEEEFFFFFFHHHML___________PQ_______________________________TGFEEEE
BBBDEEEEEEFGGGGHHHJPNQP^___________________________________________IGFFEEEE
BBB_____________________________________________________________OKIHGFFEEEE
BBBDEEEEEEFGGGGHHHJPNQP^___________________________________________IGFFEEEE
BBBCDEEEEEEEEFFFFFFHHHML___________PQ_______________________________TGFEEEE
BBBBDDDDEEEEEEEEFFFFGHIKPVPMNU_QMJJKKZ_____________________________PIGFEEED
BBBBCDDDDDDDDDEEEEEFFGJKHHHHHHHHHHHHIKN[__________________________MJKGFEEDD
BBBBBCDDDDDDDDDDDDDDDEEEFFFFFFFFFGGGGHJNM________________________XLHGFFEEDD
BBBBBBCDDDDDDDDDDDDDDDDDDEEEEEFFFFFFGGGHMQ__T________________QLOUP[OGFEDDDD
BBBBBBBCCDDDDDDDDDDDDDDDDDDDDEEEEEEEFFFGHILIIIJJKMS_____PLJJIHGGGHJFEEDDDDD
BBBBBBBBCCCDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEFFFGGGHIK_______LHGFFFFFEEEEDDDDDD
BBBBBBBBBCCCCCDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEFFFFGHJJR^QLIHGFFEEEEEEDDDDDDCC
BBBBBBBBBBCCCCCCCDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEFFFGIKNJLLGEEEEEEDDDDDDCCCCC
BBBBBBBBBBBBCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDEEEEEEFGYLFFFEEEEEDDDDDCCCCCCCCC
</pre>
</blockquote>
<p>I am willing to concede that this code is not typical Python code and
actually it could be an example of <em>bad</em> code, but I wanted a nice ASCII 
picture on my book ... :) Also, this prove that Python is not necessarily 
readable and easy to understand ;-)
I leave for the courageous reader to convert the previous algorithm to C and
measure the difference in speed ;-)</p>
</div>
<div class="section" id="about-python-speed">
<h2><a class="toc-backref" href="#id71" name="about-python-speed">About Python speed</a></h2>
<p>The best way to improved the speed is to improve the algorithm; in
this sense Python is an ideal language since it allows you to test
many algorithms in an incredibly short time: in other words, the time you 
would spend fighting with the compiler in other languages, in Python
can be used to improve the algorithm. 
However in some cases, there is little to do: for instance, in many
problems one has to run lots of loops, and Python loops are horribly
inefficients as compared to C loops. In this case the simplest possibility 
is to use Psyco. Psyco is a specialing Python compiler written by Armin
Rigo. It works for 386 based processors and allows Python to run loops at 
C speed. Installing Psyco requires $0.00 and ten minutes of your time:
nine minutes to find the program, download it, and install it; one
minute to understand how to use it.</p>
<p>The following script explains both the usage and the advantages of Psyco:</p>
<blockquote>
<pre class="literal-block">
#&lt;psyco1.py&gt;

import oopp,sys
try: 
    import psyco
except ImportError: 
    print &quot;Psyco is not installed, sorry.&quot;
else:
    n=1000000 # 1,000,000 loops

    without=oopp.loop_overhead(n) 
    print &quot;Without Psyco:&quot;,without

    psyco.bind(oopp.loop_overhead) #compile the empty_loop

    with=oopp.loop_overhead(n) 
    print &quot;With Psyco:&quot;,with

    print 'Speedup = %sx' % round(without/with,1)

#&lt;/psyco1.py&gt;
</pre>
</blockquote>
<p>The output is impressive:</p>
<blockquote>
<pre class="literal-block">
Without Psyco: 1.3
With Psyco: 0.02
Speedup = 65.0x
</pre>
</blockquote>
<p>Notice that repeating the test, you will obtain different speedups.
On my laptop, the speedup for an empty loop of 10,000,000 of
iteration is of the order of 70x, which is the same speed of a C loop, 
actually (I checked it). On my desktop, I have even found a speedup of
94x !</p>
<p>However, I must say that Psyco has some limitations. The problem is
the function call overhead. Psyco enhances the overhead and in some
programs it can even <em>worsen</em> the performance (this is way you should
<em>never</em> use the <tt class="literal"><span class="pre">psyco.jit()</span></tt> function that wraps all the functions of
your program: you should only wrap the bottleneck loops). Generally speaking, 
you should expect a much more modest improvement, a factor of 2 or 3
is what I obtain usually in my programs.</p>
<p>Look at this second example, which essentially measure the function 
call overhead by invoking the <tt class="literal"><span class="pre">do_nothing</span></tt> function:</p>
<blockquote>
<pre class="literal-block">
#&lt;psyco2.py&gt;

import oopp
try: 
    import psyco
except ImportError:
    print &quot;Psyco is not installed, sorry.&quot;
else:
    n=10000 # 10,000 loops
 
    def do_nothing_loop():
        for i in xrange(n): oopp.do_nothing()

    print &quot;Without Psyco:\n&quot;
    oopp.with_timer(do_nothing_loop,n=5)() #50,000 times

    without=do_nothing_loop.CPUtime

    psyco.bind(do_nothing_loop) 
    print &quot;With Psyco:\n&quot;
    oopp.with_timer(do_nothing_loop,n=5)() #50,000 times

    with=do_nothing_loop.CPUtime

    print 'Speedup = %sx' % round(without/with,1)

#&lt;/psyco2.py&gt;
</pre>
</blockquote>
<p>The output is less incredible:</p>
<blockquote>
<pre class="literal-block">
Without Psyco:
Executing do_nothing_loop ... Real time: 138.2 ms  CPU time: 130.0 ms
With Psyco:
Executing do_nothing_loop ... Real time: 70.0 ms  CPU time: 68.0 ms
Speedup = 1.9x
</pre>
</blockquote>
<p>However, this is still impressive, if you think that you can double 
the speed of your program by adding <em>a line</em> of code! Moreover this
example is not fair since Psyco cannot improve very much the performance 
for loops invoking functions with a variable number of arguments. On the
other hand, it can do quite a lot for loops invoking functions with 
a fixed number of arguments. I have checked that you can easily reach 
speedups of 20x (!). The only disadvantage is that a program invoking
Psyco takes much more memory, than a normal Python program, but this
is not a problem for most applications in nowadays computers. 
Therefore, often Psyco
can save you the effort of going trough a C extension. In some cases,
however, there is no hope: I leave as an exercise for the reader
to check (at least the version 0.4.1 I am using now) is unable to
improve the performance on the Mandelbrot set example. This proves
that in the case bad code, there is no point in using a compiler:
you have to improve the algorithm first !</p>
<p>By the way, if you really want to go trough a C extension with a minimal
departure from Python, you can use Pyrex by Greg Ewing. A Pyrex program
is essentially a Python program with variable declarations that is
automatically converted to C code. Alternatively, you can inline
C functions is Python with <tt class="literal"><span class="pre">weave</span></tt> of ... 
Finally, if you want to access C/C++ libraries, there tools
like Swig, Booster and others.</p>
</div>
<div class="section" id="tracing-functions">
<h2><a class="toc-backref" href="#id72" name="tracing-functions">Tracing functions</a></h2>
<p>Typically, a script contains many functions that call themselves each
other when some conditions are satisfied. Also, typically during
debugging things do not work the way we would like and it is not
clear which functions are called, in which order they are called,
and which parameters are passed. The best way to know all these
informations, is to trace the functions in our script, and to write
all the relevant informations in a log file. In order to keep the
distinction between the traced functions and the original one, it
is convenient to collect all the wrapped functions in a separate dictionary. 
The tracing of a single function can be done with a closure 
like this:</p>
<pre class="literal-block">
#&lt;oopp.py&gt;

def with_tracer(function,namespace='__main__',output=sys.stdout, indent=[0]):
    &quot;&quot;&quot;Closure returning traced functions. It is typically invoked
    trough an auxiliary function fixing the parameters of with_tracer.&quot;&quot;&quot;
    def _(*args,**kw):
        name=function.__name__
        i=' '*indent[0]; indent[0]+=4 # increases indentation
        output.write(&quot;%s[%s] Calling '%s' with arguments\n&quot; % 
                                                 (i,namespace,name))
        output.write(&quot;%s %s ...\n&quot; % (i,str(args)+str(kw)))
        res=function(*args,**kw)
        output.write(&quot;%s[%s.%s] called with result: %s\n&quot;
                         % (i,namespace,name,str(res)))
        indent[0]-=4 # restores indentation
        return res
    return _ # the traced function

#&lt;/oopp.py&gt;
</pre>
<p>Here is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import with_tracer
&gt;&gt;&gt; def fact(n): # factorial function
...     if n==1: return 1
...     else: return n*fact(n-1)
&gt;&gt;&gt; fact=with_tracer(fact)
&gt;&gt;&gt; fact(3)
[__main__] Calling 'fact' with arguments
 (3,){} ...
    [__main__] Calling 'fact' with arguments
     (2,){} ...
        [__main__] Calling 'fact' with arguments
         (1,){} ...
        [__main__.fact] called with result: 1
    [__main__.fact] called with result: 2
[__main__.fact] called with result: 6
6
</pre>
</blockquote>
<p>The logic behind <tt class="literal"><span class="pre">with_tracer</span></tt> should be clear; the only trick is the
usage of a default list as a way to store a global indentation parameter.
Since <tt class="literal"><span class="pre">indent</span></tt> is mutable, the value of <tt class="literal"><span class="pre">indent[0]</span></tt> changes at any
recursive call of the traced function, resulting in a nested display.</p>
<p>Typically, one wants to trace all the functions in a given module; 
this can be done trough the following function:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

from types import *

isfunction=lambda f: isinstance(f,(FunctionType,BuiltinFunctionType))

def wrapfunctions(obj,wrapper,err=None,**options):
    &quot;Traces the callable objects in an object with a dictionary&quot;
    namespace=options.get('namespace',getattr(obj,'__name__',''))
    output=options.get('output',sys.stdout)
    dic=dict([(k,wrapper(v,namespace,output)) 
              for k,v in attributes(obj).items() if isfunction(v)])
    customize(obj,err,**dic)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Notice that 'wrapfunctions' accepts as first argument an object with 
a <tt class="literal"><span class="pre">__dict__</span></tt> attribute (such as a module or a class) or with some 
explicit attributes (such as a simple object) and modifies it. One can 
trace a module as in this example:</p>
<blockquote>
<pre class="literal-block">
#&lt;tracemodule.py&gt;

import oopp,random

oopp.wrapfunctions(random,oopp.with_tracer) 

random.random()

#&lt;/tracemodule.py&gt;
</pre>
</blockquote>
<p>with output</p>
<blockquote>
<pre class="literal-block">
[random] Calling 'random' with arguments
(){} ...
-&gt; 'random.random' called with result: 0.175450439202
</pre>
</blockquote>
<p>The beauty of the present approach is its generality: 'wrap' can be
used to add any kind of capabilities to a pre-existing module.
For instance, we could time the functions in a module, with the
purpose of looking at the bottlenecks. To this aim, it is enough
to use a 'timer' nested closure:</p>
<p>An example of calling is  <tt class="literal"><span class="pre">wrapfunction(obj,timer,iterations=1)</span></tt>.</p>
<p>We may also compose our closures; for instance one could define a 
<tt class="literal"><span class="pre">with_timer_and_tracer</span></tt> closure:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; with_timer_and_tracer=lambda f: with_timer(with_tracer(f))
</pre>
</blockquote>
<p>It should be noticed that Python comes with a standard profiler
(in my system it is located in <tt class="literal"><span class="pre">/usr/local/lib/python2.2/profile.py</span></tt>)
that allows to profile a script or a module (try 
python /usr/local/lib/python2.2/profile.py oopp.py)</p>
<p>or</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import profile; help(profile)
</pre>
</blockquote>
<p>and see the on-line documentation.</p>
</div>
<div class="section" id="tracing-objects">
<h2><a class="toc-backref" href="#id73" name="tracing-objects">Tracing objects</a></h2>
<p>In this section, I will give a more sophisticated example, in which 
one can easily understand why the Python ability of changing methods and 
attributes during run-time, is so useful.
As a preparation to the real example, let me
first introduce an utility routine that allows the user
to add tracing capabilities to a given object.
Needless to say, this feature can be invaluable during debugging, or in trying
to understand the behaviour of a program written by others.</p>
<p>This routine is a little complex and needs some explanation.</p>
<ol class="arabic simple">
<li>The routine looks in the attributes of the object and try to access them.</li>
<li>If the access is possible, the routines looks for methods (methods
are recognized trough the <tt class="literal"><span class="pre">inspect.isroutine</span></tt> function in the
standard library) and ignores regular attributes;</li>
<li>The routine try to override the original methods with improved ones,
that possess tracing capabilities;</li>
<li>the traced method is obtained with the wrapping trick discussed before.</li>
</ol>
<p>I give  now the real life example that I have anticipated before.
Improvements and elaborations of this example can be useful to the
professional programmer, too. Suppose you have an XML text you want
to parse. Python provides excellent support for this kind of operation
and various standard modules. One of the most common is the <tt class="literal"><span class="pre">expat</span></tt>
module (see the standard library documentation for more).</p>
<p>If you are just starting using the module, it is certainly useful
to have a way of tracing its behaviour; this is especially true if
you you find some unexpected error during the parsing of a document
(and this may happens even if you are an experience programmer ;-).</p>
<p>The tracing routine just defined can be used to trace the parser, as
it is exemplified in the following short script:</p>
<blockquote>
<pre class="literal-block">
#&lt;expat.py&gt;

import oopp, xml.parsers.expat, sys

# text to be parsed
text_xml=&quot;&quot;&quot;\
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;parent id=&quot;dad&quot;&gt;
&lt;child name=&quot;kid&quot;&gt;Text goes here&lt;/child&gt;
&lt;/parent&gt;&quot;&quot;&quot;

# a few do nothing functions
def start(*args): pass
def end(*args): pass
def handler(*args): pass

# a parser object
p = xml.parsers.expat.ParserCreate()

p.StartElementHandler = start
p.EndElementHandler = end
p.CharacterDataHandler = handler

#adds tracing capabilities to p
oopp.wrapfunctions(p,oopp.with_tracer, err=sys.stdout)

p.Parse(text_xml)

#&lt;/expat.py&gt;
</pre>
</blockquote>
<p>The output is:</p>
<blockquote>
<pre class="literal-block">
Error: SetBase cannot be set
Error: Parse cannot be set
Error: ParseFile cannot be set
Error: GetBase cannot be set
Error: SetParamEntityParsing cannot be set
Error: ExternalEntityParserCreate cannot be set
Error: GetInputContext cannot be set
[] Calling 'start' with arguments
 (u'parent', {u'id': u'dad'}){} ...
[.start] called with result: None
[] Calling 'handler' with arguments
 (u'\n',){} ...
[.handler] called with result: None
[] Calling 'start' with arguments
 (u'child', {u'name': u'kid'}){} ...
[.start] called with result: None
[] Calling 'handler' with arguments
 (u'Text goes here',){} ...
[.handler] called with result: None
[] Calling 'end' with arguments
 (u'child',){} ...
[.end] called with result: None
[] Calling 'handler' with arguments
 (u'\n',){} ...
[.handler] called with result: None
[] Calling 'end' with arguments
 (u'parent',){} ...
[.end] called with result: None
</pre>
</blockquote>
<p>This is a case where certain methods cannot be managed with 
<tt class="literal"><span class="pre">getattr/setattr</span></tt>, because they are internally coded in C: this
explain the error messages at the beginning. I leave as an exercise 
for the reader to understand the rest ;-)</p>
</div>
<div class="section" id="inspecting-functions">
<h2><a class="toc-backref" href="#id74" name="inspecting-functions">Inspecting functions</a></h2>
<p>Python wonderful introspection features are really impressive when applied
to functions. It is possible to extract a big deal of informations
from a Python function, by looking at its associated <em>code object</em>.
For instance, let me consider  my, <tt class="literal"><span class="pre">do_nothing</span></tt> function: its associated
code object can be extracted from the <tt class="literal"><span class="pre">func_code</span></tt> attribute:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; co=do_nothing.func_code # extracts the code object
&gt;&gt;&gt; co
&lt;code object do_nothing at 0x402c5d20, file &quot;oopp.py&quot;, line 48&gt;
&gt;&gt;&gt; type(co)
&lt;type 'code'&gt;
</pre>
</blockquote>
<p>The code object is far being trivial: the docstring says it all:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print type(co).__doc__
code(argcount, nlocals, stacksize, flags, codestring, constants, names,
      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])
Create a code object.  Not for the faint of heart.
</pre>
</blockquote>
<p>In the case of my <tt class="literal"><span class="pre">do_nothing</span></tt> function, the code object 
possesses the following attributes:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print pretty(attributes(co))
co_argcount = 0
co_cellvars = ()
co_code = dS
co_consts = (None,)
co_filename = oopp.py
co_firstlineno = 48
co_flags = 15
co_freevars = ()
co_lnotab =
co_name = do_nothing
co_names = ()
co_nlocals = 2
co_stacksize = 1
co_varnames = ('args', 'kw')
</pre>
</blockquote>
<p>Some of these arguments are pretty technical and implementation dependent;
however, some of these are pretty clear and useful:</p>
<blockquote>
<ul class="simple">
<li>co_argcount is the total number of arguments</li>
<li>co_filename is the name of the file where the function is defined</li>
<li>co_firstlineno is the line number where the function is defined</li>
<li>co_name is the name of the function</li>
<li>co_varnames are the names</li>
</ul>
</blockquote>
<p>The programmer that it is not a &quot;faint of heart&quot; can study
the built-in documentation on code objects; s/he should try</p>
<blockquote>
<pre class="literal-block">
for k,v in attributes(co).iteritems(): print k,':',v.__doc__,'\n'
</pre>
<p># does not work now !!</p>
<pre class="literal-block">
add=[lambda x,i=i: x+i for i in range(10)]

&gt;&gt;&gt; def f(y):
...    return lambda x: x+y
...
&gt;&gt;&gt; f(1).func_closure #closure cell object
(&lt;cell at 0x402b56bc: int object at 0x811d6c8&gt;,)
</pre>
</blockquote>
<p>func.defaults, closure, etc.</p>
<p>#how to extract (non-default) arguments as help does.</p>
<p>print (lambda:None).func_code.co_filename</p>
<p>One cannot change the name of a function:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def f(): pass
...
&gt;&gt;&gt; f.__name__='ciao' # error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: readonly attribute
</pre>
</blockquote>
<p>However, one can create a copy with a different name:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def copyfunc(f,newname=None): # works under Python 2.3
    if newname is None: newname=f.func_name # same name
    return FunctionType(f.func_code, globals(), newname, 
                         f.func_defaults, f.func_closure)

#&lt;/oopp.py&gt;

&gt;&gt;&gt; copyfunc(f,newname='f2')
&lt;function f2 at 0x403e233c&gt;
</pre>
</blockquote>
<p>Notice that the <tt class="literal"><span class="pre">copy</span></tt> module would not do the job:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import copy
&gt;&gt;&gt; copy.copy(f) # error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;/usr/local/lib/python2.3/copy.py&quot;, line 84, in copy
    y = _reconstruct(x, reductor(), 0)
  File &quot;/usr/local/lib/python2.3/copy_reg.py&quot;, line 57, in _reduce
    raise TypeError, &quot;can't pickle %s objects&quot; % base.__name__
TypeError: can't pickle function objects
</pre>
</blockquote>
</div>
</div>
<div class="section" id="the-beauty-of-objects">
<h1><a class="toc-backref" href="#id75" name="the-beauty-of-objects">THE BEAUTY OF OBJECTS</a></h1>
<p>In this chapter I will show how to define generic objects in Python, and
how to manipulate them.</p>
<div class="section" id="user-defined-objects">
<h2><a class="toc-backref" href="#id76" name="user-defined-objects">User defined objects</a></h2>
<p>In Python, one cannot directly modify methods and attributes of built-in 
types, since this would be a potentially frightening source of bugs. 
Imagine for instance of changing the sort method of a list and invoking an 
external module expecting the standard sort: all kind of hideous outcome 
could happen.</p>
<p>Nevertheless, in Python, as in all OOP languages, the user can define 
her own kind of objects, customized to satisfy her needs. In order to
define a new object, the user must define the class of the objects she 
needs. The simplest possible class is a do-nothing class:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Object(object):
    &quot;A convenient Object class&quot;

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Elements of the <tt class="literal"><span class="pre">Object</span></tt> class can be created (instantiated) quite
simply:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Object
&gt;&gt;&gt; obj1=Object()
&gt;&gt;&gt; obj1
&lt;oopp.Object object at 0x81580ec&gt;
&gt;&gt;&gt; obj2=Object()
obj2
&lt;object.Object object at 0x8156704&gt;
</pre>
</blockquote>
<p>Notice that the hexadecimal number 0x81580ec is nothing else that the
unique object reference to <tt class="literal"><span class="pre">obj1</span></tt></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; hex(id(obj1))
 '0x81580ec'
</pre>
</blockquote>
<p>whereas 0x8156704 is the object reference of <tt class="literal"><span class="pre">obj2</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; hex(id(obj2))
'0x8156704'
</pre>
</blockquote>
<p>However, at this point <tt class="literal"><span class="pre">obj1</span></tt> and <tt class="literal"><span class="pre">obj2</span></tt> are generic 
doing nothing objects . Nevertheless, they have 
at least an useful attribute, the class docstring:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; obj1.__doc__ #obj1 docstring
'A convenient Object class'
&gt;&gt;&gt; obj2.__doc__ # obj2 docstring: it's the same
'A convenient Object class'
</pre>
</blockquote>
<p>Notice that the docstring is associate to the class and therefore all
the instances share the same docstring, unless one explicitly assigns
a different docstring to some instance. <tt class="literal"><span class="pre">__doc__</span></tt>
is a class attribute (or a static attribute for readers familiar with the
C++/Java terminology) and the expression is actually syntactic sugar for</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Object(object): # with explicit assignement to __doc__
...    __doc__ = &quot;A convenient Object class&quot;
</pre>
</blockquote>
<p>Since instances of 'Object' can be modified, I can transform them in
anything I want. For instance, I can create a simple clock:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; myclock=Object()
&gt;&gt;&gt; myclock
&lt;__main__.Object object at 0x8124614&gt;
</pre>
</blockquote>
<p>A minimal clock should at least print the current time 
on the system. This is given by the <tt class="literal"><span class="pre">get_time</span></tt> function
we defined in the first chapter. We may &quot;attach&quot; that function 
to our clock as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import oopp
&gt;&gt;&gt; myclock.get_time=oopp.get_time
&gt;&gt;&gt; myclock.get_time # this is a function, not a method
&lt;function get_time at 0x815c40c&gt;
</pre>
</blockquote>
<p>In other words, we have converted the <tt class="literal"><span class="pre">oopp.get_time</span></tt> function to a
<tt class="literal"><span class="pre">get_time</span></tt> function of the object <tt class="literal"><span class="pre">myclock</span></tt>. The procedure works</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; myclock.get_time()
'15:04:57'
</pre>
</blockquote>
<p>but has a disadvantage: if we instantiate another
clock</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Object
&gt;&gt;&gt; otherclock=Object()
</pre>
</blockquote>
<p>the other clock will <tt class="literal"><span class="pre">not</span></tt> have a get_time method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; otherclock.get_time() #first attempt; error
AttributeError: 'Object' object has no attribute 'get_time'
</pre>
</blockquote>
<p>Notice instead that the docstring is a <em>class attribute</em>, i.e. it
is defined both for the class and <em>all instances</em> of the class,
therefore even for <tt class="literal"><span class="pre">otherclock</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Object.__doc__
'A convenient Object class' 
&gt;&gt;&gt; otherclock.__doc__
'A convenient Object class'
</pre>
</blockquote>
<p>We would like to convert the <tt class="literal"><span class="pre">get_time</span></tt> function to a 
<tt class="literal"><span class="pre">get_time</span></tt> method for the <em>entire</em> class 'Object', i.e. for all its
instances. Naively, one would be tempted to write the following:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Object.get_time=oopp.get_time
</pre>
</blockquote>
<p>However this would not work:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; otherclock.get_time() #second attempt; still error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: oopp.get_time() takes no arguments (1 given)
</pre>
</blockquote>
<p>This error message is something that all Python beginners encounter
(and sometimes even non-beginners ;-). The solution is to introduce
an additional argument:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Object.get_time=lambda self : oopp.get_time()
&gt;&gt;&gt; otherclock.get_time # this is method now, not a function
&lt;bound method Object.&lt;lambda&gt; of &lt;__main__.Object object at 0x815881c&gt;&gt;
&gt;&gt;&gt; otherclock.get_time() #third attempt
'15:28:41'
</pre>
</blockquote>
<p>Why this works ? The explanation is the following:
when Python encounters an expression of the form
<tt class="literal"><span class="pre">objectname.methodname()</span></tt> it looks if there is a already a method 
<em>attached</em> to the object:</p>
<blockquote>
<ol class="loweralpha simple">
<li>if yes it invokes it with no arguments 
(this is why our first example worked);</li>
<li>if not it looks at the class of the object; if there is a method 
bound to the class it invokes that method <em>by passing the 
object as first argument</em>.</li>
</ol>
</blockquote>
<p>When we invoked <tt class="literal"><span class="pre">otherclock.get_time()</span></tt> in our second attempt, Python
found that the function <tt class="literal"><span class="pre">get_time</span></tt> was defined at the class level, 
and sent it the <tt class="literal"><span class="pre">otherclock</span></tt> object as first argument: however <tt class="literal"><span class="pre">get_time</span></tt> 
was bind to <tt class="literal"><span class="pre">func_get_time</span></tt>, which is function with <em>no</em> arguments: whence
the error message. The third attempt worked since, thanks to the 
lambda function trick, the <tt class="literal"><span class="pre">get_time</span></tt> function has been converted to
a function accepting a first argument.</p>
<p>Therefore that's the rule: in Python, one can define methods 
at the class level, provided one explitely introduces a first argument
containing the object on which the method is invoked.</p>
<p>This first argument is traditionally called <tt class="literal"><span class="pre">self</span></tt>; the name 'self' is not
enforced, one could use any other valid Python identifier, however the
convention is so widespread that practically everybody uses it;
pychecker will even raise a warning in the case you don't follow the
convention.</p>
<p>I have just shown one the most interesting features of Python, its
<em>dynamicity</em>: you can create the class first and add methods to it later.
That logic cannot be followed in typical compiled language as C++. On the
other hand, one can also define methods in a static, more traditional way:</p>
<blockquote>
<pre class="literal-block">
#&lt;clock1.py&gt;

&quot;Shows how to define methods inside the class (statically)&quot;

import oopp

class Clock(object):
    'Clock class; version 0.1'
    def get_time(self): # method defined inside the class
        return oopp.get_time()

myclock=Clock() #creates a Clock instance
print myclock.get_time() # print the current time

#&lt;/clock1.py&gt;
</pre>
</blockquote>
<p>In this case we have defined the <tt class="literal"><span class="pre">get_time</span></tt> method inside the class as a
normal function with an explicit first argument called self; this is
entirely equivalent to the use of a lambda function.</p>
<p>The syntax <tt class="literal"><span class="pre">myclock.get_time()</span></tt> is actually syntactic sugar for
<tt class="literal"><span class="pre">Clock.get_time(myclock)</span></tt>.</p>
<p>In this second form, it is clear the <tt class="literal"><span class="pre">get_time</span></tt> is really &quot;attached&quot; to the
class, not to the instance.</p>
</div>
<div class="section" id="objects-have-static-methods-and-classmethods">
<h2><a class="toc-backref" href="#id77" name="objects-have-static-methods-and-classmethods">Objects have static methods and classmethods</a></h2>
<blockquote>
<pre class="line-block">
<em>There should be one--and preferably only one--obvious way to do it</em>
-- Tim Peters, <em>The Zen of Python</em>.
</pre>
</blockquote>
<p>For any rule, there is an exception, and despite the Python's motto    
there are many ways to define methods in classes. The way I presented
before was the obvious one before the Python 2.2 revolution; however, 
nowadays there is another possibility that, even if less obvious, has the 
advantage of some elegance (and it is also slightly more efficient too, even if
efficiency if never a primary concern for a Python programmer).
We see that the first argument in the <tt class="literal"><span class="pre">get_time</span></tt> method is useless,
since the time is computed from the <tt class="literal"><span class="pre">time.asctime()</span></tt> function which
does not require any information about the object that is calling
it. This waste is ugly, and since according to the Zen of Python</p>
<blockquote>
<em>Beautiful is better than ugly.</em></blockquote>
<p>we should look for another way. The solution is to use a <em>static method</em>:
when a static method is invoked, the calling object is <em>not</em> implicitly passed
as first argument. Therefore we may use a normal function with no additional
first argument to define the <tt class="literal"><span class="pre">get_time</span></tt> method:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Clock(object):
    'Clock with a staticmethod'
    get_time=staticmethod(get_time)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here is how it works:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Clock
&gt;&gt;&gt; Clock().get_time() # get_time is bound both to instances
'10:34:23'
&gt;&gt;&gt; Clock.get_time() # and to the class
'10:34:26'
</pre>
</blockquote>
<p>The staticmethod idiom converts the lambda function to a
static method of the class 'Clock'. Notice that one can avoid the
lambda expression and use the (arguably more Pythonic) idiom</p>
<blockquote>
<pre class="literal-block">
def get_time()
    return oopp.get_time()
get_time=staticmethod(oopp.get_time)
</pre>
</blockquote>
<p>as the documentation suggests:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print  staticmethod.__doc__
staticmethod(function) -&gt; method
Convert a function to be a static method.
A static method does not receive an implicit first argument.
To declare a static method, use this idiom:
   class C:
       def f(arg1, arg2, ...): ...
       f = staticmethod(f)
It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
Static methods in Python are similar to those found in Java or C++.
For a more advanced concept, see the classmethod builtin.
</pre>
</blockquote>
<p>At the present the notation for static methods is still rather ugly,
but it is expected to improve in future versions of Python (probably
in Python 2.4). Documentation for static methods can
be found in Guido's essay and in the PEP.. : however this is intended for
developers.</p>
<p>As the docstring says, static methods are also &quot;attached&quot; to the
class and may be called with the syntax <tt class="literal"><span class="pre">Clock.get_time()</span></tt>.</p>
<p>A similar remark applies for the so called <em>classmethods</em>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print classmethod.__doc__
classmethod(function) -&gt; method
Convert a function to be a class method.
A class method receives the class as implicit first argument,
just like an instance method receives the instance.
To declare a class method, use this idiom:
class C:
    def f(cls, arg1, arg2, ...): ...
    f = classmethod(f)
It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
If a class method is called for a derived class, the derived class
object is passed as the implied first argument.
Class methods are different than C++ or Java static methods.
If you want those, see the staticmethod builtin.
</pre>
</blockquote>
<p>#When a regular method is invoked, a reference to the calling object is 
#implicitely passed as first argument; instead, when a static method is 
#invoked, no reference to the calling object is passed.</p>
<p>As the docstring says, classmethods are convenient when one wants to pass 
to a method the calling <em>class</em>, not the calling object. Here there is an 
example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Clock(object): pass
&gt;&gt;&gt; Clock.name=classmethod(lambda cls: cls.__name__)
&gt;&gt;&gt; Clock.name() # called by the class
'Clock'
&gt;&gt;&gt; Clock().name() # called by an instance
'Clock'
</pre>
</blockquote>
<p>Notice that classmethods (and staticmethods too) 
can only be attached to classes, not to objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Clock(object): pass
&gt;&gt;&gt; c=Clock()
&gt;&gt;&gt; c.name=classmethod(lambda cls: cls.__name__) 
&gt;&gt;&gt; c.name() #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: 'classmethod' object is not callable
</pre>
</blockquote>
<p>gives a TypeError. The reason is that classmethods and staticmethods 
are implemented 
trough <em>attribute descriptors</em>. This concept will be discussed in detail in a 
forthcoming in chapter 6.</p>
<p>Notice that classmethods are not proving any fundamental feature, since
one could very well use a normal method and retrieve the class with 
<tt class="literal"><span class="pre">self.__class__</span></tt> as we did in the first chapter. 
Therefore, we could live without (actually, I think they are a non-essential
complication to the language).
Nevertheless, now that we have them, we can use them, since
they come handy in various circumstances, as we will see in the following.</p>
</div>
<div class="section" id="objects-have-their-privacy">
<h2><a class="toc-backref" href="#id78" name="objects-have-their-privacy">Objects have their privacy</a></h2>
<p>In some situations, it is convenient to give to the developer
some information that should be hided to the final user. To this
aim Python uses private names (i.e. names starting with a single
underscore) and private/protected attributes (i.e. attributes starting with
a double underscore).</p>
<p>Consider for instance the following script:</p>
<blockquote>
<pre class="literal-block">
#&lt;privacy.py&gt;

import time

class Clock(object):
    __secret=&quot;This Clock is quite stupid.&quot;

myclock=Clock()
try: print myclock.__secret
except Exception,e: print &quot;AttributeError:&quot;,e

#&lt;/privacy.py&gt;
</pre>
</blockquote>
<p>The output of this script is</p>
<blockquote>
<pre class="literal-block">
AttributeError: 'Clock' object has no attribute '__secret'
</pre>
</blockquote>
<p>Therefore, even if the Clock object <em>does</em> have a <tt class="literal"><span class="pre">__secret</span></tt> attribute, 
the user cannot access it ! In this way she cannot discover that
actually &quot;This Clock is quite stupid.&quot;</p>
<p>In other programming languages, attributes like <tt class="literal"><span class="pre">__secret</span></tt> are
called &quot;private&quot; attributes. However, in Python private attributes
are not really private and their secrets can be accessed with very
little effort.</p>
<p>First of all, we may notice that <tt class="literal"><span class="pre">myclock</span></tt> really contains a secret
by using the builtin function <tt class="literal"><span class="pre">dir()</span></tt>:</p>
<blockquote>
<pre class="literal-block">
dir(myclock)
['_Clock__secret', '__class__', '__delattr__', '__dict__', '__doc__', 
 '__getattribute__', '__hash__', '__init__', '__module__', '__new__', 
 '__reduce__', '__repr__', '__setattr__', '__str__', '__weakref__']
</pre>
</blockquote>
<p>We see that the first attribute of myclock is '_Clock__secret``, 
which we may access directly:</p>
<blockquote>
<pre class="literal-block">
print myclock._Clock__secret
This clock is quite stupid.
</pre>
</blockquote>
<p>We see here the secret of private variables in Python: the <em>name mangling</em>.
When Python sees a name starting with two underscores (and not ending
with two underscores, otherwise it would be interpreted as a special
attribute), internally it manage it as <tt class="literal"><span class="pre">_Classname__privatename</span></tt>.
Notice that if 'Classname' begins with underscores, the leading underscores
are stripped in such a way to guarantee that the private name starts with
only <em>one</em> underscore. For instance, the '__secret' private attribute 
of classes such as 'Clock', '_Clock', '__Clock', '___Clock', etc. is
mangled to '_Clock__secret'.</p>
<p>Private names in Python are <em>not</em> intended to keep secrets: they
have other uses.</p>
<ol class="arabic simple">
<li>On one hand, private names are a suggestion to the developer. 
When the Python programmer sees a name starting with one or two 
underscores in a program written by others, she understands
that name should not be of concern for the final user, but it 
only concerns the internal implementation.</li>
<li>On the other hand, private names are quite useful in class
inheritance, since they provides safety with respect to the overriding
operation. This point we will discussed in the next chapter.</li>
<li>Names starting with one (or more) underscores are not imported by the 
statement <tt class="literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></tt></li>
</ol>
<p>Remark: it makes no sense to define names with double underscores
outside classes, since the name mangling doesn't work in this case.
Let me show an example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Clock(object): __secret=&quot;This Clock is quite stupid&quot;
&gt;&gt;&gt; def tellsecret(self): return  self.__secret
&gt;&gt;&gt; Clock.tellsecret=tellsecret
&gt;&gt;&gt; Clock().tellsecret() #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;&lt;stdin&gt;&quot;, line 2, in tellsecret
AttributeError: 'Clock' object has no attribute '__secret'
</pre>
</blockquote>
<p>The explanation is that since <tt class="literal"><span class="pre">tellsecret()</span></tt> is defined outside the class,
<tt class="literal"><span class="pre">__secret</span></tt> is not expanded to <tt class="literal"><span class="pre">_Clock__secret</span></tt> and therefore cannot be
retrieved, whereas</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Clock(object): 
...     __secret=&quot;This Clock is quite stupid&quot;
...     def tellsecret(self): return self.__secret
&gt;&gt;&gt; Clock().tellsecret()
This Clock is quite stupid
</pre>
</blockquote>
<p>will work. In other words, private variables are attached to classes,
not objects.</p>
</div>
<div class="section" id="objects-have-properties">
<h2><a class="toc-backref" href="#id79" name="objects-have-properties">Objects have properties</a></h2>
<p>In the previous section we have shown that private variables are of
little use for keeping secrets: if a developer really wants to restrict 
the access to some methods or attributes, she has to resort to
<em>properties</em>.</p>
<p>Let me show an example:</p>
<blockquote>
<pre class="literal-block">
#&lt;secret.py&gt;

import oopp

class Clock(object): 
    'Clock class with a secret'
  
    you_know_the_pw=False #default
                 
    def give_pw(self,pw):
        &quot;&quot;&quot;Check if your know the password. For security, one should crypt
        the password.&quot;&quot;&quot;
        self.you_know_the_pw=(pw==&quot;xyz&quot;)
      
    def get_secret(self):
        if self.you_know_the_pw:
            return &quot;This clock doesn't work.&quot;
        else:
            return &quot;You must give the right password to access 'secret'&quot;
      
    secret=property(get_secret)

c=Clock()
print c.secret # =&gt; You must give the right password to access 'secret'
c.give_pw('xyz') # gives the right password
print c.secret # =&gt; This clock doesn't work.
print Clock.secret # =&gt; &lt;property object at 0x814c1b4&gt;

#&lt;/secret.py&gt;
</pre>
</blockquote>
<p>In this script, one wants to restrict the access to the attribute
'secret', which can be accessed only is the user provide the
correct password. Obviously, this example is not very secure,
since I have hard coded the password 'xyz' in the source code,
which is easily accessible. In reality, one should crypt the
password a perform a more sophisticated test than the trivial
check <tt class="literal"><span class="pre">(pw==&quot;xyz&quot;)</span></tt>; anyway, the example is only intended to
shown the uses of properties, not to be really secure.</p>
<p>The key action is performed by the descriptor class <tt class="literal"><span class="pre">property</span></tt> that
converts the function <tt class="literal"><span class="pre">get_secret</span></tt> in a property object. Additional
informations on the usage of <tt class="literal"><span class="pre">property</span></tt> can be obtained from the
docstring:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print property.__doc__
property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute
fget is a function to be used for getting an attribute value, and likewise
fset is a function for setting, and fdel a function for del'ing, an
attribute.  Typical use is to define a managed attribute x:
class C(object):
    def getx(self): return self.__x
    def setx(self, value): self.__x = value
    def delx(self): del self.__x
    x = property(getx, setx, delx, &quot;I'm the 'x' property.&quot;)
</pre>
</blockquote>
<p>Properties are another example of attribute descriptors.</p>
</div>
<div class="section" id="objects-have-special-methods">
<h2><a class="toc-backref" href="#id80" name="objects-have-special-methods">Objects have special methods</a></h2>
<p>From the beginning, we stressed that objects have special attributes that
may turn handy, as for instance the docstring <tt class="literal"><span class="pre">__doc__</span></tt> and the class
name attribute <tt class="literal"><span class="pre">__class__</span></tt>. They have special methods, too.</p>
<p>With little doubt, the most useful special method is the <tt class="literal"><span class="pre">__init__</span></tt>
method, that <em>initializes</em> an object right after its creation. <tt class="literal"><span class="pre">__init__</span></tt>
is typically used to pass parameters to <em>object factories</em>. Let me an
example with geometric figures:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;
  
class GeometricFigure(object): #an example of object factory
    &quot;&quot;&quot;This class allows to define geometric figures according to their
    equation in the cartesian plane. It will be extended later.&quot;&quot;&quot;
    def __init__(self,equation,**parameters):
        &quot;Specify the cartesian equation of the object and its parameters&quot;
        self.eq=equation
        self.par=parameters
        for k,v in self.par.items(): #replaces the parameters in the equation
            self.eq=self.eq.replace(k,str(v))
        self.contains=eval('lambda x,y : '+self.eq) 
        # dynamically creates the function 'contains'

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here it is how it works:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; disk=GeometricFigure('(x-x0)**2+(y-y0)**2 &lt;= r**2', x0=0,y0=0,r=5)
&gt;&gt;&gt; # creates a disk of radius 5 centered in the origing
&gt;&gt;&gt; disk.contains(1,2) #asks if the point (1,2) is inside the disk
True
&gt;&gt;&gt; disk.contains(4,4) #asks if the point (4,4) is inside the disk
False
</pre>
</blockquote>
<p>Let me continue the section on special methods with some some observations on
<tt class="literal"><span class="pre">__repr__</span></tt> and <tt class="literal"><span class="pre">__str__</span></tt>.Notice that  I
will not discuss all the subtleties; for a thought discussion, see the
thread &quot;Using __repr__ or __str__&quot; in c.l.p. (Google is your friend).
The following discussion applies to new style classes, old style classes 
are subtly different; moreover.</p>
<p>When one  writes</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; disk
&lt;oopp.GeometricFigure instance at 0x81b496c&gt;
</pre>
</blockquote>
<p>one obtains the <em>string representation</em> of the object. Actually, the previous
line is syntactic sugar for</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print repr(disk)
&lt;oopp.GeometricFigure instance at 0x81b496c&gt;
</pre>
</blockquote>
<p>or</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print disk.__repr__()
&lt;oopp.GeometricFigure instance at 0x81b496c&gt;
</pre>
</blockquote>
<p>The <tt class="literal"><span class="pre">repr</span></tt> function extracts the string representation from the
the special method <tt class="literal"><span class="pre">__repr__</span></tt>, which can be redefined in order to 
have objects pretty printed. Notice that <tt class="literal"><span class="pre">repr</span></tt> is conceptually
different from the <tt class="literal"><span class="pre">str</span></tt> function that controls the output of the <tt class="literal"><span class="pre">print</span></tt> 
statement. Actually, <tt class="literal"><span class="pre">print</span> <span class="pre">o</span></tt> is syntactic sugar for <tt class="literal"><span class="pre">print</span> <span class="pre">str(o)</span></tt>
which is sugar for <tt class="literal"><span class="pre">print</span> <span class="pre">o.__str__()</span></tt>.</p>
<p>If for instance we define</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class PrettyPrinted(object):
    formatstring='%s' # default
    def __str__(self):
        &quot;&quot;&quot;Returns the name of self in quotes, possibly formatted via 
        self.formatstring. If self has no name, returns the name 
        of its class in angular brackets.&quot;&quot;&quot; 
        try: #look if the selfect has a name 
           name=&quot;'%s'&quot; % self.__name__ 
        except AttributeError: #if not, use the name of its class
            name='&lt;%s&gt;' % type(self).__name__
        if hasattr(self,'formatstring'):
            return self.formatstring % name
        else: 
            return name

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>then we have</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import PrettyPrinted
&gt;&gt;&gt; o=PrettyPrinted() # o is an instance of PrettyPrinted
&gt;&gt;&gt; print o #invokes o.__str__() which in this case returns o.__class__.name
&lt;PrettyPrinted&gt;
</pre>
</blockquote>
<p>whereas</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; o # i.e. print repr(o)
&lt;oopp.PrettyPrinted object at 0x400a006c&gt;
</pre>
</blockquote>
<p>However, in most cases <tt class="literal"><span class="pre">__repr__</span></tt> and <tt class="literal"><span class="pre">__str__</span></tt> gives the same
output, since if <tt class="literal"><span class="pre">__str__</span></tt> is not explicitely defined it defaults
to <tt class="literal"><span class="pre">__repr__</span></tt>. Therefore, whereas modifying <tt class="literal"><span class="pre">__str__</span></tt> 
does not change <tt class="literal"><span class="pre">__repr__</span></tt>, modifying <tt class="literal"><span class="pre">__repr__</span></tt> changes <tt class="literal"><span class="pre">__str__</span></tt>,
if <tt class="literal"><span class="pre">__str__</span></tt> is not explicitely given:</p>
<blockquote>
<pre class="literal-block">
#&lt;fairytale1.py&gt;

&quot;__repr__ can also be a regular method, not a classmethod&quot;

class Frog(object):
    attributes=&quot;poor, small, ugly&quot;
    def __str__(self):
        return &quot;I am a &quot;+self.attributes+' '+self.__class__.__name__

class Prince(object):
    attributes='rich, tall, beautiful'
    def __str__(self):
        return &quot;I am a &quot;+self.attributes+' '+self.__class__.__name__

jack=Frog(); print repr(jack),jack
charles=Prince(); print repr(charles),charles  

#&lt;/fairytale1.py&gt;
</pre>
</blockquote>
<p>The output of this script is:</p>
<blockquote>
<pre class="literal-block">
&lt;Frog object at 0x81866ec&gt; I am a poor, small, ugly Frog
&lt;Prince object at 0x818670c&gt; I am a rich, tall, beautiful Prince
</pre>
</blockquote>
<p>for jack and charles respectively.</p>
<p><tt class="literal"><span class="pre">__str__</span></tt>  and <tt class="literal"><span class="pre">__repr__</span></tt> are also called by the formatting
operators &quot;%s&quot; and &quot;%r&quot;.</p>
<p>Notice that  i) <tt class="literal"><span class="pre">__str__</span></tt> can be most naturally
rewritten as a class method; ii) Python is magic:</p>
<blockquote>
<pre class="literal-block">
#&lt;fairytale2.py&gt;
  
&quot;&quot;&quot;Shows two things: 
    1) redefining __repr__ automatically changes the output of __str__
    2) the class of an object can be dinamically changed! &quot;&quot;&quot;

class Frog(object):
    attributes=&quot;poor, small, ugly&quot;
    def __repr__(cls):
        return &quot;I am a &quot;+cls.attributes+' '+cls.__name__
    __repr__=classmethod(__repr__)

class Prince(object):
    attributes='rich, tall, beautiful'
    def __repr__(cls):
        return &quot;I am a &quot;+cls.attributes+' '+cls.__name__
    __repr__=classmethod(__repr__)

def princess_kiss(frog):
      frog.__class__=Prince

jack=Frog()
princess_kiss(jack)
print jack # the same as repr(jack)

#&lt;/fairytale2.py&gt;
</pre>
</blockquote>
<p>Now the output for jack is &quot;I am a rich, tall, beautiful Prince&quot; !
In Python you may dynamically change the class of an object!!</p>
<p>Of course, this is a feature to use with care ;-)</p>
<p>There are many others special methods, such as __new__, __getattr__,
__setattr__, etc. They will be discussed in the next chapters, in
conjunction with inheritance.</p>
</div>
<div class="section" id="objects-can-be-called-added-subtracted">
<h2><a class="toc-backref" href="#id81" name="objects-can-be-called-added-subtracted">Objects can be called, added, subtracted, ...</a></h2>
<p>Python provides a nice generalization of functions, via the concept
of <em>callable objects</em>. A callable object is an object with a <tt class="literal"><span class="pre">__call__</span></tt>
special method. They can be used to define &quot;functions&quot; that remember
how many times they are invoked:</p>
<blockquote>
<pre class="literal-block">
#&lt;call.py&gt;

class MultiplyBy(object):
    def __init__(self,n):
        self.n=n
        self.counter=0
    def __call__(self,x):
        self.counter+=1
        return self.n*x

double=MultiplyBy(2)
res=double(double(3)) # res=12
print &quot;double is callable: %s&quot; % callable(double)
print &quot;You have called double %s times.&quot; % double.counter

#&lt;/call.py&gt;
</pre>
</blockquote>
<p>With output</p>
<blockquote>
<pre class="literal-block">
double is callable:  True
You have called double 2 times.
</pre>
</blockquote>
<p>The script also show that callable objects (including functions) 
can be recognized with the <tt class="literal"><span class="pre">callable</span></tt> built-in function.</p>
<p>Callable object solves elegantly the problem of having &quot;static&quot; variables
inside functions (cfr. with the 'double' example in chapter 2).
A class with a <tt class="literal"><span class="pre">__call__</span></tt> method can be used to generate an entire
set of customized &quot;functions&quot;. For this reason, callable objects are 
especially useful in the conjunction with object factories. Let me show 
an application to my factory of geometric figures:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Makeobj(object):
    &quot;&quot;&quot;A factory of object factories. Makeobj(cls) returns instances
     of cls&quot;&quot;&quot;
    def __init__(self,cls,*args):
        self.cls=cls
        self.args=args
    def __call__(self,**pars):
        return self.cls(*self.args,**pars)

#&lt;/oopp.py&gt;

#&lt;factory.py&gt;

from oopp import Makeobj,GeometricFigure

makedisk=Makeobj(GeometricFigure,'(x-x0)**2+(y-y0)**2&lt;r**2')
makesquare=Makeobj(GeometricFigure,'abs(x-x0)&lt;L and abs(y-y0)&lt;L')
disk=makedisk(x0=0,y0=0,r=10) # make a disk of radius 10
square=makesquare(x0=0,y0=0,L=20) # make a disk of side 10

print disk.contains(9,9) # =&gt; False
print square.contains(9,9) # =&gt; True
#etc.

#&lt;/factory.py&gt;
</pre>
</blockquote>
<p>This factory generates callable objects, such as <tt class="literal"><span class="pre">makedisk</span></tt> and
<tt class="literal"><span class="pre">makesquare</span></tt> that returns geometric objects. It gives a nicer interface
to the object factory provided by 'GeometricFigure'.</p>
<p>Notice that the use of the expression <tt class="literal"><span class="pre">disk.contains(9,9)</span></tt> in order to
know if the point of coordinates (9,9) is contained in the disk, it is
rather inelegant: it would be much better to be able to ask if 
<tt class="literal"><span class="pre">(9,9)</span> <span class="pre">in</span> <span class="pre">disk</span></tt>. This is possibile, indeed: and the secrets is to
define the special method <tt class="literal"><span class="pre">__contains__</span></tt>. This is done in the next
example, that I think give a good taste of the beauty of objects</p>
<blockquote>
<pre class="literal-block">
#&lt;funnyformatter.py&gt;

from oopp import Makeobj

Nrow=50; Ncol=78
  
class GeometricFigure(object):
    &quot;&quot;&quot;This class allows to define geometric figures according to their
    equation in the cartesian plane. Moreover addition and subtraction
    of geometric figures are defined as union and subtraction of sets.&quot;&quot;&quot;
    def __init__(self,equation,**parameters):
        &quot;Initialize &quot;
        self.eq=equation
        self.par=parameters
        for (k,v) in self.par.items(): #replaces the parameters
            self.eq=self.eq.replace(k,str(v))
        self.contains=eval('lambda x,y : '+self.eq)
    def combine(self,fig,operator):
        &quot;&quot;&quot;Combine self with the geometric figure fig, using the
        operators &quot;or&quot; (addition) and &quot;and not&quot; (subtraction)&quot;&quot;&quot;
        comboeq=&quot;(&quot;+self.eq+&quot;)&quot;+operator+&quot;(&quot;+fig.eq+&quot;)&quot;
        return GeometricFigure(comboeq)
    def __add__(self,fig):
        &quot;Union of sets&quot;
        return self.combine(fig,' or ')
    def __sub__(self,fig):
        &quot;Subtraction of sets&quot;
        return self.combine(fig,' and not')
    def __contains__(self,point): #point is a tuple (x,y)
        return self.contains(*point)

makedisk=Makeobj(GeometricFigure,'(x-x0)**2/4+(y-y0)**2 &lt;= r**2')
upperdisk=makedisk(x0=38,y0=7,r=5)
smalldisk=makedisk(x0=38,y0=30,r=5)
bigdisk=makedisk(x0=38,y0=30,r=14)

def format(text,shape):
    &quot;Format the text in the shape given by figure&quot;
    text=text.replace('\n',' ')
    out=[]; i=0; col=0; row=0; L=len(text)
    while 1:
        if (col,row) in shape:
            out.append(text[i]); i+=1
            if i==L: break
        else:
            out.append(&quot; &quot;)
        if col==Ncol-1:
            col=0; out.append('\n') # starts new row
            if row==Nrow-1: row=0   # starts new page
            else: row+=1
        else: col+=1 
    return ''.join(out)

composition=bigdisk-smalldisk+upperdisk
print format(text='Python Rules!'*95,shape=composition)

#&lt;/funnyformatter.py&gt;
</pre>
</blockquote>
<p>I leave as an exercise for the reader to understand how does it work and to
play with other geometric figures (he can also generate them trough the
'Makeobj' factory). I think it is nicer to show its output:</p>
<blockquote>
<pre class="literal-block">
                           Pyt                                      
                      hon Rules!Pyt                                 
                    hon Rules!Python                                
                   Rules!Python Rules!                              
                   Python Rules!Python                              
                   Rules!Python Rules!P                             
                   ython Rules!Python                               
                   Rules!Python Rules!                              
                    Python Rules!Pyth                               
                      on Rules!Pyth                                 
                           on                                       
                                                                    
                                                                    
                                                                    
                           Rul                                      
                  es!Python Rules!Pytho                             
              n Rules!Python Rules!Python R                         
           ules!Python Rules!Python Rules!Pyth                      
         on Rules!Python Rules!Python Rules!Pyth                    
       on Rules!Python Rules!Python Rules!Python R                  
     ules!Python Rules!Python Rules!Python Rules!Pyt                
    hon Rules!Python Rules!Python Rules!Python Rules!               
   Python Rules!Python Rules!Python Rules!Python Rules              
  !Python Rules!Python Rule   s!Python Rules!Python Rul             
  es!Python Rules!Pyth             on Rules!Python Rule             
 s!Python Rules!Pyth                 on Rules!Python Rul            
 es!Python Rules!Py                   thon Rules!Python             
 Rules!Python Rules                   !Python Rules!Pyth            
on Rules!Python Ru                     les!Python Rules!P           
 ython Rules!Python                    Rules!Python Rule            
 s!Python Rules!Pyt                   hon Rules!Python R            
 ules!Python Rules!P                 ython Rules!Python             
  Rules!Python Rules!P             ython Rules!Python R             
  ules!Python Rules!Python    Rules!Python Rules!Python             
    Rules!Python Rules!Python Rules!Python Rules!Pytho              
    n Rules!Python Rules!Python Rules!Python Rules!Py               
     thon Rules!Python Rules!Python Rules!Python Rul                
       es!Python Rules!Python Rules!Python Rules!P                  
         ython Rules!Python Rules!Python Rules!P                    
           ython Rules!Python Rules!Python Rul                      
              es!Python Rules!Python Rules!                         
                  Python Rules!Python R                             
                           ule                                      
                                                                    
                                                                    
                                                                    
                                                                    
                                                                    
                                                                    
                                                                    
                           s!
</pre>
</blockquote>
<p>Remark.</p>
<p>Unfortunately, &quot;funnyformatter.py&quot; does not reuse old code: in spite of the
fact that we already had in our library the 'GeometricFigure' class, with 
an &quot;__init__&quot; method that is exactly the same of the &quot;__init__&quot; method in 
&quot;funnyformatter.py&quot;, we did not reuse that code. We simply did a cut
and paste. This means that if we later find a bug in the <tt class="literal"><span class="pre">__init__</span></tt> method,
we will have to fix it twice, both in the script and in the library. Also,
if we plan to extend the method later, we will have to extend it twice.
Fortunately, this nasty situation can be avoided: but this requires the
power of inheritance.</p>
</div>
</div>
<div class="section" id="the-power-of-classes">
<h1><a class="toc-backref" href="#id82" name="the-power-of-classes">THE POWER OF CLASSES</a></h1>
<p>This chapter is devoted to the concept of class inheritance. I will discuss
single inheritance, cooperative methods, multiple inheritance and more.</p>
<div class="section" id="the-concept-of-inheritance">
<h2><a class="toc-backref" href="#id83" name="the-concept-of-inheritance">The concept of inheritance</a></h2>
<p>Inheritance is perhaps the most important basic feature in OOP, since it
allows the reuse and incremental improvement of old code.
To show this point, let me come back to one of the 
examples I have introduced in the last chapter, 'fairytale1.py' script, 
where I defined the classes 'Frog' and 'Prince' as</p>
<blockquote>
<pre class="literal-block">
class Frog(object):
    attributes=&quot;poor, small, ugly&quot;
    def __str__(self):
        return &quot;I am a &quot;+self.attributes+' '+self.__class__.__name__

class Prince(object):
    attributes='rich, tall, beautiful'
    def __str__(self):
        return &quot;I am a &quot;+self.attributes+' '+self.__class__.__name__
</pre>
</blockquote>
<p>We see that the way we followed here was very bad since:</p>
<ol class="arabic simple">
<li>The <tt class="literal"><span class="pre">__str__</span></tt> method is duplicated both in Frog and in Prince: that
means that if we find a bug a later, we have to fix it twice!</li>
<li>The <tt class="literal"><span class="pre">__str__</span></tt> was already defined in the PrettyPrinted class (actually 
more elegantly), therefore we have triplicated the work and worsened the 
situation!</li>
</ol>
<p>This is very much against the all philosophy of OOP:</p>
<blockquote>
<em>never cut and paste!</em></blockquote>
<p>We should <em>reuse</em> old code, not paste it!</p>
<p>The solution is <em>class inheritance</em>. The idea behind inheritance is to 
define new classes as subclasses of a <em>parent</em> classes, in such a way that 
the <em>children</em> classes possess all the features of the parents. 
That means that we do not need to 
redefine the properties of the parents explicitely.
In this example, we may derive both 'Frog' and 'Prince' from
the 'PrettyPrinted' class, thus providing to both 'Frog' and  'Prince'
the <tt class="literal"><span class="pre">PrettyPrinted.__str__</span></tt> method with no effort:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import PrettyPrinted
&gt;&gt;&gt; class Frog(PrettyPrinted): attributes=&quot;poor, small, ugly&quot;
...
&gt;&gt;&gt; class Prince(PrettyPrinted):  attributes=&quot;rich, tall, beautiful&quot;
...
&gt;&gt;&gt; print repr(Frog()), Frog()
&lt;__main__.Frog object at 0x401cbeac&gt; &lt;Frog&gt;
&gt;&gt;&gt; print Prince()
&gt;&gt;&gt; print repr(Prince()),Prince()
&lt;__main__.Prince object at 0x401cbaac&gt; &lt;Prince&gt;
</pre>
</blockquote>
<p>Let me show explicitly that both 'Frog' and 'Prince' share the 
'PrettyPrinted.__str__' method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id(Frog.__str__) # of course, YMMV
1074329476
&gt;&gt;&gt; id(Prince.__str__)
1074329476
&gt;&gt;&gt; id(PrettyPrinted.__str__)
1074329476
</pre>
</blockquote>
<p>The method is always the same, since the object reference is the same
(the precise value of the reference is not guaranteed to be  1074329476,
however!).</p>
<p>This example is good to show the first advantage of inheritance: 
<em>avoiding duplication of code</em>.
Another advantage of inheritance, is <em>extensibility</em>: one can very easily
improve existing code. For instance, having written the <tt class="literal"><span class="pre">Clock</span></tt> class once, 
I can reuse it in many different ways. for example I can build a <tt class="literal"><span class="pre">Timer</span></tt> 
to be used for benchmarks. It is enough to reuse the function <tt class="literal"><span class="pre">with_timer</span></tt>
introduced in the first chapter (functions are good for reuse of code, too ;):</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Timer(Clock):
    &quot;Inherits the get_time staticmethod from Clock&quot;
    execute=staticmethod(with_timer)
    loop_overhead=staticmethod(loop_overhead)


#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here there is an example of application:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Timer
&gt;&gt;&gt; Timer.get_time()
'16:07:06'
</pre>
</blockquote>
<p>Therefore 'Timer' inherits 'Clock.get_time'; moreover it has the additional 
method <tt class="literal"><span class="pre">execute</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def square(x): return x*x
...
&gt;&gt;&gt; Timer.execute(square,n=100000)(1)
executing square ...
  Real time: 0.01 ms  CPU time: 0.008 ms
</pre>
</blockquote>
<p>The advantage of putting the function <tt class="literal"><span class="pre">execute</span></tt> in a class is that
now we may <em>inherit</em> from that class and improve out timer <em>ad
libitum</em>.</p>
</div>
<div class="section" id="inheritance-versus-run-time-class-modifications">
<h2><a class="toc-backref" href="#id84" name="inheritance-versus-run-time-class-modifications">Inheritance versus run-time class modifications</a></h2>
<p>Naively, one could think of substituting inheritance with run-time 
modification of classes, since this is allowed by Python. However,
this is not such a good idea, in general. Let me give a simple example.
Suppose we want to improve our previous clock, to show the date, too.
We could reach that goal with the following script:</p>
<blockquote>
<pre class="literal-block">
#&lt;clock2.py&gt;

&quot;Shows how to modify and enhances classes on the fly&quot;

from oopp import *

clock=Clock() #creates a Clock instance
print clock.get_time() # print the current time

get_data=lambda : ' '.join(time.asctime().split()[0:3])+ \
                       ' '+time.asctime().split()[-1]

get_data_and_time=lambda : &quot;Today is: %s \nThe time is: %s&quot; % (
                       get_data(),get_time()) # enhances get_time

Clock.get_time=staticmethod(get_data_and_time)

print clock.get_time() # print the current time and data

#&lt;/clock2.py&gt;
</pre>
</blockquote>
<p>The output of this script is:</p>
<blockquote>
12:51:25
Today is: Sat Feb 22 2003 
The time is: 12:51:25</blockquote>
<p>Notice that:</p>
<ol class="arabic simple">
<li>I instantiated the <tt class="literal"><span class="pre">clock</span></tt> object <em>before</em> redefining the <tt class="literal"><span class="pre">get_time</span></tt>
method, when it only could print the time and <em>not</em> the date.</li>
<li>However, after the redefinition of the class, the behaviour of all its 
instances is changed, <em>including the behaviour of objects instantiated 
before the change!</em>. Then <tt class="literal"><span class="pre">clock</span></tt> <em>can</em> print the date, too.</li>
</ol>
<p>This is not so surprising, once you recognize that Guido own a very famous
time-machine ... ;-)</p>
<p>Seriously, the reason is that an object does not contains a reserved copy
of the attributes and methods of its class: it only contains <em>references</em>
to them. If we change them in the class, the references to them in the
object will stay the same, but the contents will change.</p>
<p>In this example, I have solved the problem of enhancing the 'Clock' class
without inheritance, but dynamically replaceing its <tt class="literal"><span class="pre">get_time</span></tt> 
(static) method with the <cite>get_data_and_time`</cite> (static) method. 
The dynamics modification of methods can be cool, but it should be avoided 
whenever possible, at least for two reasons <a class="footnote-reference" href="#id22" id="id23" name="id23">[11]</a>:</p>
<ol class="arabic simple">
<li>having a class and therefore all its instances (including the instances
created before the modification !) changed during the life-time of the
program can be very confusing to the programmer, if not to the interpreter.</li>
<li>the modification is destructive: I cannot have the old <tt class="literal"><span class="pre">get_time</span></tt> method
and the new one at the same time, unless one explicitly gives to it 
a new name (and giving new names increases the pollution of the namespace).</li>
</ol>
<p>Both these disadvantages can be solved by resorting to the mechanism of
inheritance. For instance, in this example, we can derive a new class 
<tt class="literal"><span class="pre">NewClock</span></tt> from <tt class="literal"><span class="pre">Clock</span></tt> as follows:</p>
<blockquote>
<pre class="literal-block">
#&lt;newclock.py&gt;

import oopp,time

get_data=lambda : ' '.join(time.asctime().split()[0:3])+ \
                       ' '+time.asctime().split()[-1]

get_data_and_time=lambda : &quot;Today is: %s \nThe time is: %s&quot; % (
                       get_data(),oopp.get_time()) # enhances get_time

class NewClock(oopp.Clock):
       &quot;&quot;&quot;NewClock is a class that inherits from Clock, provides get_data
        and overrides get_time.&quot;&quot;&quot;
       get_data=staticmethod(get_data)
       get_time=staticmethod(get_data_and_time)

clock=oopp.Clock(); print 'clock output=',clock.get_time() 
newclock=NewClock(); print 'newclock output=',newclock.get_time()

#&lt;/newclock.py&gt;
</pre>
</blockquote>
<p>The output of this script is:</p>
<blockquote>
<pre class="literal-block">
clock output= 16:29:17
newclock output= Today is: Sat Feb 22 2003 
The time is: 16:29:17
</pre>
</blockquote>
<p>We see that the two problems previously discussed are solved since:</p>
<ol class="lowerroman simple">
<li>there is no cut and paste: the old method <tt class="literal"><span class="pre">Clock.get_time()</span></tt> is used
in the definition of the new method <tt class="literal"><span class="pre">NewClock.get_time()</span></tt>;</li>
<li>the old method is still accessible as <tt class="literal"><span class="pre">Clock.get_time()</span></tt>; there is
no need to invent a new name like <tt class="literal"><span class="pre">get_time_old()</span></tt>.</li>
</ol>
<p>We say that the method <tt class="literal"><span class="pre">get_time</span></tt> in <tt class="literal"><span class="pre">NewClock</span></tt> <em>overrides</em> the method
<tt class="literal"><span class="pre">get_time</span></tt> in Clock.</p>
<p>This simple example shows the power of inheritance in code
reuse, but there is more than that.</p>
<p>Inheritance is everywhere in Python, since
all  classes inherit from object. This means that all classes
inherit the methods and attributes of the object class, such as <tt class="literal"><span class="pre">__doc__</span></tt>,
<tt class="literal"><span class="pre">__class__</span></tt>, <tt class="literal"><span class="pre">__str__</span></tt>, etc.</p>
<blockquote>
<table class="footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25" name="id24">[12]</a></td><td>There are cases when run-time modifications of classes is useful
anyway: particularly when one wants to modify the behavior of
classes written by others without changing the source code. I
will show an example in next chapter.</td></tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="inheriting-from-built-in-types">
<h2><a class="toc-backref" href="#id85" name="inheriting-from-built-in-types">Inheriting from built-in types</a></h2>
<p>However, one can subclass a built-in type, effectively creating an 
user-defined type with all the feature of a built-in type, and modify it.</p>
<p>Suppose for instance one has a keyword dictionary such as</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; kd={'title': &quot;OOPP&quot;, 'author': &quot;M.S.&quot;, 'year': 2003}
</pre>
</blockquote>
<p>it would be nice to be able to access the attributes without
excessive quoting, i.e. using <tt class="literal"><span class="pre">kd.author</span></tt> instead of <tt class="literal"><span class="pre">kd[&quot;author&quot;]</span></tt>.
This can be done by subclassing the built-in class <tt class="literal"><span class="pre">dict</span></tt> and
by overriding the <tt class="literal"><span class="pre">__getattr__</span></tt> and <tt class="literal"><span class="pre">__setattr__</span></tt> special methods:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp/py&gt;

class kwdict(dict):
    &quot;Keyword dictionary base class&quot;
    def __getattr__(self,attr): 
        return self[attr]
    def __setattr__(self,key,val): 
        self[key]=val
    __str__ = pretty 

#&lt;/oopp/py&gt;
</pre>
</blockquote>
<p>Here there is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import kwdict
&gt;&gt;&gt; book=kwdict({'title': &quot;OOPP&quot;, 'author': &quot;M.S.&quot;})
&gt;&gt;&gt; book.author #it works
'M.S.'
&gt;&gt;&gt; book[&quot;author&quot;] # this also works
'M.S.'
&gt;&gt;&gt; book.year=2003 #you may also add new fields on the fly
&gt;&gt;&gt; print book
author = M.S.
title = OOPP
year = 2003
</pre>
</blockquote>
<p>The advantage of subclassing the built-in 'dict', it that you have for free 
all the standard dictionary methods, without having to reimplement them.</p>
<p>However, to subclass built-in it is not always a piece of cake. In
many cases there are complications, indeed. Suppose for instance
one wants to create an enhanced string type, with
the ability of indent and dedent a block of text provided by 
the following functions:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def indent(block,n):
     &quot;Indent a block of code by n spaces&quot;
     return '\n'.join([' '*n+line for line in block.splitlines()])

def dedent(block):
    &quot;Dedent a block of code, if need there is&quot;&quot;&quot;
    lines=block.splitlines()
    for line in lines:
        strippedline=line.lstrip()
        if strippedline: break
    spaces=len(line)-len(strippedline)
    if not spaces: return block
    return '\n'.join([line[spaces:] for line in lines])

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>The solution is to inherit from the built-in string type <tt class="literal"><span class="pre">str</span></tt>, and to 
add to the new class the <tt class="literal"><span class="pre">indent</span></tt> and <tt class="literal"><span class="pre">dedent</span></tt> methods:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import indent,dedent
&gt;&gt;&gt; class Str(str):
...    indent=indent
...    dedent=dedent
&gt;&gt;&gt; s=Str('spam\neggs')
&gt;&gt;&gt; type(s)
&lt;class '__main__.Str'&gt;
&gt;&gt;&gt; print s.indent(4)
    spam
    eggs
</pre>
</blockquote>
<p>However, this approach has a disadvantage, since the output of <tt class="literal"><span class="pre">indent</span></tt> is
not a <tt class="literal"><span class="pre">Str</span></tt>, but a normal <tt class="literal"><span class="pre">str</span></tt>, therefore without the additional 
<tt class="literal"><span class="pre">indent</span></tt> and <tt class="literal"><span class="pre">dedent</span></tt> methods:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(s.indent(4))
&lt;type 'str'&gt;
&gt;&gt;&gt; s.indent(4).indent(4) #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 9, in ?
AttributeError: 'str' object has no attribute 'indent'
&gt;&gt;&gt; s.indent(4).dedent(4) #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 9, in ?
AttributeError: 'str' object has no attribute 'dedent'
</pre>
</blockquote>
<p>We would like <tt class="literal"><span class="pre">indent</span></tt> to return a <tt class="literal"><span class="pre">Str</span></tt> object. To solve this problem
it is enough to rewrite the class as follows:</p>
<blockquote>
<pre class="literal-block">
#&lt;Str.py&gt;

from oopp import indent,dedent

class Str(str):
   def indent(self,n):
       return Str(indent(self,n))
   def dedent(self):
       return Str(dedent(self))

s=Str('spam\neggs').indent(4)
print type(s)
print s # indented s
s=s.dedent()
print type(s)
print s # non-indented s

#&lt;/Str.py&gt;
</pre>
</blockquote>
<p>Now, everything works and the output of the previous script is</p>
<blockquote>
<pre class="literal-block">
&lt;class 'Str'&gt;
    spam
    eggs
&lt;class 'Str'&gt;
spam
eggs
</pre>
</blockquote>
<p>The solution works because now <tt class="literal"><span class="pre">indent()</span></tt> returns an instance
of <tt class="literal"><span class="pre">Str</span></tt>, which therefore has an <tt class="literal"><span class="pre">indent</span></tt> method. Unfortunately,
this is not the end. Suppose we want to add another food to our list:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; s2=s+Str(&quot;\nham&quot;)
&gt;&gt;&gt; s2.indent(4) #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: 'str' object has no attribute 'indent'
</pre>
</blockquote>
<p>The problem is the same, again: the type of <tt class="literal"><span class="pre">s2</span></tt> is <tt class="literal"><span class="pre">str</span></tt></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(s2)
&lt;type 'str'&gt;
</pre>
</blockquote>
<p>and therefore there is no <tt class="literal"><span class="pre">indent</span></tt> method available. There is a
solution to this problem, i.e. to redefine the addition operator
for objects of the class <tt class="literal"><span class="pre">Str</span></tt>. This can be done directly by hand,
but it is <em>ugly</em> for the following reasons:</p>
<ol class="arabic simple">
<li>If you derive a new class from <tt class="literal"><span class="pre">Str</span></tt> you have to redefine the
addition operator (both the left addition and the right addition <a class="footnote-reference" href="#id24" id="id25" name="id25">[12]</a>)
again (ughh!);</li>
<li>There are others operators you must redefine, in particular the
the augumented assignement operator <tt class="literal"><span class="pre">+=</span></tt>, the repetition operator <tt class="literal"><span class="pre">*</span></tt> 
and its augmented version <tt class="literal"><span class="pre">*=</span></tt>;</li>
<li>In the case of numeric types, one must redefine, <tt class="literal"><span class="pre">+,-,*,/,//,</span> <span class="pre">mod,</span></tt>,
possibily <tt class="literal"><span class="pre">&lt;&lt;,&gt;&gt;</span></tt> and others, including  the corresponding 
augumented assignement operators and the left and the right form of
the operators.</li>
</ol>
<p>This is a mess, especially since due to point 1, one has to redefined
all the operators each time she defines a new subclass. I short, one has
to write a lot of boilerplate for a stupid job that the language
should be able to perform itself automatically. But here are the
good news: Python <em>can</em> do all that automatically, in an elegant
and beautiful way, which works for all types, too.</p>
<p>But this requires the magic of metaclasses.</p>
<blockquote>
<table class="footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27" name="id26">[13]</a></td><td>The right addition works this way. Python looks at the expression x+y
and if x has an explicit__add__ method invokes it; on the other hand, 
if x does not define  an __add__ method, Python considers y+x. 
If y defines a __radd__ method, it invokes it, otherwise
raises an exception. The same is done for right multiplication, etc.</td></tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="controlling-the-creation-of-objects">
<h2><a class="toc-backref" href="#id86" name="controlling-the-creation-of-objects">Controlling the creation of objects</a></h2>
<p>Before introducing multiple inheritance, let me make a short digression on
the mechanism of object creation in Python 2.2+. The important point is
that new style classes have a <tt class="literal"><span class="pre">__new__</span></tt> static method that allows
the user to take complete control of object creation. To understand how
<tt class="literal"><span class="pre">__new__</span></tt> works, I must explain what happens when an object is instantiated
with a statement like</p>
<blockquote>
<pre class="literal-block">
s=Str(&quot;spam&quot;) #object creation
</pre>
</blockquote>
<p>What happens under the hood, is that the special static method  <tt class="literal"><span class="pre">__new__</span></tt> 
of the class <tt class="literal"><span class="pre">Str</span></tt> (inherited from the built-in <tt class="literal"><span class="pre">str</span></tt> class)
is invoked <tt class="literal"><span class="pre">before</span></tt> the <tt class="literal"><span class="pre">Str.__init__</span></tt> method. This means that
the previous line should really be considered syntactic sugar for:</p>
<blockquote>
<pre class="literal-block">
s=Str.__new__(Str,&quot;spam&quot;) # Str.__new__ is actually str.__new__
assert isinstance(s,Str)
Str.__init__(s,&quot;spam&quot;)  # Str.__init__ is actually str.__init__
</pre>
</blockquote>
<p>Put it more verbosely, what happens during the object creation is the
following:</p>
<ol class="arabic simple">
<li>the static method <tt class="literal"><span class="pre">__new__</span></tt>  is invoked with the class of the created 
object as first argument <a class="footnote-reference" href="#id26" id="id27" name="id27">[13]</a>;</li>
<li><tt class="literal"><span class="pre">__new__</span></tt> returns an instance of that class.</li>
<li>the instance is then initialized by the <tt class="literal"><span class="pre">__init__</span></tt> method.</li>
</ol>
<p>Notice that both <tt class="literal"><span class="pre">__new__</span></tt> and <tt class="literal"><span class="pre">__init__</span></tt> are called with the same 
argument list, therefore one must make sure that they have a compatible 
signature.</p>
<p>Let me discuss now why <tt class="literal"><span class="pre">__new__</span></tt> must be a static method.
First of all, it cannot be a normal method with a first argument which is an
instance of the calling class, since at the time of <tt class="literal"><span class="pre">__new__</span></tt> invocation
that instance (<tt class="literal"><span class="pre">myclock</span></tt> in the example) has still to be created
Since <tt class="literal"><span class="pre">__new__</span></tt> needs information about the class calling it, one
could think of implementing <tt class="literal"><span class="pre">__new__</span></tt> as a class method. However,
this would implicitly pass the caller class and return an instance
of it. It is more convenient, to have the ability of creating
instances of any class directly from C.__new__(B,*args,**kw)</p>
<p>For this reasons, <tt class="literal"><span class="pre">__new__</span></tt> must be a static method and pass explicitly
the class which is calling it.</p>
<p>Let me now show an important application of the <tt class="literal"><span class="pre">__new__</span></tt> static method:
forbidding object creation. For instance, sometimes it is useful to have 
classes that cannot be instantiated. This kind of classes can be
obtained by inheriting from a <tt class="literal"><span class="pre">NonInstantiable</span></tt> class:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class NonInstantiableError(Exception): 
    pass

class NonInstantiable(object): 
    def __new__(cls,*args,**kw):
        raise NonInstantiableError(&quot;%s cannot be instantiated&quot; % cls)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here there is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import NonInstantiable,get_time
&gt;&gt;&gt; class Clock(NonInstantiable): 
...    get_time=staticmethod(get_time)
&gt;&gt;&gt; Clock.get_time() # works
'18:48:08'
Clock() #error
Traceback (most recent call last):
  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in ?
    Clock()
  File &quot;oopp.py&quot;, line 257, in __new__
    raise NonInstantiableError(&quot;%s cannot be instantiated&quot; % cls)
NonInstantiableError: &lt;class '__main__.Clock'&gt; cannot be instantiated
</pre>
</blockquote>
<p>However, the approach pursued here has a disadvantage:<tt class="literal"><span class="pre">Clock</span></tt> was already 
defined as a subclass of <tt class="literal"><span class="pre">object</span></tt> and I has to change the source code
to make it a subclass of 'NonInstantiable'. But what happens if 
I cannot change the sources? How can I <em>reuse</em> the old code?</p>
<p>The solution is provided by multiple inheritance.</p>
<p>Notice that '__new__' is a staticmethod: <a class="footnote-reference" href="#id29" id="id28" name="id28">[14]</a></p>
<blockquote>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(NonInstantiable.__dict__['__new__'])
&lt;type 'staticmethod'&gt;
</pre>
</blockquote>
<table class="footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id28" name="id29">[14]</a></td><td>This is how <tt class="literal"><span class="pre">type(s)</span></tt> or <tt class="literal"><span class="pre">s.__class__</span></tt> get to know that 
<tt class="literal"><span class="pre">s</span></tt> is an instance of <tt class="literal"><span class="pre">Str</span></tt>, since the class information is 
explicitely passed to the newborn object trough <tt class="literal"><span class="pre">__new__</span></tt>.</td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31" name="id30">[15]</a></td><td><p>However <tt class="literal"><span class="pre">object.__dict__['__new__']</span></tt> is not a staticmethod</p>
<pre class="doctest-block">
&gt;&gt;&gt; type(object.__dict__['__new__']) # special case
&lt;type 'builtin_function_or_method'&gt;
</pre>
</td></tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="multiple-inheritance">
<h2><a class="toc-backref" href="#id87" name="multiple-inheritance">Multiple Inheritance</a></h2>
<p>Multiple Inheritance (often abbreviated as MI) is often 
considered one of the most advanced topic in Object Oriented Programming. 
It is also one of the most difficult features to implement
in an Object Oriented Programming language. Even, some languages by design
decided to avoid it. This is for instance the case of Java, that avoided
MI having seen its implementation in C++ (which is not for the faint of
heart ;-) and uses a poorest form of it trough interfaces.
For what concerns the scripting languages, of which
the most famous are Perl, Python and Ruby (in this order, even if
the right order would be Python, Ruby and Perl), only Python
implements Multiple Inheritance well (Ruby has a restricted form
of it trough mix-ins, whereas Perl implementation is too difficult
for me to understand what it does ;).</p>
<p>The fact that Multiple Inheritance can be hairy, does not mean that it
is <em>always</em> hairy, however. Multiple Inheritance is used with success
in Lisp derived languages (including Dylan).</p>
<p>The aims of this chapter is to discuss the
Python support for MI in the most recent version (2.2 and 2.3), which
has considerably improved with respect to previous versions.
The message is the following: if Python 1.5 had a basic support for
MI inheritance (basic but nevertheless with nice features, dynamic),
Python 2.2 has <em>greatly</em> improved that support and with the
change of the Method Resolution Order in Python 2.3, we may say
that support for MI is now <em>excellent</em>.</p>
<p>I strongly encourage Python programmers to use MI a lot: this will
allows even a stronger reuse of code than in single inheritance.</p>
<p>Often, inheritance is used when one has a complicate class B, and she wants 
to modify (or enhance) its behavior, by deriving a child class C, which is 
only slightly different from B. In this situation,  B is already a standalone 
class, providing some non-trivial functionality, independently from 
the existence of C.  This kind of design it typical of the so called
<em>top-down</em> philosophy, where one builds the 
all structure as a monolithic block, leaving room only for minor improvements.
An alternative approach is the so called <em>bottom-up</em> programming, in 
which one builds complicate things starting from very simple building blocks. 
In this logic, it is very appealing the idea of creating classes with the
only purpose of being derived. The 'NonInstantiable' just defined is a
perfect example of this kind of classes, though with multiple inheritance
in mind and often called <em>mixin</em> classes.
It can be used to create a new class <tt class="literal"><span class="pre">NonInstantiableClock</span></tt> 
that inherits from <tt class="literal"><span class="pre">Clock</span></tt> and from <tt class="literal"><span class="pre">NonInstantiable</span></tt>.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class NonInstantiableClock(Clock,NonInstantiable): 
    pass

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Now <tt class="literal"><span class="pre">NonInstantiableClock</span></tt> is both a clock</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import NonInstantiableClock
&gt;&gt;&gt; NonInstantiableClock.get_time() # works
'12:57:00' 
</pre>
</blockquote>
<p>and a non-instantiable class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; NonInstantiableClock() # as expected, give an error
Traceback (most recent call last):
  File &quot;&lt;pyshell#2&gt;&quot;, line 1, in ?
    NonInstantiableClock() # error
  File &quot;oopp.py&quot;, line 245, in __new__
    raise NonInstantiableError(&quot;%s cannot be instantiated&quot; % cls)
NonInstantiableError: &lt;class 'oopp.NonInstantiableClock'&gt; 
cannot be instantiated
</pre>
</blockquote>
<p>Let me give a simple example of a situation where the mixin approach 
comes handy. Suppose that the owner of a 'Pizza-shop' needs a program to 
take care of all the pizzas to-go he sell. Pizzas are distinguished 
according to their size (small, medium or large) and their toppings. 
The problem can be solved by inheriting from a generic pizza factory
like this:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class GenericPizza(object): # to be customized
    toppinglist=[] # nothing, default 
    baseprice=1 # one dollar, default
    topping_unit_price=0.5 # half dollar for each topping, default
    sizefactor={'small':1, 'medium':2, 'large':3} 
    # a medium size pizza costs twice a small pizza, 
    # a large pizza costs three times
    def __init__(self,size):
        self.size=size
    def price(self):
        return (self.baseprice+
               self.toppings_price())*self.sizefactor[self.size]
    def toppings_price(self):
        return len(self.toppinglist)*self.topping_unit_price
    def __str__(self):
        return '%s pizza with %s, cost $ %s' % (self.size,
                                          ','.join(self.toppinglist),
                                          self.price())

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here the base class 'GenericPizza' is written with inheritance in mind: one
can derives many pizza classes from it by overriding the <tt class="literal"><span class="pre">toppinglist</span></tt>;
for instance one could define</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import GenericPizza
&gt;&gt;&gt; class Margherita(GenericPizza): 
...     toppinglist=['tomato']
</pre>
</blockquote>
<p>The problem of this approach is that one must define dozens of 
different pizza subclasses (Marinara, Margherita, Capricciosa, QuattroStagioni, 
Prosciutto, ProsciuttoFunghi, PizzaDellaCasa, etc. etc. <a class="footnote-reference" href="#id30" id="id31" name="id31">[15]</a>). In such a 
situation, it is better to perform the generation of subclasses in a smarter 
way, i.e. via a customizable class factory.
A simpler approach is to use always the same class and to customize
its instances just after creation. Both approaches can be implemented via
the following 'Customizable' mixin class, not meant to be instantiated, 
but rather to be <em>inherited</em>:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Customizable(object):
    &quot;&quot;&quot;Classes inhering from 'Customizable' have a 'with' method acting as
    an object modifier and 'With' classmethod acting as a class factory&quot;&quot;&quot;
    def with(self,**kw):
        customize(self,**kw)# customize the instance
        return self # returns the customized instance
    def With(cls,**kw):
        class ChildOf(cls): pass # a new class inheriting from cls
        ChildOf.__name__=cls.__name__ # by default, with the same name
        customize(ChildOf,**kw)       # of the original class
        return ChildOf
    With=classmethod(With) 

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Descendants of 'Customizable' can be customized by using
'with', that directly acts on the instances, or 'With', that returns
new classes. Notice that one could make 'With' to customize the
original class, without returning a new one; however, in practice,
this would not be safe: I remind that changing a class modifies
automatically all its instances, even instances created <em>before</em>
the modification. This could produce bad surprises: it is better to 
returns new classes, that may have the same name of the original one, 
but are actually completely independent from it.</p>
<p>In order to solve the pizza shop problem we may define a 'CustomizablePizza' 
class</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class CustomizablePizza(GenericPizza,Customizable):
    pass

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>which can be used in two ways: i) to customize instances just after creation:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import CustomizablePizza
&gt;&gt;&gt; largepizza=CustomizablePizza('large') # CustomizablePizza instance
&gt;&gt;&gt; largemarinara=largepizza.with(toppinglist=['tomato'],baseprice=2)
&gt;&gt;&gt; print largemarinara
large pizza with tomato mozzarella, cost $ 7.0
</pre>
</blockquote>
<p>and ii) to generated customized new classes:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Margherita=CustomizablePizza.With(
...    toppinglist=['tomato','mozzarella'], __name__='Margherita')
&gt;&gt;&gt; print Margherita('medium')
medium pizza with tomato,mozzarella, cost $ 4.0
</pre>
</blockquote>
<p>The advantage of the bottom-up approach, is that the 'Customizable' class
can be reused in completely different problems; for instance, it could
be used as a class factory. For instance we could use it to generate a 
'CustomizableClock' class as in this example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; CustomizableClock=Customizable.With(get_time=staticmethod(Clock.get_time),
... __name__='CustomizableClock') #adds get_time
&gt;&gt;&gt; CustomizableClock.get_time() # now it works
'09:57:50'
</pre>
</blockquote>
<p>Here 'Customizable' &quot;steal&quot; the 'get_time' method from 'Clock'.
However that would be a rather perverse usage ;) I wrote it to show
the advantage of classmethods, more than to suggest to the reader that
this is an example of good programming.</p>
<blockquote>
<table class="footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33" name="id32">[16]</a></td><td>In Italy, you can easily find &quot;pizzerie&quot; with more than 50 different 
kinds of pizzas (once I saw a menu with something like one hundred 
different combinations ;)</td></tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="cooperative-hierarchies">
<h2><a class="toc-backref" href="#id88" name="cooperative-hierarchies">Cooperative hierarchies</a></h2>
<p>The examples of multiple inheritance hierarchies given until now were pretty 
easy. The reason is that there was no interaction between the methods of the 
children and of the parents. However, things get more complicated (and
interesting ;) when the methods in the hierarchy call each other. 
Let me consider an example coming from paleoantropology:</p>
<blockquote>
<pre class="literal-block">
#&lt;paleoanthropology1.py&gt;

class HomoHabilis(object):
    def can(self):
        print self,'can:'
        print &quot; - make tools&quot;

class HomoSapiens(HomoHabilis):
    def can(self): #overrides HomoHabilis.can
        HomoHabilis.can(self)
        print &quot; - make abstractions&quot;
      
class HomoSapiensSapiens(HomoSapiens):
    def can(self): #overrides HomoSapiens.can
        HomoSapiens.can(self)
        print &quot; - make art&quot;

modernman=HomoSapiensSapiens()
modernman.can()

#&lt;/paleoanthropology1.py&gt;
</pre>
</blockquote>
<p>In this example children methods call parent methods:  
'HomoSapiensSapiens.can' calls 'HomoSapiens.can' that in turns calls
'HomoHabilis.can' and the final output is:</p>
<blockquote>
<pre class="literal-block">
&lt;__main__.HomoSapiensSapiens object at 0x814e1fc&gt; can:
 - make tools
 - make abstractions
 - make art
</pre>
</blockquote>
<p>The script works, but it is far from ideal,  if code reuse and refactoring
are considered important requirements. The point is that (very likely, as the
research in paleoanthropology progresses) we may want to extend the 
hierarchy, for instance by adding a class on the top or in the middle. 
In the present form, this would require a non-trivial modification of 
the source code (especially
if one think that the hierarchy could be fleshed out with dozens of others
methods and attributes). However, the aim of OOP is to avoid as 
much as possible source code modifications. This goal can be attained in
practice, if the source code is written to be friendly to extensions and 
improvements as much as possible. I think it is worth to spend some time 
in improving this example, since what can be learn here, 
can be lifted to real life cases.</p>
<p>First of all, let me define a generic <em>Homo</em> class, to be used
as first ring of the inheritance chain (actually the first ring is
'object'):</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Homo(PrettyPrinted): 
    &quot;&quot;&quot;Defines the method 'can', which is intended to be overriden 
    in the children classes, and inherits '__str__' from PrettyPrinted,
    ensuring a nice printing representation for all children.&quot;&quot;&quot;
    def can(self): 
        print self,'can:'
    
#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Now, let me point out one of the shortcomings of the previous code: in each
subclass, we explicitly call its parent class (also called super class)
by its name. This is inconvenient, both because a change of name in
later stages of the project would require a lot of search and replace
(actually not a lot in this toy example, but you can imagine having
a very big projects with dozens of named method calls) and because it makes 
difficult to insert a new element in the inheritance hierarchy. 
The solution to this problems is the
<tt class="literal"><span class="pre">super</span></tt> built-in, which provides an easy access to the methods
of the superclass.
<tt class="literal"><span class="pre">super</span></tt> objects comes in two flavors: <tt class="literal"><span class="pre">super(cls,obj)</span></tt> objects return 
bound methods whereas <tt class="literal"><span class="pre">super(cls)</span></tt> objects return unbound methods.
In the next code we will use the first form. The hierarchy can more elegantly 
be rewritten as <a class="footnote-reference" href="#id32" id="id33" name="id33">[16]</a> :</p>
<blockquote>
<pre class="literal-block">
#&lt;paleo2.py&gt;

from oopp import Homo

class HomoHabilis(Homo):
    def can(self):
        super(HomoHabilis,self).can()
        print &quot; - make tools&quot;

class HomoSapiens(HomoHabilis):
    def can(self):
        super(HomoSapiens,self).can()
        print &quot; - make abstractions&quot;
      
class HomoSapiensSapiens(HomoSapiens):
    def can(self):
        super(HomoSapiensSapiens,self).can()
        print &quot; - make art&quot;


HomoSapiensSapiens().can()

#&lt;/paleo2.py&gt;
</pre>
</blockquote>
<p>with output</p>
<blockquote>
<pre class="literal-block">
&lt;HomoSapiensSapiens&gt; can:
 - make tools
 - make abstractions
 - make art
</pre>
</blockquote>
<p>This is not yet the most elegant form, since even
if <tt class="literal"><span class="pre">super</span></tt> avoids naming the base class explicitely, still it
requires to explicitely name the class where it is defined. This is
rather annoying.
Removing that restriction, i.e. implementing really anonymous 
<tt class="literal"><span class="pre">super</span></tt> calls, is possible but requires a good understand of
private variables in inheritance.</p>
</div>
<div class="section" id="inheritance-and-privacy">
<h2><a class="toc-backref" href="#id89" name="inheritance-and-privacy">Inheritance and privacy</a></h2>
<p>In order to define anonymous cooperative super calls,  we need classes 
that know themselves, i.e. containing a reference to themselves. This
is not an obvious problem as it could seems, since it cannot be solved
without incurring in the biggest annoyance in inheritance: 
<em>name clashing</em>. Name clashing happens when names and attributes defined 
in different ancestors overrides each other in a unwanted order.
Name clashing is especially painful in the case of cooperative 
hierarchies and particularly in in the problem at hand.</p>
<p>A naive solution would be to attach a plain (i.e. non-private) 
attribute '.this' to the class, containing a reference
to itself, that can be invoked by the methods of the class.
Suppose, for instance, that I want to use that attribute in the <tt class="literal"><span class="pre">__init__</span></tt>
method of that class. A naive attempt would be to write something like:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class B(object):
...     def __init__(self): 
...         print self.this,'.__init__' # .this defined later
&gt;&gt;&gt; B.this=B # B.this can be set only after B has been created
&gt;&gt;&gt; B()
&lt;class '__main__.B'&gt;
</pre>
</blockquote>
<p>Unfortunately, this approach does not work with cooperative hierarchies. 
Consider, for instance, extending 'B' with a cooperative children 
class 'C' as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class C(B):
...    def __init__(self):
...       super(self.this,self).__init__() # cooperative call
...       print type(self).this,'.__init__'
&gt;&gt;&gt; C.this=C
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">C.__init__</span></tt> calls <tt class="literal"><span class="pre">B.__init__</span></tt> by passing a 'C' instance, therefore
<tt class="literal"><span class="pre">C.this</span></tt> is printed and not <tt class="literal"><span class="pre">B.this</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C()
&lt;class '__main__.C'&gt; .__init__
&lt;class '__main__.C'&gt; .__init__
&lt;__main__.C object at 0x4042ca6c&gt;
</pre>
</blockquote>
<p>The problem is that the <tt class="literal"><span class="pre">C.this</span></tt> overrides <tt class="literal"><span class="pre">B.this</span></tt>. The only
way of avoiding the name clashing is to use a private attribute 
<tt class="literal"><span class="pre">.__this</span></tt>, as in the following script:</p>
<blockquote>
<pre class="literal-block">
#&lt;privateh.py&gt;

class B(object):
     def __init__(self): 
        print self.__this,'.__init__'
B._B__this=B

class C(B):
    def __init__(self):
       super(self.__this,self).__init__() # cooperative __init__ 
       print self.__this,'.__init__'
C._C__this=C

C()

# output:
# &lt;class '__main__.B'&gt; .__init__
# &lt;class '__main__.C'&gt; .__init__

#&lt;/privateh.py&gt;
</pre>
</blockquote>
<p>The script works since, due to the magic of the mangling mechanism,
in <tt class="literal"><span class="pre">B.__init__</span></tt>, <tt class="literal"><span class="pre">self._B__this</span></tt> i.e. <tt class="literal"><span class="pre">B</span></tt> is retrieved, whereas in 
<tt class="literal"><span class="pre">C.__init__</span></tt> <tt class="literal"><span class="pre">self._C__this</span></tt> i.e. <tt class="literal"><span class="pre">C</span></tt> is retrieved.</p>
<p>The elegance of the mechanism can be improved with an helper function
that makes its arguments reflective classes, i.e. classes with a
<tt class="literal"><span class="pre">__this</span></tt> private attribute:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def reflective(*classes):
    &quot;&quot;&quot;Reflective classes know themselves, i.e. they possess a private
    attribute __this containing a reference to themselves. If the class
    name starts with '_', the underscores are stripped.&quot;&quot;&quot;
    for c in classes:
        name=c.__name__ .lstrip('_')  # in 2.3
        setattr(c,'_%s__this' % name,c) 

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>It is trivial to rewrite the paleonthropological hierarchy in terms of 
anonymous cooperative super calls by using this trick.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class HomoHabilis(Homo):
    def can(self):
        super(self.__this,self).can()
        print &quot; - make tools&quot;

class HomoSapiens(HomoHabilis):
    def can(self):
        super(self.__this,self).can()
        print &quot; - make abstractions&quot;
      
class HomoSapiensSapiens(HomoSapiens):
    def can(self):
        super(self.__this,self).can()
        print &quot; - make art&quot;

reflective(HomoHabilis,HomoSapiens,HomoSapiensSapiens)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here there is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; man=HomoSapiensSapiens(); man.can()
&lt;HomoSapiensSapiens&gt; can:
 - make tools
 - make abstractions
 - make art
</pre>
</blockquote>
<p>We may understand why it works by looking at the attributes of man:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print pretty(attributes(man))
_HomoHabilis__this = &lt;class 'oopp.HomoHabilis'&gt;
_HomoSapiensSapiens__this = &lt;class 'oopp.HomoSapiensSapiens'&gt;
_HomoSapiens__this = &lt;class 'oopp.HomoSapiens'&gt;
can = &lt;bound method HomoSapiensSapiens.can of 
      &lt;oopp.HomoSapiensSapiens object at 0x404292ec&gt;&gt;
formatstring = %s
</pre>
</blockquote>
<p>It is also interesting to notice that the hierarchy can be entirely
rewritten without using cooperative methods, but using private attributes,
instead. This second approach is simpler, as the following script shows:</p>
<blockquote>
<pre class="literal-block">
#&lt;privatehierarchy.py&gt;

from oopp import PrettyPrinted,attributes,pretty

class Homo(PrettyPrinted):
    def can(self):
        print self,'can:'
        for attr,value in attributes(self).iteritems(): 
            if attr.endswith('__attr'): print value
class HomoHabilis(Homo): 
    __attr=&quot; - make tools&quot;
class HomoSapiens(HomoHabilis): 
    __attr=&quot; - make abstractions&quot;
class HomoSapiensSapiens(HomoSapiens): 
    __attr=&quot; - make art&quot;

modernman=HomoSapiensSapiens()
modernman.can()
print '----------------------------------\nAttributes of',modernman
print pretty(attributes(modernman))

#&lt;/privatehierarchy.py&gt;
</pre>
</blockquote>
<p>Here I have replaced the complicate chain of cooperative methods with 
much simpler private attributes. Only the 'can' method in the 'Homo' 
class survives, and it is modified to print the value of the '__attr' 
attributes. Moreover, all the classes of the hierarchy have been made
'Customizable', in view of future extensions.</p>
<p>The second script is much shorter and much more elegant than the original
one, however its logic can be a little baffling, at first. The solution
to the mistery is provided by the attribute dictionary of 'moderman',
given by the second part of the output:</p>
<blockquote>
<pre class="literal-block">
&lt;HomoSapiensSapiens&gt; can:
 - make abstractions  
 - make art  
 - make tools 
------------------------------------------
Attributes of &lt;HomoSapiensSapiens&gt;:
_HomoHabilis__attr =  - make tools
_HomoSapiensSapiens__attr =  - make art
_HomoSapiens__attr =  - make abstractions
can = &lt;bound method HomoSapiensSapiens.can of 
      &lt;__main__.HomoSapiensSapiens object at 0x402d892c&gt;&gt;
formatstring = %s
</pre>
</blockquote>
<p>We see that, in addition to the 'can' method inherited from 'Homo',
the 'with' and 'With' method inherited from 'Customizable' and
the 'formatstring' inherited from 'PrettyPrinted', 
<tt class="literal"><span class="pre">moderman</span></tt> has the attributes</p>
<blockquote>
<pre class="literal-block">
_HomoHabilis__attr:' - make tools' # inherited from HomoHabilis
_HomoSapiens__attr:' - make abstractions'# inherited from HomoSapiens
_HomoSapiensSapiens__attr: ' - make art' # inherited from HomoSapiensSapiens
</pre>
</blockquote>
<p>which origin is obvious, once one reminds the mangling mechanism associated
with private variables. The important point is that the trick would <em>not</em>
have worked for normal attributes. Had I used as variable name
'attr' instead of '__attr', the name would have been overridden: the only
attribute of 'HomoSapiensSapiens' would have been ' - make art'.</p>
<p>This example explains the advantages of private variables during inheritance:
they cannot be overridden. Using private name guarantees the absence of 
surprises due to inheritance. If a class B has only private variables,
deriving a class C from B cannot cause name clashes.</p>
<p>Private variables have a drawbacks, too. The most obvious disadvantages is
the fact that in order to customize private variables outside their 
defining class, one needs to pass explicitly the name of the class.</p>
<p>For instance we could not change an attribute with the syntax 
<tt class="literal"><span class="pre">HomoHabilis.With(__attr='</span> <span class="pre">-</span> <span class="pre">work</span> <span class="pre">the</span> <span class="pre">stone')</span></tt>, we must write the 
more verbose, error prone and redundant 
<tt class="literal"><span class="pre">HomoHabilis.With(_HomoHabilis__attr='</span> <span class="pre">-</span> <span class="pre">work</span> <span class="pre">the</span> <span class="pre">stone')</span></tt></p>
<p>A subtler drawback will be discussed in chapter 6.</p>
<blockquote>
<table class="footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id35" name="id34">[17]</a></td><td>In single inheritance hierarchies, <tt class="literal"><span class="pre">super</span></tt> can be dismissed
in favor of <tt class="literal"><span class="pre">__base__</span></tt>: for instance, 
<tt class="literal"><span class="pre">super(HomoSapiens,self).can()</span></tt> is equivalent to
<tt class="literal"><span class="pre">HomoSapiens.__base__.can(self)</span></tt>. Nevertheless, in view
of possible extensions to multiple inheritance, using <tt class="literal"><span class="pre">super</span></tt> is a
much preferable choice.</td></tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="section" id="the-sophistication-of-descriptors">
<h1><a class="toc-backref" href="#id90" name="the-sophistication-of-descriptors">THE SOPHISTICATION OF DESCRIPTORS</a></h1>
<p>Attribute descriptors are important metaprogramming tools that allows 
the user to customize the behavior of attributes in custom classes.
For instance, attribute descriptors (or descriptors for short) 
can be used as method wrappers, 
to modify or enhance methods (this is the case for the well
known staticmethods and classmethods attribute descriptors); they
can also be used as attribute wrappers, to change or restrict the access to 
attributes (this is the case for properties). Finally, descriptors 
allows the user to play with the resolution order of attributes: 
for instance, the <tt class="literal"><span class="pre">super</span></tt> built-in object used in (multiple) inheritance 
hierarchies, is implemented as an attribute descriptor.</p>
<p>In this chapter, I will show how the user can define its own attribute 
descriptors and I will give some example of useful things you can do with 
them (in particular to add tracing and timing capabilities).</p>
<div class="section" id="motivation">
<h2><a class="toc-backref" href="#id91" name="motivation">Motivation</a></h2>
<p>Attribute descriptors are a recent idea (they where first introduced in 
Python 2.2) nevertheless, under the hood, are everywhere in Python. It is 
a tribute to Guido's ability of hiding Python complications that
the average user can easily miss they existence.
If you need to do simple things, you can very well live without 
the knowledge of descriptors. On the other hand, if you need difficult 
things (such as tracing all the attribute access of your modules) 
attribute descriptors, allow you to perform 
impressive things. 
Let me start by showing why the knowledge of attribute descriptors is 
essential for any user seriously interested  in metaprogramming applications.
Suppose I  want to trace the methods of a clock:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import oopp
&gt;&gt;&gt; clock=oopp.Clock()
</pre>
</blockquote>
<p>This is easily done with the <tt class="literal"><span class="pre">with_tracer</span></tt> closure of chapter 2:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; oopp.wrapfunctions(clock,oopp.with_tracer)
&lt;oopp.Clock object at 0x4044c54c&gt;
&gt;&gt;&gt; clock.get_time()
[] Calling 'get_time' with arguments
(){} ...
-&gt; '.get_time' called with result: 19:55:07
'19:55:07'
</pre>
</blockquote>
<p>However, this approach fails if I try to trace the entire class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; oopp.wrapfunctions(oopp.Clock,oopp.with_tracer)
&lt;class 'oopp.Clock'&gt;
&gt;&gt;&gt; oopp.Clock.get_time() # error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 6, in ?
TypeError: unbound method _() must be called with Clock instance 
as first argument (got nothing instead)
</pre>
</blockquote>
<p>The reason is that <tt class="literal"><span class="pre">wrapfunctions</span></tt> sets the attributes of 'Clock'
by invoking <tt class="literal"><span class="pre">customize</span></tt>, which uses <tt class="literal"><span class="pre">setattr</span></tt>. This converts
'_' (i.e. the traced version of <tt class="literal"><span class="pre">get_time</span></tt>) in a regular method, not in 
a staticmethod!
In order to trace staticmethods, one has to understand the nature 
of attribute descriptors.</p>
</div>
<div class="section" id="functions-versus-methods">
<h2><a class="toc-backref" href="#id92" name="functions-versus-methods">Functions versus methods</a></h2>
<p>Attribute descriptors are essential for the implementation 
of one of the most basic Python features: the automatic conversion 
of functions in methods. As I already anticipated in chapter 1, there is 
a sort of magic when one writes <tt class="literal"><span class="pre">Clock.get_time=lambda</span> <span class="pre">self:</span> <span class="pre">get_time()</span></tt>
and Python automagically converts the right hand side, that is a
function, to a left hand side that is a (unbound) method. In order to 
understand this magic, one needs a better comprehension of the
relation between functions and methods.
Actually, this relationship is quite subtle 
and has no analogous in mainstream programming languages.
For instance, C is not OOP and has only functions, lacking the concept
of method, whereas Java (as other OOP languages) 
has no functions,  only methods.
C++ has functions and methods, but functions are completely
different from methods On the other hand, in Python, 
functions and methods can be transformed both ways.</p>
<p>To show how it works, let me start by defining a simple printing 
function:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

import __main__ # gives access to the __main__ namespace from the module

def prn(s):
    &quot;&quot;&quot;Given an evaluable string, print its value and its object reference.
    Notice that the evaluation is done in the __main__ dictionary.&quot;&quot;&quot;
    try: obj=eval(s,__main__.__dict__)
    except: print 'problems in evaluating',s
    else: print s,'=',obj,'at',hex(id(obj))

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Now, let me define a class with a method <tt class="literal"><span class="pre">m</span></tt> equals to the identity
function <tt class="literal"><span class="pre">f</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def f(x): &quot;Identity function&quot;; return x
...
&gt;&gt;&gt; class C(object):
...    m=f
...    print m #here m is the function f
&lt;function f at 0x401c2b1c&gt;
</pre>
</blockquote>
<p>We see that <em>inside</em> its defining class, <tt class="literal"><span class="pre">m</span></tt> coincides with the function 
<tt class="literal"><span class="pre">f</span></tt> (the object reference is the same):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; f
&lt;function f at 0x401c2b1c&gt;
</pre>
</blockquote>
<p>We may retrieve <tt class="literal"><span class="pre">m</span></tt> from <em>outside</em> the class via the class dictionary <a class="footnote-reference" href="#id34" id="id35" name="id35">[17]</a>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.__dict__['m']
&lt;function prn at 0x401c2b1c&gt;
</pre>
</blockquote>
<p>However, if we invoke <tt class="literal"><span class="pre">m</span></tt> with
the syntax <tt class="literal"><span class="pre">C.m</span></tt>, then it (magically) becomes a (unbound) method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.m #here m has become a method!
&lt;unbound method C.f&gt;
</pre>
</blockquote>
<p>But why it is so? How comes that in the second syntax the function 
<tt class="literal"><span class="pre">f</span></tt> is transformed in a (unbound) method? To answer that question, we have
to understand how attributes are really invoked in Python, i.e. via
attribute descriptors.</p>
</div>
<div class="section" id="methods-versus-functions">
<h2><a class="toc-backref" href="#id93" name="methods-versus-functions">Methods versus functions</a></h2>
<p>First of all, let me point out the differences between methods and
functions. Here, <tt class="literal"><span class="pre">C.m</span></tt> does <em>not</em> coincides with <tt class="literal"><span class="pre">C.__dict__['m']</span></tt>
i.e. <tt class="literal"><span class="pre">f</span></tt>, since its object reference is different:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import prn,attributes
&gt;&gt;&gt; prn('C.m')
C.m = &lt;unbound method C.prn&gt; at 0x81109b4
</pre>
</blockquote>
<p>The difference is clear since methods and functions have different attributes:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; attributes(f).keys()
['func_closure', 'func_dict', 'func_defaults', 'func_name', 
'func_code', 'func_doc', 'func_globals']
</pre>
</blockquote>
<p>whereas</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; attributes(C.m).keys()
['im_func', 'im_class', 'im_self']
</pre>
</blockquote>
<p>We discussed few of the functions attributes in the chapter
on functions. The instance method attributes are simpler: <tt class="literal"><span class="pre">im_self</span></tt> 
returns the object to which the method is attached,</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print C.m.im_self #unbound method, attached to the class
None
&gt;&gt;&gt; C().m.im_self #bound method, attached to C()
&lt;__main__.C object at 0x81bf4ec&gt; 
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">im_class</span></tt> returns the class to which the
method is attached</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.m.im_class #class of the unbound method
&lt;class '__main__.C'&gt;
&gt;&gt;&gt; C().m.im_class #class of the bound method,
&lt;class '__main__.C'&gt;
</pre>
</blockquote>
<p>and <tt class="literal"><span class="pre">im_func</span></tt> returns the function equivalent to
the method.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.m.im_func
&lt;function m at 0x8157f44&gt;
&gt;&gt;&gt; C().m.im_func # the same
&lt;function m at 0x8157f44&gt;
</pre>
</blockquote>
<p>As the reference manual states, calling 
<tt class="literal"><span class="pre">m(*args,**kw)</span></tt> is completely equivalent to calling 
<tt class="literal"><span class="pre">m.im_func(m.im_self,</span> <span class="pre">*args,**kw)</span></tt>&quot;.</p>
<p>As a general rule, an attribute descriptor is an object with a <tt class="literal"><span class="pre">__get__</span></tt> 
special method. The most used descriptors are the good old functions:
they have a <tt class="literal"><span class="pre">__get__</span></tt> special  method returning a <em>method-wrapper object</em></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; f.__get__
&lt;method-wrapper object at 0x815cdc4&gt;
</pre>
</blockquote>
<p>method-wrapper objects can be transformed in (both bound and unbound) methods:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; f.__get__(None,C)
&lt;unbound method C.f&gt;
&gt;&gt;&gt; f.__get__(C(),C)
&lt;bound method C.f of &lt;__main__.C object at 0x815cdc4&gt;&gt;
</pre>
</blockquote>
<p>The general calling syntax for method-wrapper objects is 
<tt class="literal"><span class="pre">.__get__(obj,cls=None)</span></tt>, where the first argument is an
instance object or None and the second (optional) argument is the class (or a
generic superclass) of the first one.</p>
<p>Now we see what happens when we use the syntax <tt class="literal"><span class="pre">C.m</span></tt>: Python interprets
this as a shortcut for <tt class="literal"><span class="pre">C.__dict['m'].__get__(None,C)</span></tt> (if <tt class="literal"><span class="pre">m</span></tt> is
in the 'C' dictionary, otherwise it looks for ancestor dictionaries). 
We may check that everything is correct by observing that
<tt class="literal"><span class="pre">f.__get__(None,C)</span></tt> has exactly the same object reference than <tt class="literal"><span class="pre">C.m</span></tt>,
therefore they are the same object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; hex(id(f.__get__(None,C))) # same as hex(id(C.m))
'0x811095c'
</pre>
</blockquote>
<p>The process works equally well for the syntax <tt class="literal"><span class="pre">getattr</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print getattr(C,'m'), hex(id(getattr(C,'m')))
&lt;unbound method C.f&gt; 0x811095c
</pre>
</blockquote>
<p>and for bound methods: if</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c=C()
</pre>
</blockquote>
<p>is an instance of the class C, then the syntax</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; getattr(c,'m') #same as c.m
&lt;bound method C.f of &lt;__main__.C object at 0x815cdc4&gt;&gt;
</pre>
</blockquote>
<p>is a shortcut for</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(c).__dict__['m'].__get__(c,C) # or f.__get__(c,C)
&lt;bound method C.f of &lt;__main__.C object at 0x815cdc4&gt;&gt;
</pre>
</blockquote>
<p>(notice that the object reference for <tt class="literal"><span class="pre">c.m</span></tt> and <tt class="literal"><span class="pre">f.__get__(c,C)</span></tt> is
the same, they are <em>exactly</em> the same object).</p>
<p>Both the unbound method C.m and the bound method c.m refer to the same 
object at hexadecimal address 0x811095c. This object is common to all other
instances of C:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c2=C()
&gt;&gt;&gt; print c2.m,hex(id(c2.m)) #always the same method
&lt;bound method C.m of &lt;__main__.C object at 0x815768c&gt;&gt; 0x811095c
</pre>
</blockquote>
<p>One can also omit the second argument:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c.m.__get__(c)
&lt;bound method ?.m of &lt;__main__.C object at 0x81597dc&gt;&gt;
</pre>
</blockquote>
<p>Finally, let me point out that methods are attribute descriptors too,
since they have a <tt class="literal"><span class="pre">__get__</span></tt> attribute returning a method-wrapper
object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.m.__get__
&lt;method-wrapper object at 0x815d51c&gt;
</pre>
</blockquote>
<p>Notice that this method wrapper is <em>not</em> the same than the <tt class="literal"><span class="pre">f.__get__</span></tt>
method wrapper.</p>
<blockquote>
<table class="footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id37" name="id36">[18]</a></td><td>If <tt class="literal"><span class="pre">C.__dict['m']</span></tt> is not defined, Python looks if <tt class="literal"><span class="pre">m</span></tt> is defined
in some ancestor of C. For instance if <cite>B</cite> is the base of <cite>C</cite>, it
looks in <tt class="literal"><span class="pre">B.__dict['m']</span></tt>, etc., by following the MRO.</td></tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="static-methods-and-class-methods">
<h2><a class="toc-backref" href="#id94" name="static-methods-and-class-methods">Static methods and class methods</a></h2>
<p>Whereas functions and methods are implicit attribute descriptors,
static methods and class methods are examples of explicit
descriptors. They allow to convert regular functions to 
specific descriptor objects. Let me show a trivial example. 
Given the identity function</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def f(x): return x
</pre>
</blockquote>
<p>we may convert it to a staticmethod object</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sm=staticmethod(f)
&gt;&gt;&gt; sm
&lt;staticmethod object at 0x4018a0a0&gt;
</pre>
</blockquote>
<p>or to a classmethod object</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cm=classmethod(f)
&gt;&gt;&gt; cm
&lt;classmethod object at 0x4018a0b0&gt;
</pre>
</blockquote>
<p>In both cases the <tt class="literal"><span class="pre">__get__</span></tt> special method returns a method-wrapper object</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sm.__get__
&lt;method-wrapper object at 0x401751ec&gt;
&gt;&gt;&gt; cm.__get__
&lt;method-wrapper object at 0x4017524c&gt;
</pre>
</blockquote>
<p>However the static method wrapper is quite different from the class
method wrapper. In the first case the wrapper returns a function:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sm.__get__(C(),C)
&lt;function f at 0x4027a8b4&gt;
&gt;&gt;&gt; sm.__get__(C())
&lt;function f at 0x4027a8b4&gt;
</pre>
</blockquote>
<p>in the second case it returns a method</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cm.__get__(C(),C)
&lt;bound method type.f of &lt;class '__main__.C'&gt;&gt;
</pre>
</blockquote>
<p>Let me discuss more in detail the static methods, first.</p>
<p>It is always possible to extract the function from the static method
via the syntaxes <tt class="literal"><span class="pre">sm.__get__(a)</span></tt> and <tt class="literal"><span class="pre">sm.__get__(a,b)</span></tt> with <em>ANY</em> valid
a and b, i.e. the result does not depend on a and b. This is correct,
since static methods are actually function that have nothing to do
with the class and the instances to which they are bound.</p>
<p>This behaviour of the method wrapper makes clear why the relation between 
methods and functions is inversed for static methods with respect to
regular methods:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class C(object):
...     s=staticmethod(lambda : None)
...     print s
...
&lt;staticmethod object at 0x8158ec8&gt;
</pre>
</blockquote>
<p>Static methods are non-trivial objects <em>inside</em> the class, whereas 
they are regular functions <em>outside</em> the class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.s
&lt;function &lt;lambda&gt; at 0x8158e7c&gt;
&gt;&gt;&gt; C().s
&lt;function &lt;lambda&gt; at 0x8158e7c&gt;
</pre>
</blockquote>
<p>The situation is different for classmethods: inside the class they
are non-trivial objects, just as static methods,</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class C(object):
...     cm=classmethod(lambda cls: None)
...     print cm
...
&lt;classmethod object at 0x8156100&gt;
</pre>
</blockquote>
<p>but outside the class they are methods bound to the class,</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c=C()
&gt;&gt;&gt; prn('c.cm') 
&lt;bound method type.&lt;lambda&gt; of &lt;class '__main__.C'&gt;&gt; 
0x811095c
</pre>
</blockquote>
<p>and not to the instance 'c'. The reason is that the <tt class="literal"><span class="pre">__get__</span></tt> wrapper method
can be invoked with the syntax  <tt class="literal"><span class="pre">__get__(a,cls)</span></tt> which 
is only sensitive to the second argument or with the syntax
<tt class="literal"><span class="pre">__get__(obj)</span></tt> which is only sensitive to the type of the first
argument:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cm.__get__('whatever',C) # the first argument is ignored
&lt;bound method type.f of &lt;class '__main__.C'&gt;&gt;
</pre>
</blockquote>
<p>sensitive to the type of 'whatever':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cm.__get__('whatever') # in Python 2.2 would give a serious error
&lt;bound method type.f of &lt;type 'str'&gt;&gt;
</pre>
</blockquote>
<p>Notice that the class method is actually bound to C's class, i.e.
to 'type'.</p>
<p>Just as regular methods (and differently
from static methods) classmethods have attributes <tt class="literal"><span class="pre">im_class</span></tt>, <tt class="literal"><span class="pre">im_func</span></tt>, 
and <tt class="literal"><span class="pre">im_self</span></tt>. In particular one can retrieve the function wrapped inside
the classmethod with</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; cm.__get__('whatever','whatever').im_func 
&lt;function f at 0x402c2534&gt;
</pre>
</blockquote>
<p>The difference with regular methods is that <tt class="literal"><span class="pre">im_class</span></tt> returns the
class of 'C' whereas <tt class="literal"><span class="pre">im_self</span></tt> returns 'C' itself.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.cm.im_self # a classmethod is attached to the class
&lt;class '__main__.C'&gt;
&gt;&gt;&gt; C.cm.im_class #the class of C
&lt;type 'type'&gt;
</pre>
</blockquote>
<p>Remark: Python 2.2.0 has a bug in classmethods (fixed in newer versions):
when the first argument of __get__ is None, then one must specify 
the second argument (otherwise segmentation fault :-()</p>
</div>
<div class="section" id="properties">
<h2><a class="toc-backref" href="#id95" name="properties">Properties</a></h2>
<p>Properties are a more general kind of attribute descriptors than 
staticmethods and classmethods, since their effect can be customized
trough arbitrary get/set/del functions. Let me give an example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def getp(self): return 'property' # get function
...
&gt;&gt;&gt; p=property(getp) # property object
&gt;&gt;&gt; p
&lt;property object at 0x815855c&gt;
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">p</span></tt> has a <tt class="literal"><span class="pre">__get__</span></tt> special method returning a method-wrapper
object, just as it happens for other descriptors:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; p.__get__
&lt;method-wrapper object at 0x8158a7c&gt;
</pre>
</blockquote>
<p>The difference is that</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; p.__get__(None,type(p))
&lt;property object at 0x4017016c&gt;
&gt;&gt;&gt; p.__get__('whatever')
'property'
&gt;&gt;&gt; p.__get__('whatever','whatever')
'property'
</pre>
</blockquote>
<p>As for static methods, the <tt class="literal"><span class="pre">__get__</span></tt> method wrapper is independent from
its arguments, unless the first one is None: in such a case it returns
the property object, in all other circumstances it returns the result
of <tt class="literal"><span class="pre">getp</span></tt>. This explains the behavior</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class C(object): p=p
&gt;&gt;&gt; C.p
&lt;property object at 0x815855c&gt;
&gt;&gt;&gt; C().p
'property'
</pre>
</blockquote>
<p>Properties are a dangerous feature, since they change the semantics
of the language. This means that apparently trivial operations can have 
any kind of side effects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def get(self):return 'You gave me the order to destroy your hard disk!!'
&gt;&gt;&gt; class C(object): x=property(get) 
&gt;&gt;&gt; C().x
'You gave me the order to destroy your hard disk!!'
</pre>
</blockquote>
<p>Invoking 'C.x' could very well invoke an external program who is going
to do anything! It is up to the programmer to not abuse properties.
The same is true for user defined attribute descriptors.</p>
<p>There are situations in which they are quite handy, however. For
instance, properties can be used to trace the access data attributes.
This can be especially useful during debugging, or for logging
purposes.</p>
<p>Notice that this approach has the problem that now data attributes cannot 
no more be called trough their class, but only though their instances.
Moreover properties do not work well with <tt class="literal"><span class="pre">super</span></tt> in cooperative
methods.</p>
</div>
<div class="section" id="user-defined-attribute-descriptors">
<h2><a class="toc-backref" href="#id96" name="user-defined-attribute-descriptors">User-defined attribute descriptors</a></h2>
<p>As we have seen, there are plenty of predefined attribute descriptors,
such as staticmethods, classmethods and properties (the built-in
<tt class="literal"><span class="pre">super</span></tt> is also an attribute descriptor which, for sake of
convenience, will be discussed in the next section).
In addition to them, the user can also define customized attribute 
descriptors, simply trough classes with a <tt class="literal"><span class="pre">__get__</span></tt> special method.
Let me give an example:</p>
<blockquote>
<pre class="literal-block">
#&lt;simpledescr.py&gt;

class ChattyAttr(object):
    &quot;&quot;&quot;Chatty descriptor class; descriptor objects are intended to be 
    used as attributes in other classes&quot;&quot;&quot;
    def __get__(self, obj, cls=None):
        binding=obj is not None
        if  binding:
            return 'You are binding %s to %s' % (self,obj)
        else:
            return 'Calling %s from %s' % (self,cls)

class C(object):
    d=ChattyAttr()

c=C()

print c.d # &lt;=&gt; type(c).__dict__['d'].__get__(c,type(c))
print C.d # &lt;=&gt; C.__dict__['d'].__get__(None,C)

#&lt;/simpledescr.py&gt;
</pre>
</blockquote>
<p>with output:</p>
<blockquote>
<pre class="literal-block">
You are binding &lt;ChattyAttr object at 0x401bc1cc&gt; to 
&lt;C object at 0x401bc2ec&gt;
Calling &lt;ChattyAttr object at 0x401bc1cc&gt; from &lt;class 'C'&gt;
</pre>
</blockquote>
<p>Invoking a method with the syntax <tt class="literal"><span class="pre">C.d</span></tt> or <tt class="literal"><span class="pre">c.d</span></tt> involves calling
<tt class="literal"><span class="pre">__get__</span></tt>. The <tt class="literal"><span class="pre">__get__</span></tt> signature is fixed: it is
`` __get__=__get__(self,obj,cls=None)``, since the notation
<tt class="literal"><span class="pre">self.descr_attr</span></tt> automatically passes <tt class="literal"><span class="pre">self</span></tt> and <tt class="literal"><span class="pre">self.__class__</span></tt> to 
<tt class="literal"><span class="pre">__get__</span></tt>.</p>
<p>Custom descriptors can be used to restrict the access to objects in a
more general way than trough properties. For instance, suppose one
wants to raise an error if a given attribute 'a' is accessed, both
from the class and from the instance: a property cannot help here,
since it works only from the instance. The solution is the following
custom descriptor:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class AccessError(object):
    &quot;&quot;&quot;Descriptor raising an AttributeError when the attribute is 
    accessed&quot;&quot;&quot; #could be done with a property
    def __init__(self,errormessage):
        self.msg=errormessage
    def __get__(self,obj,cls=None):
        raise AttributeError(self.msg)

#&lt;/oopp.py&gt;

&gt;&gt;&gt; from oopp import AccessError
&gt;&gt;&gt; class C(object):
...    a=AccessError(&quot;'a' cannot be accessed&quot;)
&gt;&gt;&gt; c=C()
&gt;&gt;&gt; c.a #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;oopp.py&quot;, line 313, in __get__
    raise AttributeError(self.msg)
AttributeError: 'a' cannot be accessed
&gt;&gt;&gt; C.a #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;oopp.py&quot;, line 313, in __get__
    raise AttributeError(self.msg)
AttributeError: 'a' cannot be accessed
</pre>
</blockquote>
<p>It is always possibile to convert plain attributes (i.e. attributes
without a &quot;__get__&quot; method) to descriptor objects:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class convert2descriptor(object):
    &quot;&quot;&quot;To all practical means, this class acts as a function that, given an
    object, adds to it a __get__ method if it is not already there. The 
    added __get__ method is trivial and simply returns the original object, 
    independently from obj and cls.&quot;&quot;&quot;
    def __new__(cls,a):
        if hasattr(a,&quot;__get__&quot;): # do nothing
            return a # a is already a descriptor
        else: # creates a trivial attribute descriptor
            cls.a=a
            return object.__new__(cls)
    def __get__(self,obj,cls=None):
        &quot;Returns self.a independently from obj and cls&quot;
        return self.a

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>This example also shows the magic of <tt class="literal"><span class="pre">__new__</span></tt>, that allows to use a
class as a function. The output of 'convert2descriptor(a)' can be both 
an instance of 'convert2descriptor' (in this case 'convert2descriptor' acts as 
a normal class, i.e. as an object factory) or 'a' itself 
(if 'a' is already a descriptor): in this case 'convert2descriptor' acts 
as a function.</p>
<p>For instance, a string is converted to a descriptor</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import convert2descriptor
&gt;&gt;&gt; a2=convert2descriptor('a')
&gt;&gt;&gt; a2
&lt;oopp.convert2descriptor object at 0x4017506c&gt;
&gt;&gt;&gt; a2.__get__('whatever')
'a'
</pre>
</blockquote>
<p>whereas a function is untouched:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def f(): pass
&gt;&gt;&gt; f2=convert2descriptor(f) # does nothing
&gt;&gt;&gt; f2
&lt;function f at 0x4019110c&gt;
</pre>
</blockquote>
</div>
<div class="section" id="data-descriptors">
<h2><a class="toc-backref" href="#id97" name="data-descriptors">Data descriptors</a></h2>
<p>It is also possible to specify a <tt class="literal"><span class="pre">__set__</span></tt> method (descriptors
with a <tt class="literal"><span class="pre">__set__</span></tt> method are typically data descriptors) with
the signature <tt class="literal"><span class="pre">__set__(self,obj,value)</span></tt> as in the following
example:</p>
<blockquote>
<pre class="literal-block">
#&lt;datadescr.py&gt;

class DataDescriptor(object):
    value=None
    def __get__(self, obj, cls=None):
        if obj is None: obj=cls
        print &quot;Getting&quot;,obj,&quot;value =&quot;,self.value
        return self.value
    def __set__(self, obj, value):
        self.value=value
        print &quot;Setting&quot;,obj,&quot;value =&quot;,value

class C(object):
    d=DataDescriptor()

c=C()

c.d=1 #calls C.__dict__['d'].__set__(c,1)
c.d   #calls C.__dict__['d'].__get__(c,C)
C.d   #calls C.__dict__['d'].__get__(None,C)
C.d=0 #does *not* call __set__
print &quot;C.d =&quot;,C.d

#&lt;/datadescr.py&gt;
</pre>
</blockquote>
<p>With output:</p>
<blockquote>
<pre class="literal-block">
Setting &lt;C object at 0x401bc1ec&gt; value = 1
Getting &lt;C object at 0x401bc42c&gt; value = 1
Getting &lt;class 'C'&gt; value = 1      
C.d = 0
</pre>
</blockquote>
<p>With this knowledge, we may now reconsider the clock example given 
in chapter 3. #NO!??</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import oopp
&gt;&gt;&gt; class Clock(object): pass
&gt;&gt;&gt; myclock=Clock()
...
&gt;&gt;&gt; myclock.get_time=oopp.get_time # this is a function
&gt;&gt;&gt; Clock.get_time=lambda self : oopp.get_time() # this is a method 
</pre>
</blockquote>
<p>In this example, <tt class="literal"><span class="pre">myclock.get_time</span></tt>, which is attached to the <tt class="literal"><span class="pre">myclock</span></tt> 
object, is a function, whereas <tt class="literal"><span class="pre">Clock.get_time</span></tt>, which is attached to 
the <tt class="literal"><span class="pre">Clock</span></tt> class is a method. We may also check this by using the <tt class="literal"><span class="pre">type</span></tt> 
function:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(myclock.get_time)
&lt;type 'function'&gt;
</pre>
</blockquote>
<p>whereas</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(Clock.get_time) 
&lt;type 'instance method'&gt;
</pre>
</blockquote>
<p>It must be remarked that user-defined attribute descriptors, just as
properties, allow to arbitrarily change the semantics of the language
and should be used with care.</p>
</div>
<div class="section" id="the-super-attribute-descriptor">
<h2><a class="toc-backref" href="#id98" name="the-super-attribute-descriptor">The <tt class="literal"><span class="pre">super</span></tt> attribute descriptor</a></h2>
<p>super has also a second form, where it is more used as a descriptor.</p>
<p><tt class="literal"><span class="pre">super</span></tt> objects are attribute descriptors, too, with a <tt class="literal"><span class="pre">__get__</span></tt>
method returning a method-wrapper object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(C,C()).__get__
&lt;method-wrapper object at 0x8161074&gt;
</pre>
</blockquote>
<p>Here I give some example of acceptable call:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(C,C()).__get__('whatever')
&lt;super: &lt;class 'C'&gt;, &lt;C object&gt;&gt;
&gt;&gt;&gt; super(C,C()).__get__('whatever','whatever')
&lt;super: &lt;class 'C'&gt;, &lt;C object&gt;&gt;
</pre>
</blockquote>
<p>Unfortunately, for the time being 
(i.e. for Python 2.3), the <tt class="literal"><span class="pre">super</span></tt> mechanism  has various limitations. 
To show the issues, let me start by  considering the following base class:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class ExampleBaseClass(PrettyPrinted):
    &quot;&quot;&quot;Contains a regular method 'm', a staticmethod 's', a classmethod 
    'c', a property 'p' and a data attribute 'd'.&quot;&quot;&quot;
    m=lambda self: 'regular method of %s' % self
    s=staticmethod(lambda : 'staticmethod')
    c=classmethod(lambda cls: 'classmethod of %s' % cls)
    p=property(lambda self: 'property of %s' % self)
    a=AccessError('Expected error')
    d='data'

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Now, let me derive a new class C from ExampleBaseClass:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import ExampleBaseClass
&gt;&gt;&gt; class C(ExampleBaseClass): pass
&gt;&gt;&gt; c=C()
</pre>
</blockquote>
<p>Ideally, we would like to retrieve the methods and attributes of 
ExampleBaseClass from C, by using the <tt class="literal"><span class="pre">super</span></tt> mechanism.</p>
<ol class="arabic simple">
<li>We see that <tt class="literal"><span class="pre">super</span></tt> works without problems for regular methods, 
staticmethods and classmethods:</li>
</ol>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(C,c).m()
'regular method of &lt;C&gt;'
&gt;&gt;&gt; super(C,c).s()
'staticmethod'
&gt;&gt;&gt; super(C,c).c()
&quot;classmethod of &lt;class '__main__.C'&gt;&quot;
</pre>
</blockquote>
<p>It also works for user defined attribute descriptors:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(C,c).a # access error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;oopp.py&quot;, line 340, in __get__
    raise AttributeError(self.msg)
AttributeError: Expected error
</pre>
</blockquote>
<p>and for properties (only for Python 2.3+):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ExampleBaseClass.p
&lt;property object at 0x81b30fc&gt;
</pre>
</blockquote>
<p>In Python 2.2 one would get an error, instead</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(C,c).p #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: 'super' object has no attribute 'p'
</pre>
</blockquote>
<p>3. Moreover, certain attributes of the superclass, such as its
<tt class="literal"><span class="pre">__name__</span></tt>, cannot be retrieved:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ExampleBaseClass.__name__
'ExampleBaseClass'
&gt;&gt;&gt; super(C,c).__name__ #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: 'super' object has no attribute '__name__'
</pre>
</blockquote>
<ol class="arabic simple" start="4">
<li>There is no direct way to retrieve the methods of the super-superclass 
(i.e. the grandmother class, if you wish) or in general the furthest 
ancestors, since <tt class="literal"><span class="pre">super</span></tt> does not chain.</li>
<li>Finally, there are some subtle issues with the <tt class="literal"><span class="pre">super(cls)</span></tt> syntax:</li>
</ol>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(C).m #(2) error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: 'super' object has no attribute 'm'
</pre>
</blockquote>
<p>means <tt class="literal"><span class="pre">super(C).__get__(None,C)</span></tt>, but only 
<tt class="literal"><span class="pre">super(C).__get__(c,C).m==super(C,c)</span></tt> works.</p>
<blockquote>
<blockquote>
On the other hand,</blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(C).__init__  #(1) 
&lt;built-in method __init__ of type object at 0x80e6fc0&gt;
&gt;&gt;&gt; super(C).__new__  #(1) 
&lt;built-in method __init__ of type object at 0x80e6fc0&gt;
</pre>
<blockquote>
seems to work, whereas in reality does not. The reason is that since 
<tt class="literal"><span class="pre">super</span></tt> objects are instances 
of <tt class="literal"><span class="pre">object</span></tt>, they inherit object's methods, and in particular 
<tt class="literal"><span class="pre">__init__</span></tt> ; therefore the <tt class="literal"><span class="pre">__init__</span></tt> method in (1) is <em>not</em> 
the <tt class="literal"><span class="pre">ExampleBaseClass.__init__</span></tt> method. The point is that <tt class="literal"><span class="pre">super</span></tt> 
objects are attribute descriptors and not references to the superclass.</blockquote>
</blockquote>
<p>Probably, in future versions of Python the <tt class="literal"><span class="pre">super</span></tt> mechanism will be 
improved. However, for the time being, one must provide a workaround for 
dealing with these issues. This will be discussed in the next chapter.</p>
</div>
<div class="section" id="method-wrappers">
<h2><a class="toc-backref" href="#id99" name="method-wrappers">Method wrappers</a></h2>
<p>One of the most typical applications of attribute descriptors is their
usage as <em>method wrappers</em>.</p>
<p>Suppose, for instance, one wants to add tracing capabilities to 
the methods of a class for debugging purposes. The problem
can be solved with a custom descriptor class:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

import inspect

class wrappedmethod(Customizable):
    &quot;&quot;&quot;Customizable method factory intended for derivation.
    The wrapper method is overridden in the children.&quot;&quot;&quot;

    logfile=sys.stdout # default
    namespace='' # default

    def __new__(cls,meth): # meth is a descriptor
        if isinstance(meth,FunctionType):
            kind=0 # regular method
            func=meth
        elif isinstance(meth,staticmethod):
            kind=1 # static method
            func=meth.__get__('whatever')
        elif isinstance(meth,classmethod):
            kind=2 # class method
            func=meth.__get__('whatever','whatever').im_func 
        elif isinstance(meth,wrappedmethod): # already wrapped
            return meth # do nothing
        elif inspect.ismethoddescriptor(meth):
            kind=0; func=meth # for many builtin methods 
        else:
            return meth # do nothing
        self=super(wrappedmethod,cls).__new__(cls)
        self.kind=kind; self.func=func # pre-initialize
        return self

    def __init__(self,meth): # meth not used
        self.logfile=self.logfile # default values
        self.namespace=self.namespace # copy the current

    def __get__(self,obj,cls): # closure 
        def _(*args,**kw):
            if obj is None: o=() # unbound method call
            else: o=(obj,) # bound method call
            allargs=[o,(),(cls,)][self.kind]+args 
            return self.wrapper()(*allargs,**kw)
        return _ # the wrapped function
        # allargs is the only nontrivial line in _; it adds
        # 0 - obj if meth is a regular method
        # 1 - nothing if meth is a static method
        # 2 - cls if meth is a class method

    def wrapper(self): return self.func # do nothing, to be overridden

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>This class is intended for derivation: the wrapper method has to be overridden
in the children in order to introduce the wanted feature. If I want to 
implement the capability of tracing methods, I can reuse the <tt class="literal"><span class="pre">with_tracer</span></tt>
closure introduced in chapter 2:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class tracedmethod(wrappedmethod):
    def wrapper(self):
        return with_tracer(self.func,self.namespace,self.logfile)
        
#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Nothing prevents me from introducing timing features by reusing the 
<tt class="literal"><span class="pre">with_timer</span></tt> closure:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class timedmethod(wrappedmethod):
    iterations=1 # additional default parameter

    def __init__(self,meth):
        super(timedmethod,self).__init__(self,meth)
        self.iterations=self.iterations # copy

    def wrapper(self):
        return with_timer(self.func,self.namespace,
                          self.iterations,self.logfile)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here there is an example of usage:</p>
<p>The dictionary of wrapped functions is then built from an utility function</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def wrap(obj,wrapped,condition=lambda k,v: True, err=None):
    &quot;Retrieves obj's dictionary and wraps it&quot;
    if isinstance(obj,dict): # obj is a dictionary 
        dic=obj
    else: 
        dic=getattr(obj,'__dict__',{}).copy() # avoids dictproxy objects
        if not dic: dic=attributes(obj) # for simple objects
    wrapped.namespace=getattr(obj,'__name__','')
    for name,attr in dic.iteritems(): # modify dic
        if condition(name,attr): dic[name]=wrapped(attr)
    if not isinstance(obj,dict): # modify obj
        customize(obj,err,**dic) 

#&lt;/oopp.py&gt;
</pre>
<pre class="literal-block">
#&lt;tracingmethods.py&gt;

from oopp import *

class C(object): 
    &quot;Class with traced methods&quot;

    def f(self): return self 
    f=tracedmethod(f)

    g=staticmethod(lambda:None)
    g=tracedmethod(g)

    h=classmethod(do_nothing)
    h=tracedmethod(h)

c=C()

#unbound calls
C.f(c) 
C.g()
C.h()

#bound calls
c.f()  
c.g()
c.h()

#&lt;/tracingmethods.py&gt;
</pre>
</blockquote>
<p>Output:</p>
<blockquote>
<pre class="literal-block">
[C] Calling 'f' with arguments
(&lt;C object at 0x402042cc&gt;,){} ...
-&gt; 'C.f' called with result: &lt;C object at 0x402042cc&gt;

[C] Calling '&lt;lambda&gt;' with arguments
(){} ...
-&gt; 'C.&lt;lambda&gt;' called with result: None

[C] Calling 'do_nothing' with arguments
(&lt;class 'C'&gt;,){} ...
-&gt; 'C.do_nothing' called with result: None

[C] Calling 'f' with arguments
(&lt;C object at 0x402042cc&gt;,){} ...
-&gt; 'C.f' called with result: &lt;C object at 0x402042cc&gt;

[C] Calling '&lt;lambda&gt;' with arguments
(){} ...
-&gt; 'C.&lt;lambda&gt;' called with result: None

[C] Calling 'do_nothing' with arguments
(&lt;class 'C'&gt;,){} ...
-&gt; 'C.do_nothing' called with result: None
</pre>
</blockquote>
<p>The approach in 'tracingmethods.py' works, but it is far from
being elegant, since I had to explicitly wrap each method in the
class by hand.</p>
<p>Both problems can be avoided.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; wrap(Clock,tracedmethod)
&gt;&gt;&gt; Clock.get_time()
[Clock] Calling 'get_time' with arguments
(){} ...
-&gt; 'Clock.get_time' called with result: 21:56:52
'21:56:52'
</pre>
</blockquote>
</div>
</div>
<div class="section" id="the-subtleties-of-multiple-inheritance">
<h1><a class="toc-backref" href="#id100" name="the-subtleties-of-multiple-inheritance">THE SUBTLETIES OF MULTIPLE INHERITANCE</a></h1>
<p>In chapter 4 we introduced the concept of multiple inheritance and discussed
its simplest applications in absence of name collisions. When with methods
with different names are derived from different classes multiple inheritance
is pretty trivial. However, all kind of subtilites comes in presence of name 
clashing, i.e. when we multiply inherits different methods defined in different
classes but with the <em>same</em> name.
In order to understand what happens in this situation, it is essential to 
understand the concept of Method Resolution Order (MRO). For reader's
convenience, I collect in this chapter some of the information
reported in <a class="reference" href="http://www.python.org/2.3/mro.html">http://www.python.org/2.3/mro.html</a>.</p>
<div class="section" id="a-little-bit-of-history-why-python-2-3-has-changed-the-mro">
<h2><a class="toc-backref" href="#id101" name="a-little-bit-of-history-why-python-2-3-has-changed-the-mro">A little bit of history: why Python 2.3 has changed the MRO</a></h2>
<p>Everything started with a post by Samuele Pedroni to the Python
development mailing list <a class="footnote-reference" href="#id36" id="id37" name="id37">[18]</a>.  In his post, Samuele showed that the
Python 2.2 method resolution order is not monotonic and he proposed to
replace it with the C3 method resolution order.  Guido agreed with his
arguments and therefore now Python 2.3 uses C3.  The C3 method itself
has nothing to do with Python, since it was invented by people working
on Dylan and it is described in a paper intended for lispers <a class="footnote-reference" href="#id40" id="id38" name="id38">[19]</a>.  The
present paper gives a (hopefully) readable discussion of the C3
algorithm for Pythonistas who want to understand the reasons for the
change.</p>
<p>First of all, let me point out that what I am going to say only applies
to the <em>new style classes</em> introduced in Python 2.2:  <em>classic classes</em>
maintain their old method resolution order, depth first and then left to
right.  Therefore, there is no breaking of old code for classic classes;
and even if in principle there could be breaking of code for Python 2.2
new style classes, in practice the cases in which the C3 resolution
order differs from the Python 2.2 method resolution order are so rare
that no real breaking of code is expected.  Therefore: don't be scared!</p>
<p>Moreover, unless you make strong use of multiple inheritance and you
have non-trivial hierarchies, you don't need to understand the C3
algorithm, and you can easily skip this paper.  On the other hand, if
you really want to know how multiple inheritance works, then this paper
is for you.  The good news is that things are not as complicated as you
might expect.</p>
<p>Let me begin with some basic definitions.</p>
<ol class="arabic simple">
<li>Given a class C in a complicated multiple inheritance hierarchy, it
is a non-trivial task to specify the order in which methods are
overridden, i.e. to specify the order of the ancestors of C.</li>
<li>The list of the ancestors of a class C, including the class itself,
ordered from the nearest ancestor to the furthest, is called the
class precedence list or the <em>linearization</em> of C.</li>
<li>The <em>Method Resolution Order</em> (MRO) is the set of rules that
construct the linearization.  In the Python literature, the idiom
&quot;the MRO of C&quot; is also used as a synonymous for the linearization of
the class C.</li>
<li>For instance, in the case of single inheritance hierarchy, if C is a
subclass of C1, and C1 is a subclass of C2, then the linearization of
C is simply the list [C, C1 , C2].  However, with multiple
inheritance hierarchies, it is more difficult to construct a
linearization that respects <em>local precedence ordering</em> and
<em>monotonicity</em>.</li>
<li>I will discuss the local precedence ordering later, but I can give
the definition of monotonicity here.  A MRO is monotonic when the
following is true:  <em>if C1 precedes C2 in the linearization of C,
then C1 precedes C2 in the linearization of any subclass of C</em>.
Otherwise, the innocuous operation of deriving a new class could
change the resolution order of methods, potentially introducing very
subtle bugs.  Examples where this happens will be shown later.</li>
<li>Not all classes admit a linearization.  There are cases, in
complicated hierarchies, where it is not possible to derive a class
such that its linearization respects all the desired properties.</li>
</ol>
<p>Here I give an example of this situation. Consider the hierarchy</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; O = object
&gt;&gt;&gt; class X(O): pass
&gt;&gt;&gt; class Y(O): pass
&gt;&gt;&gt; class A(X,Y): pass
&gt;&gt;&gt; class B(Y,X): pass
</pre>
</blockquote>
<p>which can be represented with the following inheritance graph, where I
have denoted with O the <tt class="literal"><span class="pre">object</span></tt> class, which is the beginning of any
hierarchy for new style classes:</p>
<blockquote>
<pre class="literal-block">
 -----------
|           |
|    O      |
|  /   \    |
 - X    Y  /
   |  / | /
   | /  |/
   A    B
   \   /
     ?
</pre>
</blockquote>
<p>In this case, it is not possible to derive a new class C from A and B,
since X precedes Y in A, but Y precedes X in B, therefore the method
resolution order would be ambiguous in C.</p>
<p>Python 2.3 raises an exception in this situation (TypeError:  MRO
conflict among bases Y, X) forbidding the naive programmer from creating
ambiguous hierarchies.  Python 2.2 instead does not raise an exception,
but chooses an <em>ad hoc</em> ordering (CABXYO in this case).</p>
</div>
<div class="section" id="the-c3-method-resolution-order">
<h2><a class="toc-backref" href="#id102" name="the-c3-method-resolution-order">The C3 Method Resolution Order</a></h2>
<p>Let me introduce a few simple notations which will be useful for the
following discussion.  I will use the shortcut notation</p>
<blockquote>
C1 C2 ... CN</blockquote>
<p>to indicate the list of classes [C1, C2, ... , CN].</p>
<p>The <em>head</em> of the list is its first element:</p>
<blockquote>
head = C1</blockquote>
<p>whereas the <em>tail</em> is the rest of the list:</p>
<blockquote>
tail = C2 ... CN.</blockquote>
<p>I shall also use the notation</p>
<blockquote>
C + (C1 C2 ... CN) = C C1 C2 ... CN</blockquote>
<p>to denote the sum of the lists [C] + [C1, C2, ... ,CN].</p>
<p>Now I can explain how the MRO works in Python 2.3.</p>
<p>Consider a class C in a multiple inheritance hierarchy, with C
inheriting from the base classes B1, B2, ...  , BN.  We want to compute
the linearization L[C] of the class C. In order to do that, we need the
concept of <em>merging</em> lists, since the rule says that</p>
<blockquote>
<em>the linearization of C is the sum of C plus the merge of a) the
linearizations of the parents and b) the list of the parents.</em></blockquote>
<p>In symbolic notation:</p>
<blockquote>
L[C(B1 ... BN)] = C + merge(L[B1] ... L[BN], B1 ... BN)</blockquote>
<p>How is the merge computed? The rule is the following:</p>
<blockquote>
<em>take the head of the first list, i.e L[B1][0]; if this head is not in
the tail of any of the other lists, then add it to the linearization
of C and remove it from the lists in the merge, otherwise look at the
head of the next list and take it, if it is a good head.  Then repeat
the operation until all the class are removed or it is impossible to
find good heads.  In this case, it is impossible to construct the
merge, Python 2.3 will refuse to create the class C and will raise an
exception.</em></blockquote>
<p>This prescription ensures that the merge operation <em>preserves</em> the
ordering, if the ordering can be preserved.  On the other hand, if the
order cannot be preserved (as in the example of serious order
disagreement discussed above) then the merge cannot be computed.</p>
<p>The computation of the merge is trivial if:</p>
<ol class="arabic">
<li><p class="first">C is the <tt class="literal"><span class="pre">object</span></tt> class, which has no parents; in this case its
linearization coincides with itself,</p>
<blockquote>
<p>L[object] = object.</p>
</blockquote>
</li>
<li><p class="first">C has only one parent (single inheritance); in this case</p>
<blockquote>
<p>L[C(B)] = C + merge(L[B],B) = C + L[B]</p>
</blockquote>
</li>
</ol>
<p>However, in the case of multiple inheritance things are more cumbersome
and I don't expect you can understand the rule without a couple of
examples ;-)</p>
</div>
<div class="section" id="examples">
<h2><a class="toc-backref" href="#id103" name="examples">Examples</a></h2>
<p>First example. Consider the following hierarchy:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; O = object
&gt;&gt;&gt; class F(O): pass
&gt;&gt;&gt; class E(O): pass
&gt;&gt;&gt; class D(O): pass
&gt;&gt;&gt; class C(D,F): pass
&gt;&gt;&gt; class B(D,E): pass
&gt;&gt;&gt; class A(B,C): pass
</pre>
</blockquote>
<p>In this case the inheritance graph can be drawn as</p>
<blockquote>
<pre class="literal-block">
                          6
                         ---
Level 3                 | O |                  (more general)
                      /  ---  \
                     /    |    \                      |
                    /     |     \                     |
                   /      |      \                    |
                  ---    ---    ---                   |
Level 2        3 | D | 4| E |  | F | 5                |
                  ---    ---    ---                   |
                   \  \ _ /       |                   |
                    \    / \ _    |                   |
                     \  /      \  |                   |
                      ---      ---                    |
Level 1            1 | B |    | C | 2                 |
                      ---      ---                    |
                        \      /                      |
                         \    /                      \ /
                           ---
Level 0                 0 | A |                (more specialized)
                           ---
</pre>
</blockquote>
<p>The linearizations of O,D,E and F are trivial:</p>
<blockquote>
<pre class="literal-block">
L[O] = O
L[D] = D O
L[E] = E O
L[F] = F O
</pre>
</blockquote>
<p>The linearization of B can be computed as</p>
<blockquote>
<pre class="literal-block">
L[B] = B + merge(DO, EO, DE)
</pre>
</blockquote>
<p>We see that D is a good head, therefore we take it and we are reduced to
compute merge(O,EO,E).  Now O is not a good head, since it is in the
tail of the sequence EO.  In this case the rule says that we have to
skip to the next sequence.  Then we see that E is a good head; we take
it and we are reduced to compute merge(O,O) which gives O. Therefore</p>
<blockquote>
<pre class="literal-block">
L[B] =  B D E O
</pre>
</blockquote>
<p>Using the same procedure one finds:</p>
<blockquote>
<pre class="literal-block">
L[C] = C + merge(DO,FO,DF)
     = C + D + merge(O,FO,F)
     = C + D + F + merge(O,O)
     = C D F O
</pre>
</blockquote>
<p>Now we can compute:</p>
<blockquote>
<pre class="literal-block">
L[A] = A + merge(BDEO,CDFO,BC)
     = A + B + merge(DEO,CDFO,C)
     = A + B + C + merge(DEO,DFO)
     = A + B + C + D + merge(EO,FO)
     = A + B + C + D + E + merge(O,FO)
     = A + B + C + D + E + F + merge(O,O)
     = A B C D E F O
</pre>
</blockquote>
<p>In this example, the linearization is ordered in a pretty nice way
according to the inheritance level, in the sense that lower levels (i.e.
more specialized classes) have higher precedence (see the inheritance
graph).  However, this is not the general case.</p>
<p>I leave as an exercise for the reader to compute the linearization for
my second example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; O = object
&gt;&gt;&gt; class F(O): pass
&gt;&gt;&gt; class E(O): pass
&gt;&gt;&gt; class D(O): pass
&gt;&gt;&gt; class C(D,F): pass
&gt;&gt;&gt; class B(E,D): pass
&gt;&gt;&gt; class A(B,C): pass
</pre>
</blockquote>
<p>The only difference with the previous example is the change B(D,E) --&gt;
B(E,D); however even such a little modification completely changes the
ordering of the hierarchy</p>
<blockquote>
<pre class="literal-block">
                           6
                          ---
Level 3                  | O |
                       /  ---  \
                      /    |    \
                     /     |     \
                    /      |      \
                  ---     ---    ---
Level 2        2 | E | 4 | D |  | F | 5
                  ---     ---    ---
                   \      / \     /
                    \    /   \   /
                     \  /     \ /
                      ---     ---
Level 1            1 | B |   | C | 3
                      ---     ---
                       \       /
                        \     /
                          ---
Level 0                0 | A |
                          ---
</pre>
</blockquote>
<p>Notice that the class E, which is in the second level of the hierarchy,
precedes the class C, which is in the first level of the hierarchy, i.e.
E is more specialized than C, even if it is in a higher level.</p>
<p>A lazy programmer can obtain the MRO directly from Python 2.2, since in
this case it coincides with the Python 2.3 linearization.  It is enough
to invoke the .mro() method of class A:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; A.mro()
(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;,
&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;,
&lt;type 'object'&gt;)
</pre>
</blockquote>
<p>Finally, let me consider the example discussed in the first section,
involving a serious order disagreement.  In this case, it is
straightforward to compute the linearizations of O, X, Y, A and B:</p>
<blockquote>
<pre class="literal-block">
L[O] = 0
L[X] = X O
L[Y] = Y O
L[A] = A X Y O
L[B] = B Y X O
</pre>
</blockquote>
<p>However, it is impossible to compute the linearization for a class C
that inherits from A and B:</p>
<blockquote>
<pre class="literal-block">
L[C] = C + merge(AXYO, BYXO, AB)
     = C + A + merge(XYO, BYXO, B)
     = C + A + B + merge(XYO, YXO)
</pre>
</blockquote>
<p>At this point we cannot merge the lists XYO and YXO, since X is in the
tail of YXO whereas Y is in the tail of XYO:  therefore there are no
good heads and the C3 algorithm stops.  Python 2.3 raises an error and
refuses to create the class C.</p>
</div>
<div class="section" id="bad-method-resolution-orders">
<h2><a class="toc-backref" href="#id104" name="bad-method-resolution-orders">Bad Method Resolution Orders</a></h2>
<p>A MRO is <em>bad</em> when it breaks such fundamental properties as local
precedence ordering and monotonicity.  In this section, I will show
that both the MRO for classic classes and the MRO for new style classes
in Python 2.2 are bad.</p>
<p>It is easier to start with the local precedence ordering.  Consider the
following example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; F=type('Food',(),{'remember2buy':'spam'})
&gt;&gt;&gt; E=type('Eggs',(F,),{'remember2buy':'eggs'})
&gt;&gt;&gt; G=type('GoodFood',(F,E),{}) #under Python 2.3 this is an error
</pre>
</blockquote>
<p>with inheritance diagram</p>
<blockquote>
<pre class="literal-block">
             O
             |
(buy spam)   F
             | \
             | E   (buy eggs)
             | /
             G

      (buy eggs or spam ?)
</pre>
</blockquote>
<p>We see that class G inherits from F and E, with F <em>before</em> E:  therefore
we would expect the attribute <em>G.remember2buy</em> to be inherited by
<em>F.rembermer2buy</em> and not by <em>E.remember2buy</em>:  nevertheless Python 2.2
gives</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; G.remember2buy #under Python 2.3 this is an error
'eggs'
</pre>
</blockquote>
<p>This is a breaking of local precedence ordering since the order in the
local precedence list, i.e. the list of the parents of G, is not
preserved in the Python 2.2 linearization of G:</p>
<blockquote>
<pre class="literal-block">
L[G,P22]= G E F object   # F *follows* E
</pre>
</blockquote>
<p>One could argue that the reason why F follows E in the Python 2.2
linearization is that F is less specialized than E, since F is the
superclass of E; nevertheless the breaking of local precedence ordering
is quite non-intuitive and error prone.  This is particularly true since
it is a different from old style classes:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class F: remember2buy='spam'
&gt;&gt;&gt; class E(F): remember2buy='eggs'
&gt;&gt;&gt; class G(F,E): pass
&gt;&gt;&gt; G.remember2buy
'spam'
</pre>
</blockquote>
<p>In this case the MRO is GFEF and the local precedence ordering is
preserved.</p>
<p>As a general rule, hierarchies such as the previous one should be
avoided, since it is unclear if F should override E or viceversa.
Python 2.3 solves the ambiguity by raising an exception in the creation
of class G, effectively stopping the programmer from generating
ambiguous hierarchies.  The reason for that is that the C3 algorithm
fails when the merge</p>
<blockquote>
<pre class="literal-block">
merge(FO,EFO,FE)
</pre>
</blockquote>
<p>cannot be computed, because F is in the tail of EFO and E is in the tail
of FE.</p>
<p>The real solution is to design a non-ambiguous hierarchy, i.e. to derive
G from E and F (the more specific first) and not from F and E; in this
case the MRO is GEF without any doubt.</p>
<blockquote>
<pre class="literal-block">
           O
           |
           F (spam)
         / |
(eggs)   E |
         \ |
           G
             (eggs, no doubt)
</pre>
</blockquote>
<p>Python 2.3 forces the programmer to write good hierarchies (or, at
least, less error-prone ones).</p>
<p>On a related note, let me point out that the Python 2.3 algorithm is
smart enough to recognize obvious mistakes, as the duplication of
classes in the list of parents:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class A(object): pass
&gt;&gt;&gt; class C(A,A): pass # error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: duplicate base class A
</pre>
</blockquote>
<p>Python 2.2 (both for classic classes and new style classes) in this
situation, would not raise any exception.</p>
<p>Finally, I would like to point out two lessons we have learned from this
example:</p>
<ol class="arabic simple">
<li>despite the name, the MRO determines the resolution order of
attributes, not only of methods;</li>
<li>the default food for Pythonistas is spam !  (but you already knew
that ;-)</li>
</ol>
<p>Having discussed the issue of local precedence ordering, let me now
consider the issue of monotonicity.  My goal is to show that neither the
MRO for classic classes nor that for Python 2.2 new style classes is
monotonic.</p>
<p>To prove that the MRO for classic classes is non-monotonic is rather
trivial, it is enough to look at the diamond diagram:</p>
<blockquote>
<pre class="literal-block">
   C
  / \
 /   \
A     B
 \   /
  \ /
   D
</pre>
</blockquote>
<p>One easily discerns the inconsistency:</p>
<blockquote>
<pre class="literal-block">
L[B,P21] = B C        # B precedes C : B's methods win
L[D,P21] = D A C B C  # B follows C  : C's methods win!
</pre>
</blockquote>
<p>On the other hand, there are no problems with the Python 2.2 and 2.3
MROs, they give both</p>
<blockquote>
<pre class="literal-block">
L[D] = D A B C
</pre>
</blockquote>
<p>Guido points out in his essay <a class="footnote-reference" href="#id41" id="id39" name="id39">[20]</a> that the classic MRO is not so bad in
practice, since one can typically avoids diamonds for classic classes.
But all new style classes inherit from object, therefore diamonds are
unavoidable and inconsistencies shows up in every multiple inheritance
graph.</p>
<p>The MRO of Python 2.2 makes breaking monotonicity difficult, but not
impossible.  The following example, originally provided by Samuele
Pedroni, shows that the MRO of Python 2.2 is non-monotonic:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class A(object): pass
&gt;&gt;&gt; class B(object): pass
&gt;&gt;&gt; class C(object): pass
&gt;&gt;&gt; class D(object): pass
&gt;&gt;&gt; class E(object): pass
&gt;&gt;&gt; class K1(A,B,C): pass
&gt;&gt;&gt; class K2(D,B,E): pass
&gt;&gt;&gt; class K3(D,A):   pass
&gt;&gt;&gt; class Z(K1,K2,K3): pass
</pre>
</blockquote>
<p>Here are the linearizations according to the C3 MRO (the reader should
verify these linearizations as an exercise and draw the inheritance
diagram ;-)</p>
<blockquote>
<pre class="literal-block">
L[A] = A O
L[B] = B O
L[C] = C O
L[D] = D O
L[E] = E O
L[K1]= K1 A B C O
L[K2]= K2 D B E O
L[K3]= K3 D A O
L[Z] = Z K1 K2 K3 D A B C E O
</pre>
</blockquote>
<p>Python 2.2 gives exactly the same linearizations for A, B, C, D, E, K1,
K2 and K3, but a different linearization for Z:</p>
<blockquote>
<pre class="literal-block">
L[Z,P22] = Z K1 K3 A K2 D B C E O
</pre>
</blockquote>
<p>It is clear that this linearization is <em>wrong</em>, since A comes before D
whereas in the linearization of K3 A comes <em>after</em> D. In other words, in
K3 methods derived by D override methods derived by A, but in Z, which
still is a subclass of K3, methods derived by A override methods derived
by D!  This is a violation of monotonicity.  Moreover, the Python 2.2
linearization of Z is also inconsistent with local precedence ordering,
since the local precedence list of the class Z is [K1, K2, K3] (K2
precedes K3), whereas in the linearization of Z K2 <em>follows</em> K3.  These
problems explain why the 2.2 rule has been dismissed in favor of the C3
rule.</p>
<table class="footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38" name="id40">[19]</a></td><td>The thread on python-dev started by Samuele Pedroni:
<a class="reference" href="http://mail.python.org/pipermail/python-dev/2002-October/029035.html">http://mail.python.org/pipermail/python-dev/2002-October/029035.html</a></td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39" name="id41">[20]</a></td><td>The paper <em>A Monotonic Superclass Linearization for Dylan</em>:
<a class="reference" href="http://www.webcom.com/haahr/dylan/linearization-oopsla96.html">http://www.webcom.com/haahr/dylan/linearization-oopsla96.html</a></td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id44" name="id42">[21]</a></td><td>Guido van Rossum's essay, <em>Unifying types and classes in Python 2.2</em>:
<a class="reference" href="http://www.python.org/2.2.2/descrintro.html">http://www.python.org/2.2.2/descrintro.html</a></td></tr>
</tbody>
</table>
<table class="footnote" frame="void" id="id43" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id47" name="id43">[22]</a></td><td>The (in)famous book on metaclasses, <em>Putting Metaclasses to Work</em>:
Ira R. Forman, Scott Danforth, Addison-Wesley 1999 (out of print,
but probably still available on <a class="reference" href="http://www.amazon.com">http://www.amazon.com</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="understanding-the-method-resolution-order">
<h2><a class="toc-backref" href="#id105" name="understanding-the-method-resolution-order">Understanding the Method Resolution Order</a></h2>
<p>The MRO of any given (new style) Python class is given
by the special attribute <tt class="literal"><span class="pre">__mro__</span></tt>. Notice that since
Python is an extremely dynamic language it is possible
to delete and to generate whole classes at run time, therefore the MRO
is a dynamic concept. For instance, let me show how it is possibile to 
remove a class from my 
paleoanthropological hierarchy: for instance I can
replace the last class 'HomoSapiensSapiens' with 'HomoSapiensNeardenthalensis'
(changing a class in the middle of the hierarchy would be more difficult). The
following lines do the job dynamically:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; del HomoSapiensSapiens
&gt;&gt;&gt; class HomoSapiensNeardenthalensis(HomoSapiens):
...     def can(self):
...         super(self.__this,self).can()
...         print &quot; - make something&quot;
&gt;&gt;&gt; reflective(HomoSapiensNeardenthalensis)
&gt;&gt;&gt; HomoSapiensNeardenthalensis().can()
HomoSapiensNeardenthalensis can:
 - make tools
 - make abstractions
 - make something
</pre>
</blockquote>
<p>In this case the MRO of 'HomoSapiensNeardenthalensis', i.e. the list of
all its ancestors, is</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; HomoSapiensNeardenthalensis.__mro__
[&lt;class '__main__.HomoSapiensNeardenthalensis'&gt;,&lt;class 'oopp.HomoSapiens'&gt;, 
 &lt;class 'oopp.HomoHabilis'&gt;, &lt;class 'oopp.Homo'&gt;, 
 &lt;class 'oopp.PrettyPrinted'&gt;, &lt;class 'oopp.object'&gt;]
</pre>
</blockquote>
<p>The <tt class="literal"><span class="pre">__mro__</span></tt> attribute gives the <em>linearization</em> of the class, i.e. the
ordered list of its ancestors, starting from the class itself and ending
with object. The linearization of a class is essential in order to specify
the resolution order of methods and attributes, i.e. the Method Resolution
Order (MRO). In the case of single inheritance hierarchies, such the
paleonthropological example, the MRO is pretty obvious; on the contrary
it is a quite non-trivial concept in the case of multiple inheritance 
hierarchies.</p>
<p>For instance, let me reconsider my first example of multiple inheritance,
the <tt class="literal"><span class="pre">NonInstantiableClock</span></tt> class, inheriting from 'NonInstantiable' and 
'Clock'. I may represent the hierarchy with the following inheritance graph:</p>
<blockquote>
<pre class="literal-block">
          --   object   -- 
        /     (__new__)    \
       /                    \
      /                      \
   Clock                NonInstantiable
(get_time)                 (__new__)
     \                         /
      \                       /
       \                     /
        \                   /
         \                 /
         NonInstantiableClock   
          (get_time,__new__)
</pre>
</blockquote>
<p>The class <tt class="literal"><span class="pre">Clock</span></tt> define a <tt class="literal"><span class="pre">get_time</span></tt> method, whereas the class 
<tt class="literal"><span class="pre">NonInstantiable</span></tt> overrides the <tt class="literal"><span class="pre">__new__</span></tt> method of the <tt class="literal"><span class="pre">object</span></tt> class; 
the class <tt class="literal"><span class="pre">NonInstantiableClock</span></tt> inherits <tt class="literal"><span class="pre">get_time</span></tt> from 'Clock' and 
<tt class="literal"><span class="pre">__new__</span></tt> from 'NonInstantiable'.</p>
<p>The linearization of 'NonInstantiableClock' is</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; NonInstantiableClock.mro()
[&lt;class '__main__.NonInstantiableClock'&gt;, &lt;class 'oopp.Clock'&gt;, 
 &lt;class 'oopp.NonInstantiable'&gt;, &lt;type 'object'&gt;]
</pre>
</blockquote>
<p>In particular, since 'NonInstantiable' precedes 'object', its <tt class="literal"><span class="pre">__new__</span></tt> 
method overrides the <tt class="literal"><span class="pre">object</span></tt> new method. However, with the MRO used before
Python 2.2, the linearization would have been <tt class="literal"><span class="pre">NonInstantiableClock,</span> <span class="pre">Clock,</span> 
<span class="pre">object,</span> <span class="pre">NonInstantiable,</span> <span class="pre">object</span></tt> and the <tt class="literal"><span class="pre">__new__</span></tt> method of object would 
have (hypothetically, of course, since before Python 2.2 there was not 
<tt class="literal"><span class="pre">__new__</span></tt> method! ;-)  overridden the <tt class="literal"><span class="pre">__new__</span></tt>
method of <tt class="literal"><span class="pre">NonInstantiable</span></tt>, therefore <tt class="literal"><span class="pre">NonInstantiableClock</span></tt> would 
have lost the property of being non-instantiable!</p>
<p>This simple example shows that the choice of a correct Method Resolution 
Order is far from being obvious in general multiple inheritance hierarchies. 
After a false start in Python 2.2, (with a MRO failing in some subtle cases)
Python 2.3 decided to adopt the so-called C3 MRO, invented by people working 
on Dylan (even if Dylan itself uses the MRO of Common Lisp CLOS). Since this 
is quite a technical matter, I defer the interested reader to appendix 2 
for a full discussion of the C3 algorithm.</p>
<p>Here, I prefer to point out how the built-in
<tt class="literal"><span class="pre">super</span></tt> object works in multiple inheritance situations. To this aim, it 
is convenient to define an utility function that retrieves the ancestors
of a given class with respect to the MRO of one of its subclasses:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def ancestor(C,S=None):
    &quot;&quot;&quot;Returns the ancestors of the first argument with respect to the 
    MRO of the second argument. If the second argument is None, then 
    returns the MRO of the first argument.&quot;&quot;&quot;
    if C is object:
        raise TypeError(&quot;There is no superclass of object&quot;)
    elif S is None or S is C:
        return list(C.__mro__)
    elif issubclass(S,C): # typical case
        mro=list(S.__mro__)
        return mro[mro.index(C):] # compute the ancestors from the MRO of S
    else:
        raise TypeError(&quot;S must be a subclass of C&quot;)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Let me show how the function <tt class="literal"><span class="pre">ancestor</span></tt> works. 
Consider the class <tt class="literal"><span class="pre">Clock</span></tt> in isolation: then 
its direct superclass, i.e. the first ancestor, is <tt class="literal"><span class="pre">object</span></tt>,</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; ancestor(Clock)[1]
&lt;type 'object'&gt;
</pre>
</blockquote>
<p>therefore <tt class="literal"><span class="pre">super(Clock).__new__</span></tt> retrieves the <tt class="literal"><span class="pre">object.__new__</span></tt> method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(Clock).__new__
&lt;built-in method __new__ of type object at 0x80e6fc0&gt;
</pre>
</blockquote>
<p>Consider now the <tt class="literal"><span class="pre">Clock</span></tt> class together with its subclass 
<tt class="literal"><span class="pre">NonInstantiableClock</span></tt>:
in this case the first ancestor of <tt class="literal"><span class="pre">Clock</span></tt>, <em>with respect to the MRO of 
'NonInstantiableClock'</em> is <tt class="literal"><span class="pre">NonInstantiable</span></tt></p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ancestor(Clock,NonInstantiableClock)[1] 
&lt;class 'oopp.NonInstantiable'&gt;
</pre>
</blockquote>
<p>Therefore <tt class="literal"><span class="pre">super(Clock,NonInstantiableClock).__new__</span></tt> retrieves the 
<tt class="literal"><span class="pre">NonInstantiable.__new__</span></tt> method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(Clock,NonInstantiableClock).__new__
&lt;function __new__ at 0x81b293c&gt;
&gt;&gt;&gt; NonInstantiable.__new__
&lt;function __new__ at 0x81b293c&gt;
</pre>
</blockquote>
<p>It must be pointed out that <tt class="literal"><span class="pre">super(C,S)</span></tt> is equivalent but not the same 
than <tt class="literal"><span class="pre">ancestor(C,S)[1]</span></tt>, since it does not return the superclass: 
it returns a super object, instead:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(Clock,NonInstantiableClock)
&lt;super: &lt;class 'Clock'&gt;, &lt;type object&gt;&gt;
</pre>
<p>#&lt;oopp.py&gt;</p>
<p>#class Super(super):
#    def __init__(self,C,S=None):
#        super(Super,self).__init__(C,S)
#        self.__name__=&quot;Super(%s)&quot; % C.__name__</p>
<p>#&lt;/oopp.py&gt;</p>
</blockquote>
<p>Finally, there is little quirk of super:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class C(PrettyPrinted): pass
&gt;&gt;&gt; s=super(C,C())
&gt;&gt;&gt; s.__str__()
</pre>
</blockquote>
<p>but</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str(s) # idem for print s
&quot;&lt;super: &lt;class 'C'&gt;, &lt;C object&gt;&gt;&quot;
</pre>
</blockquote>
<p>Idem for non-pre-existing methods:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class D(list): pass
...
&gt;&gt;&gt; s=super(D,D())
&gt;&gt;&gt; s.__len__()
0
&gt;&gt;&gt; len(s) #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: len() of unsized object
</pre>
</blockquote>
<p>The same problem comes with <tt class="literal"><span class="pre">__getattr__</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class E(object):
...     def __getattr__(self,name):
...             if name=='__len__': return lambda:0
...
&gt;&gt;&gt; e=E()
&gt;&gt;&gt; e.__len__()
0
&gt;&gt;&gt; len(e) # error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: len() of unsized object
</pre>
</blockquote>
</div>
<div class="section" id="counting-instances">
<h2><a class="toc-backref" href="#id106" name="counting-instances">Counting instances</a></h2>
<blockquote>
<pre class="line-block">
<em>Everything should be built top-down, except the first time.</em>
-- Alan Perlis
</pre>
</blockquote>
<p>Multiple inheritance adds a step further to the bottom-up philosophy and
it makes appealing the idea of creating classes with the only 
purpose of being derived. Whereas in the top-down approach one starts
with full featured standalone classes, to be further refined, in the
mix-in approach one starts with bare bone classes, providing very simple 
or even trivial features, with the purpose of providing 
basic reusable components in multiple inheritance hierarchies.
At the very end, the idea is to generate a library of <em>mixin</em> classes, to be
composed with other classes. We already saw a couple of examples of
mixin classes: 'NonInstantiable' and 'Customizable'. In this paragraph
I will show three other examples: 'WithCounter','Singleton' and
'AvoidDuplication'.</p>
<p>A common requirement for a class is the ability to count the number of its
instances. This is a quite easy problem: it is enough to increments a counter 
each time an instance of that class is initialized. However, this idea can
be implemented in the wrong way. i.e. naively one could implement
counting capabilities in a class without such capabilities by modifying the
<tt class="literal"><span class="pre">__init__</span></tt> method explicitly in the original source code. 
A better alternative is to follow the bottom-up approach and to implement 
the counting feature in a separate mix-in class: then the feature can be 
added to the original class via multiple inheritance, without touching 
the source.
Moreover, the counter class becomes a reusable components that can be
useful for other problems, too. In order to use the mix-in approach, the 
<tt class="literal"><span class="pre">__new__</span></tt> method of the counter class must me cooperative, and preferably
via an anonymous super call.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class WithCounter(object): 
    &quot;&quot;&quot;Mixin class counting the total number of its instances and storing 
     it in the class attribute counter.&quot;&quot;&quot;

    counter=0 # class attribute (or static attribute in C++/Java terms)
 
    def __new__(cls,*args,**kw):
        cls.counter+=1 # increments the class attribute
        return super(cls.__this,cls).__new__(cls,*args,**kw)  
        #anonymous cooperative call to the superclass's method __new__

reflective(WithCounter)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Each time an instance of 'WithCounter' is initialized, the counter 'count' is
incremented and when 'WithCounter' is composed trough multiple inheritance, 
its '__new__'  method cooperatively invokes the <tt class="literal"><span class="pre">__new__</span></tt> method 
of the other components.</p>
<p>For instance, I can use 'WithCounter' to implement a 'Singleton', i.e. 
a class that can have only one instance. This kind of classes can be
obtained as follows:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Singleton(WithCounter):
    &quot;If you inherit from me, you can only have one instance&quot;
    def __new__(cls,*args,**kw):
        if cls.counter==0: #first call
            cls.instance=super(cls.__this,cls).__new__(cls,*args,**kw)
        return cls.instance

reflective(Singleton)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>As an application, I can create a 
class <tt class="literal"><span class="pre">SingleClock</span></tt> that inherits from <tt class="literal"><span class="pre">Clock</span></tt> 
<em>and</em> from <tt class="literal"><span class="pre">Singleton</span></tt>. This means that <tt class="literal"><span class="pre">SingleClock</span></tt> is both a 
'Clock' and a 'Singleton', i.e. there can be only a clock:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Clock,Singleton
&gt;&gt;&gt; class SingleClock(Clock,Singleton): pass
...
&gt;&gt;&gt; clock1=SingleClock()
&gt;&gt;&gt; clock2=SingleClock()
&gt;&gt;&gt; clock1 is clock2
True
</pre>
</blockquote>
<p>Instantiating many clocks is apparently possible (i.e. no error
message is given) but you always obtain the same instance. This makes
sense, since there is only one time on the system and a single
clock is enough.</p>
<p>A variation of the 'Singleton' is a class that generates a new
instance only when a certain condition is satisfied. Suppose for instance
one has a 'Disk' class, to be instantiated with the syntax 
<tt class="literal"><span class="pre">Disk(xpos,ypos,radius)</span></tt>.
It is clear that two disks with the same radius and the same position in
the cartesian plane, are essentially the same disk (assuming there are no
additional attributes such as the color). Therefore it is a vaste of memory
to instantiate two separate objects to describe the same disk. To solve
this problem, one possibility is to store in a list the calling arguments.
When it is time to instanciate a new objects with arguments args = xpos,ypos,
radius, Python should check if a disk with these arguments has already
been instanciated: in this case that disk should be returned, not a new
one. This logic can be elegantly implemented in a mix-in class such as the 
following (compare with the <tt class="literal"><span class="pre">withmemory</span></tt> wrapper in chapter 2):</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class AvoidDuplication(object):
    def __new__(cls,*args,**kw):
        return super(cls.__this,cls).__new__(cls,*args,**kw) 
    __new__=withmemory(__new__) # collects the calls in __new__.result

reflective(AvoidDuplication)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Notice that 'AvoidDuplication' is introduced with the only purpose of
giving its functionality to 'Disk': in order to reach this goal, it is enough 
to derive 'Disk' from this class and our previously
introduced 'GeometricFigure' class by writing something like</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; class Disk(GeometricFigure,AvoidDuplication): 
...     def __init__(self,xpos,ypos,radius):
...         return super(Disk,self).__init__('(x-x0)**2+(y-y0)**2 &lt;= r**2', 
...                                          x0=xpos,y0=ypos,r=radius)
</pre>
</blockquote>
<p>Now, if we create a disk</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c1=Disk(0,0,10) #creates a disk of radius 10
</pre>
</blockquote>
<p>it is easy enough to check that trying to instantiate a new disk with the
<em>same</em> arguments return the old disk:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c2=Disk(0,0,10) #returns the *same* old disk
&gt;&gt;&gt; c1 is c2
True
</pre>
</blockquote>
<p>Here, everything works, because through the 
cooperative <tt class="literal"><span class="pre">super</span></tt> mechanism, <tt class="literal"><span class="pre">Disk.__init__</span></tt> calls 
<tt class="literal"><span class="pre">AvoidDuplication.__init__</span></tt> that calls <tt class="literal"><span class="pre">GeometricFigure.__init__</span></tt> 
that in turns initialize the disk. Inverting the order of
'AvoidDuplication' and 'GeometricFigure' would case a disaster, since
<tt class="literal"><span class="pre">GeometricFigure.__init__</span></tt> would override <tt class="literal"><span class="pre">AvoidDuplication.__init__</span></tt>.</p>
<p>Alternatively, one could use the object factory 'Makeobj' implemented in 
chapter 3:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class NonDuplicatedFigure(GeometricFigure,AvoidDuplication): pass
&gt;&gt;&gt; makedisk=Makeobj(NonDuplicatedFigure,'(x-x0)**2/4+(y-y0)**2 &lt;= r**2')
&gt;&gt;&gt; disk1=makedisk(x0=38,y0=7,r=5)
&gt;&gt;&gt; disk2=makedisk(x0=38,y0=7,r=5)
&gt;&gt;&gt; disk1 is disk2
True
</pre>
</blockquote>
<p>Remark: it is interesting to notice that the previous approach would not work
for keyword arguments, directly, since dictionary are unhashable.</p>
</div>
<div class="section" id="the-pizza-shop-example">
<h2><a class="toc-backref" href="#id107" name="the-pizza-shop-example">The pizza-shop example</a></h2>
<p>Now it is time to give a non-trivial example of multiple inheritance with
cooperative and non-cooperative classes. The point is that multiple 
inheritance can easily leads to complicated hierarchies: where the
resolution order of methods is far from being obvious and actually
can give bad surprises.</p>
<p>To explain the issue, let me extend the program for the pizza-shop owner of
chapter 4, by following the bottom-up approach and using anonymous
cooperative super calls.
In this approach, one starts from the simplest thing. 
It is clear that the pizza-shop owner has interest in recording all the 
pizzas he sell. 
To this aim, he needs a class providing logging capabilities: 
each time a new instance is created, its features are stored in a log file. In
order to count the total number of instances, 'WithLogger' must derive from
the 'WithCounter' class. In order to have a nicely printed message,
'WithLogger' must derive from 'PrettyPrinted'. Finally, 
since 'WithLogger' must be a general purpose 
class that I will reuse in other problem as a mixin class, it must be 
cooperative. 'WithLogger' can be implemented as follows:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class WithLogger(WithCounter,PrettyPrinted):
    &quot;&quot;&quot;WithLogger inherits from WithCounter the 'count' class attribute; 
    moreover it inherits '__str__' from PrettyPrinted&quot;&quot;&quot;
    logfile=sys.stdout #default
    verboselog=False #default
    def __init__(self,*args,**kw): 
        super(self.__this,self).__init__(*args,**kw) # cooperative
        dic=attributes(self) # non-special attributes dictionary
        print &gt;&gt; self.logfile,'*'*77
        print &gt;&gt; self.logfile, time.asctime()
        print &gt;&gt; self.logfile, &quot;%s. Created %s&quot; % (type(self).counter,self)
        if self.verboselog:
            print &gt;&gt; self.logfile,&quot;with accessibile non-special attributes:&quot;
            if not dic: print &gt;&gt; self.logfile,&quot;&lt;NOTHING&gt;&quot;,
            else: print &gt;&gt; self.logfile, pretty(dic)

reflective(WithLogger)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here I could well use <tt class="literal"><span class="pre">super(self.__this,self).__init__(*args,**kw)</span></tt> 
instead of <tt class="literal"><span class="pre">super(self.__this,self).__init__(*args,**kw)</span></tt>, nevertheless 
the standard <tt class="literal"><span class="pre">super</span></tt> works in this case and I can use it with better 
performances.
Thanks to the power of multiple inheritance, we may give logging features
to the 'CustomizablePizza' class defined in chapter 4 
with just one line of code:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; class Pizza(WithLogger,CustomizablePizza):
...     &quot;Notice, WithLogger is before CustomizablePizza&quot;
&gt;&gt;&gt; Pizza.With(toppinglist=['tomato'])('small')
****************************************************************************
Sat Feb 22 14:54:44 2003
1. Created &lt;Pizza&gt;
&lt;__main__.Pizza object at 0x816927c&gt;
</pre>
</blockquote>
<p>It is also possible to have a more verbose output:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Pizza.With(verboselog=True)
&lt;class '__main__.Pizza'&gt;
&gt;&gt;&gt; Pizza('large')
****************************************************************************
Sat Feb 22 14:59:51 2003
1. Created &lt;Pizza&gt;
with accessibile non-special attributes: 
With = &lt;bound method type.customized of &lt;class '__main__.Pizza'&gt;&gt;
baseprice = 1
count = 2
formatstring = %s
logfile = &lt;open file '&lt;stdout&gt;', mode 'w' at 0x402c2058&gt;
price = &lt;bound method Pizza.price of &lt;__main__.Pizza object at 0x402f6c8c&gt;&gt;
size = large
sizefactor = {'small': 1, 'large': 3, 'medium': 2}
topping_unit_price = 0.5
toppinglist = ['tomato']
toppings_price = &lt;bound method Pizza.toppings_price of 
  &lt;__main__.Pizza object at 0x402f6c8c&gt;&gt;
verboselog = True
with = &lt;bound method Pizza.customized of 
&lt;__main__.Pizza object at 0x402f6c8c&gt;&gt;
&lt;__main__.Pizza object at 0x401ce7ac&gt;
</pre>
</blockquote>
<p>However, there is a problem here, since the output is '&lt;Pizza&gt;' and
not the nice 'large pizza with tomato, cost $ 4.5' that we would
expect from a child of 'CustomizablePizza'. The solution to the
puzzle is given by the MRO:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Pizza.mro()
[&lt;class '__main__.Pizza'&gt;, &lt;class 'oopp.WithLogger'&gt;, 
 &lt;class 'oopp.WithCounter'&gt;, &lt;class 'oopp.PrettyPrinted'&gt;,
 &lt;class 'oopp.CustomizablePizza'&gt;, &lt;class 'oopp.GenericPizza'&gt;, 
 &lt;class 'oopp.Customizable'&gt;,  &lt;type 'object'&gt;]
</pre>
</blockquote>
<p>The inheritance graph is rather complicated:</p>
<blockquote>
<pre class="literal-block">
                          object  7

                       /     /   \     \
                     /      /     \      \
                   /       /       \       \
                 /        /         \        \
               /         /           \         \
             /          /             \          \
           /           /               \           \
         /            /                 \            \
       /             /                   \             \
2  WithCounter   PrettyPrinted 3    GenericPizza 5  Customizable 6
  (__new__)    (__str__,__init__)      (__str__)       /              
      \            /                       /        /    
       \          /                       /      /         
        \        /                       /    /
         \      /                       /  /
          \    /            CustomizablePizza  4
           \  /                      /       
   1     WithLogger                /
         (__init__)              /        
              \                /
               \             /
                \          /
                 \       /
                  \    /

                  Pizza  O
</pre>
</blockquote>
<p>As we see, the precedence in the resolution of methods is far from being 
trivial. It is denoted in the graph with numbers
from 0 to 7: first the methods of 'Pizza' (level 0), then the methods of 
'WithLogger' (level 1), then the methods of 'WithCounter' (level 2),  then 
the methods of 'PrettyPrinted' (level 3), then the methods of
'CustomizablePizza' (level 4), then the methods of 'GenericPizza' (level 5),
then the level of 'Customizable' (level 6), finally the 'object' methods 
(level 7).</p>
<p>The reason why the MRO is so, can be understood by studying 
appendix 1.</p>
<p>We see that the <tt class="literal"><span class="pre">__init__</span></tt> methods of 'WithLogger' and 
the <tt class="literal"><span class="pre">__new__</span></tt> method of 'WithCounter' are cooperative. 
<tt class="literal"><span class="pre">WithLogger.__init__</span></tt> 
calls <tt class="literal"><span class="pre">WithCounter.__init__</span></tt> that is
inherited from <tt class="literal"><span class="pre">CustomizablePizza.__init__</span></tt> which is not cooperative, 
but this is not dangerous since <tt class="literal"><span class="pre">CustomizablePizza.__init__</span></tt> does not need 
to call any other <tt class="literal"><span class="pre">__init__</span></tt>.</p>
<p>However, <tt class="literal"><span class="pre">PrettyPrinted.__str__</span></tt> and <tt class="literal"><span class="pre">GenericPizza.__str__</span></tt> are not
cooperative and since 'PrettyPrinted' precedes 'GenericPizza', the
<tt class="literal"><span class="pre">GenericPizza.__str__</span></tt> method is overridden, which is bad.</p>
<p>If  <tt class="literal"><span class="pre">WithLogger.__init__</span></tt>  and <tt class="literal"><span class="pre">WithCounter.__new__</span></tt> were not 
cooperative, they would therefore badly breaking the program.</p>
<p>The message is: when you inherit from both cooperative and non-cooperative
classes, put cooperative classes first. The will be fair and will not
blindly override methods of the non-cooperative classes.</p>
<p>With multiple inheritance you can reuse old code a lot,
however the price to pay, is to have a non-trivial hierarchy. If from
the beginning we knew that 'Pizza' was needing a 'WithLogger', 
a 'WithCounter' and the
ability to be 'Customizable' we could have put everything in an unique
class. The problem is that in real life one never knows ;) 
Fortunately, Python dynamism allows to correct design mistakes</p>
<p>Remark: in all text books about inheritance, the authors always stress
that inheritance should be used as a &quot;is-a&quot; relation, not
and &quot;has-a&quot; relation. In spite of this fact, I have decided to implement
the concept of having a logger (or a counter) via a mixin class. One 
should not blindly believe text books ;)</p>
</div>
<div class="section" id="fixing-wrong-hierarchies">
<h2><a class="toc-backref" href="#id108" name="fixing-wrong-hierarchies">Fixing wrong hierarchies</a></h2>
<p>A typical metaprogramming technique, is the run-time modification of classes.
As I said in a previous chapter, this feature can confuse the programmer and 
should not be abused (in particular it should not be used as a replacement 
of inheritance!); nevertheless, there applications where the ability of 
modifying classes at run time is invaluable: for instance, 
it can be used to correct design mistakes.</p>
<p>In this case we would like the <tt class="literal"><span class="pre">__str__</span> <span class="pre">method</span></tt> of 'PrettyPrinted' to be
overridden by <tt class="literal"><span class="pre">GenericPizza.__str__</span></tt>. Naively, this can be solved by
putting 'WithLogger' after 'GenericPizza'. Unfortunately, doing so 
would cause <tt class="literal"><span class="pre">GenericPizza.__init__</span></tt> to override <tt class="literal"><span class="pre">WithLogger.__init__</span></tt>,
therefore by loosing logging capabilitiesr, unless countermeasures
are taken.</p>
<p>A valid countermeasure could be to replace the non-cooperative
<tt class="literal"><span class="pre">GenericPizza.__init__</span></tt> with a cooperative one. This can miraculously
done at run time in few lines of code:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def coop_init(self,size): # cooperative __init__ for GenericPizza
    self.size=size
    super(self._GenericPizza__this,self).__init__(size)

GenericPizza.__init__=coop_init # replace the old __init__

reflective(GenericPizza) # define GenericPizza.__this

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Notice the usage of the fully qualified private attribute
<tt class="literal"><span class="pre">self._GenericPizza__this</span></tt> inside <tt class="literal"><span class="pre">coop_init</span></tt>: since this function 
is defined outside any class, the automatica mangling mechanism cannot 
work and has to be implemented by hand. Notice also that 
<tt class="literal"><span class="pre">super(self._GenericPizza__this,self)</span></tt> could be replaced by
<tt class="literal"><span class="pre">super(GenericPizza,self)</span></tt>; however the simpler approach is
less safe against possible future manipulations of the hierarchy. 
Suppose, for example, we want to create a copy of the hierarchy
with the same name but slightly different features (actually,
in chapter 8 we will implement a traced copy of the pizza hierarchy, 
useful for debugging purposes): then, using <tt class="literal"><span class="pre">super(GenericPizza,self)</span></tt>
would raise an error, since self would be an instance of the traced
hierarchy and <tt class="literal"><span class="pre">GenericPizza</span></tt>  the original nontraced class. Using
the form <tt class="literal"><span class="pre">super(self._GenericPizza__this,self)</span></tt> and making 
<tt class="literal"><span class="pre">self._GenericPizza__this</span></tt> pointing to the traced 'GenericPizza'
class (actually this will happen automatically) the problems goes
away.</p>
<p>Now everything works if 'WithLogger' is put after 'CustomizablePizza'</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; class PizzaWithLog(CustomizablePizza,WithLogger): pass 
&gt;&gt;&gt; PizzaWithLog.With(toppinglist=['tomato'])('large')
****************************************************************************
Sun Apr 13 16:19:12 2003
1. Created large pizza with tomato, cost $ 4.5
&lt;class '__main__.PizzaWithLog'&gt;
</pre>
</blockquote>
<p>The log correctly  says <tt class="literal"><span class="pre">Created</span> <span class="pre">large</span> <span class="pre">pizza</span> <span class="pre">with</span> <span class="pre">tomato,</span> <span class="pre">cost</span> <span class="pre">$</span> <span class="pre">4.5</span></tt> and not
<tt class="literal"><span class="pre">Created</span> <span class="pre">&lt;Pizza&gt;</span></tt> as before since now <tt class="literal"><span class="pre">GenericPizza.__str__</span></tt>
overrides <tt class="literal"><span class="pre">PrettyPrinted.__str__</span></tt>. Moreover, the hierarchy is logically
better organized:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; PizzaWithLog.mro()
[&lt;class '__main__.PizzaWithLog'&gt;, &lt;class 'oopp.CustomizablePizza'&gt;, 
&lt;class 'oopp.GenericPizza'&gt;,  &lt;class 'oopp.Customizable'&gt;, 
&lt;class 'oopp.WithLogger'&gt;, &lt;class 'oopp.WithCounter'&gt;, 
&lt;class 'oopp.PrettyPrinted'&gt;, &lt;type 'object'&gt;]
</pre>
</blockquote>
<p>I leave as an exercise for the reader to make the <tt class="literal"><span class="pre">__str__</span></tt> methods
cooperative ;)</p>
<p>Obviously, in this example it would have been better to correct the
original hierarchy, by leaving 'Beautiful' instantiable from the beginning
(that's why I said the 'Beautiful' is an example of wrong mix-in class): 
nevertheless, sometimes, one has do to with wrong hierarchies written by 
others, and it can be a pain to fix them, both directly by modifying the 
original source code, and indirectly
by inheritance, since one must change all the names, in order to distinghish
the original classes from the fixed ones. In those cases Python
dynamism can save your life. This also allows you enhance original
classes which are not wrong, but that simply don't do something you want
to implement.</p>
<p>Modifying classes at run-time can be trivial, as in the examples I have
shown here, but can also be rather tricky, as in this example</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import PrettyPrinted
&gt;&gt;&gt; class PrettyPrintedWouldBe(object): __str__ = PrettyPrinted.__str__
&gt;&gt;&gt; print PrettyPrintedWouldBe() #error
Traceback (most recent call last):
 File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: unbound method __str__() must be called with PrettyPrinted 
instance as first argument (got nothing instead)
</pre>
</blockquote>
<p>As the error message says, the problem here, is that the 
<tt class="literal"><span class="pre">PrettyPrinted.__str__</span></tt> unbound method, has not received any argument. 
This is because in this
form <tt class="literal"><span class="pre">PrettyPrintedWouldBe.__str__</span></tt> has been defined as an attribute, 
not as a real method. The solution is to write</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class PrettyPrintedWouldBe(object): 
...     __str__ = PrettyPrinted.__dict__['__str__']
...
&gt;&gt;&gt; print PrettyPrintedWouldBe() # now it works
&lt;PrettyPrintedWouldBe&gt;
</pre>
</blockquote>
<p>This kind of run-time modifications does not work when private variables
are involved:</p>
<blockquote>
<pre class="literal-block">
#&lt;changewithprivate.py&gt;

class C(object):
    __x='C.__init__'
    def __init__(self): 
        print self.__x # okay

class D(object):
    __x='D.__init__'
    __init__=C.__dict__['__init__'] # error

class New:
    class C(object):
        __x='New.C.__init__'
        __init__=C.__dict__['__init__'] # okay

C()
try: D()
except AttributeError,e: print e

#&lt;/changewithprivate.py&gt;
</pre>
</blockquote>
<p>Gives as result</p>
<blockquote>
<pre class="literal-block">
C.__init__
'D' object has no attribute '_C__x'
New.C.__init__
</pre>
</blockquote>
<p>The problem is that when <tt class="literal"><span class="pre">C.__dict__['__init__']</span></tt> is compiled 
(to byte-code) <tt class="literal"><span class="pre">self.__x</span></tt> is expanded to <tt class="literal"><span class="pre">self._C__x</span></tt>. However,
when one invokes <tt class="literal"><span class="pre">D.__init__</span></tt>, a D-object is passed, which has
a <tt class="literal"><span class="pre">self._D__x</span></tt> attribute, but not a <tt class="literal"><span class="pre">self._C__x</span></tt> attribute (unless
'D' is a subclass of 'C'. Fortunately, Python wisdom</p>
<blockquote>
<em>Namespaces are one honking great idea -- let's do more of those!</em></blockquote>
<p>suggests the right solution: to use a new class with the <em>same name</em>
of the old one, but in a different namespace, in order to avoid
confusion. The simplest way to generate a new namespace is to
declare a new class (the class 'New' in this example): then 'New.C'
becomes an inner class of 'New'. Since it has the same name of the
original class, private variables are correctly expanded and one
can freely exchange methods from 'C' to 'New.C' (and viceversa, too).</p>
</div>
<div class="section" id="modifying-hierarchies">
<h2><a class="toc-backref" href="#id109" name="modifying-hierarchies">Modifying hierarchies</a></h2>
<blockquote>
<pre class="literal-block">
def mod(cls): return cls

class New: pass

for c in HomoSapiensSapiens.__mro__:
    setattr(New,c.__name__,mod(c))
</pre>
</blockquote>
</div>
<div class="section" id="inspecting-python-code">
<h2><a class="toc-backref" href="#id110" name="inspecting-python-code">Inspecting Python code</a></h2>
<p>how to inspect a class, by retrieving useful informations about its
information.</p>
<p>A first possibility is to use the standard <tt class="literal"><span class="pre">help</span></tt> function.
The problem of this approach is that <tt class="literal"><span class="pre">help</span></tt> gives too much 
information.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

#plaindata=
plainmethod=lambda m:m #identity function

class Get(object):
    &quot;&quot;&quot;Invoked as Get(cls)(xxx) where xxx = staticmethod, classmethod,
    property, plainmethod, plaindata, returns the corresponding 
    attributes as a keyword dictionary. It works by internally calling 
    the routine inspect.classify_class_attrs. Notice that data
    attributes with double underscores are not retrieved 
    (this is by design).&quot;&quot;&quot;
    def __init__(self,cls):
        self.staticmethods=kwdict()
        self.classmethods=kwdict()
        self.properties=kwdict()
        self.methods=kwdict()
        self.data=kwdict()
        for name, kind, klass, attr in inspect.classify_class_attrs(cls):
            if kind=='static method':
                self.staticmethods[name]=attr
            elif kind=='class method':
                self.classmethods[name]=attr
            elif kind=='property':
                self.properties[name]=attr
            elif kind=='method':
                self.methods[name]=attr
            elif kind=='data':
               if not special(name): self.data[name]=attr
    def __call__(self,descr): #could be done with a dict
        if descr==staticmethod: return self.staticmethods 
        elif descr==classmethod: return self.classmethods
        elif descr==property: return self.properties 
        elif descr==plainmethod: return self.methods
        elif descr==plaindata: return self.data
        else: raise SystemExit(&quot;Invalid descriptor&quot;)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>With similar tricks one can automatically recognize cooperative methods:
#it is different, (better NOT to use descriptors)</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

#class Cooperative(Class):
#    __metaclass__ = WithWrappingCapabilities
#
#    def cooperative(method):
#         &quot;&quot;&quot;Calls both the superclass method and the class
#         method (if the class has an explicit method). 
#         Works for methods returning None.&quot;&quot;&quot;
#         name,cls=Cooperative.parameters # fixed by the meta-metaclass
#         def _(*args,**kw):
#            getattr(super(cls,args[0]),name)(*args[1:],**kw) 
#            if method: method(*args,**kw) # call it
#         return _
#    
#    cooperative=staticmethod(cooperative)


#&lt;/oopp.py&gt;
</pre>
<pre class="literal-block">
#&lt;oopp.py&gt;

def wrapH(cls):
    for c in cls.__mro__[:-2]:
        tracer.namespace=c.__name__
        new=vars(c).get('__new__',None)
        if new: c.__new__=tracedmethod(new)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
</div>
</div>
<div class="section" id="the-magic-of-metaclasses-part-i">
<h1><a class="toc-backref" href="#id111" name="the-magic-of-metaclasses-part-i">THE MAGIC OF METACLASSES - PART I</a></h1>
<blockquote>
<pre class="line-block">
<em>Metaclasses are deeper magic than 99% of users should ever
worry about.  If you wonder whether you need them, you don't
(the people who actually need them know with certainty that
they need them, and don't need an explanation about why).</em>
--Tim Peters
</pre>
</blockquote>
<p>Python always had metaclasses, since they are inherent to its object
model. However, before Python 2.2, metaclasses where tricky and their
study could cause the programmer's brain to explode <a class="footnote-reference" href="#id42" id="id44" name="id44">[21]</a>. Nowadays, 
the situation has changed, and the reader should be able to understand 
this chapter without risk for his/her brain (however I do not give any 
warranty ;)</p>
<p>Put it shortly, metaclasses give to the Python programmer
complete control on the creation of classes. This simple statement
has far reaching consequences, since the ability of interfering with
the process of class creation, enable the programmer to make miracles.</p>
<p>In this and in the following chapters, I will show some of these
miracles.</p>
<p>This chapter will focus on subtle problems of metaclasses in inheritance
and multiple inheritance, including multiple inheritance of metaclasses
with classes and metaclasses with metaclasses.</p>
<p>The next chapter will focus more on applications.</p>
<table class="footnote" frame="void" id="id45" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id45">[23]</a></td><td>Metaclasses in Python 1.5 [A.k.a the killer joke] 
<a class="reference" href="http://www.python.org/doc/essays/metaclasses/">http://www.python.org/doc/essays/metaclasses/</a></td></tr>
</tbody>
</table>
<p>There is very little documentation about metaclasses, except Guido's
essays and the papers by David Mertz and myself published in IBMdeveloperWorks</p>
<blockquote>
<a class="reference" href="http://www-106.ibm.com/developerworks/library/l-pymeta.html">http://www-106.ibm.com/developerworks/library/l-pymeta.html</a></blockquote>
<div class="section" id="metaclasses-as-class-factories">
<h2><a class="toc-backref" href="#id112" name="metaclasses-as-class-factories">Metaclasses as class factories</a></h2>
<p>In the Python object model (inspired from the Smalltalk, that had metaclasses 
a quarter of century ago!) classes themselves are objects. 
Now, since objects are instances of classes, that means that classes 
themselves can be seen as instances of special classes called <em>metaclasses</em>.
Notice that things get hairy soon, since by following this idea, one could 
say the metaclasses themselves are classes and therefore objects;  that 
would mean than even metaclasses can be seen as 
instances of special classes called meta-metaclasses. On the other hand,
meta-meta-classes can be seen as instances of meta-meta-metaclasses,
etc. Now, it should be obvious why metaclasses have gained such a 
reputation of brain-exploders ;). However, fortunately, the situation 
is not so bad in practice, since the infinite recursion of metaclasses is 
avoided because there is a metaclass that is the &quot;mother of all metaclasses&quot;: 
the built-in metaclass <em>type</em>. 'type' has the property of being its own 
metaclass, therefore the recursion stops. Consider for instance the following
example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class C(object): pass # a generic class
&gt;&gt;&gt; type(C) #gives the metaclass of C
&lt;type 'type'&gt;
&gt;&gt;&gt; type(type(C)) #gives the metaclass of type
&lt;type 'type'&gt;
</pre>
</blockquote>
<p>The recursion stops, since the metaclass of 'type' is 'type'.
One cool consequence of classes being instances of 'type', 
is that since <em>type</em> is a subclass of object,</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; issubclass(type,object)
True 
</pre>
</blockquote>
<p>any Python class is not only a subclass of <tt class="literal"><span class="pre">object</span></tt>, but also
an instance of 'object':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; isinstance(C,type)
True
&gt;&gt;&gt; isinstance(C,object) 
True
&gt;&gt;&gt; issubclass(C,object) 
True
</pre>
</blockquote>
<p>Notice that 'type' is an instance of itself (!) and therefore of 'object':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; isinstance(type,type) # 'type' is an instance of 'type'
True
&gt;&gt;&gt; isinstance(type,object) # therefore 'type' is an instance of 'object'
True
</pre>
</blockquote>
<p>As it is well known, <tt class="literal"><span class="pre">type(X)</span></tt> returns the type of <tt class="literal"><span class="pre">X</span></tt>; however, 
<tt class="literal"><span class="pre">type</span></tt> has also a second form in which it acts as a class factory.
The form is <tt class="literal"><span class="pre">type(name,bases,dic)</span></tt> where <tt class="literal"><span class="pre">name</span></tt> is the name of
the new class to be created, bases is the tuple of its bases and dic
is the class dictionary. Let me give a few examples:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C=type('C',(),{})
&gt;&gt;&gt; C
&lt;class '__main__.C'&gt;
&gt;&gt;&gt; C.__name__
'C'
&gt;&gt;&gt; C.__bases__
(&lt;type 'object'&gt;,)
&gt;&gt;&gt; C.__dict__
&lt;dict-proxy object at 0x8109054&gt;
</pre>
</blockquote>
<p>Notice that since all metaclasses inherits from <tt class="literal"><span class="pre">type</span></tt>, as a consequences
all metaclasses can be used as class factories.</p>
<p>A fairy tale example will help in understanding the concept
and few subtle points on how attributes are transmitted from metaclasses
to their instances.</p>
<p>Let me start by defining a 'Nobility' metaclass :</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Nobility(type): attributes=&quot;Power,Richness,Beauty&quot;
</pre>
</blockquote>
<p>instances of 'Nobility' are classes such 'Princes', 'Dukes', 'Barons', etc.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Prince=Nobility(&quot;Prince&quot;,(),{})
</pre>
</blockquote>
<p>Instances of 'Nobility' inherits its attributes, just as instances of normal
classes inherits the class docstring:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Prince.attributes
'Power,Richness,Beauty'
</pre>
</blockquote>
<p>Nevertheless, 'attributes' will not be retrieved by the <tt class="literal"><span class="pre">dir</span></tt> function:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print dir(Prince)
['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__', 
 '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__repr__', 
 '__setattr__', '__str__', '__weakref__']
</pre>
</blockquote>
<p>However, this is a limitation of <tt class="literal"><span class="pre">dir</span></tt>, in reality <tt class="literal"><span class="pre">Prince.attributes</span></tt>
is there. On the other hand, the situation is different for a specific 
'Prince' object</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; charles=Prince()
&gt;&gt;&gt; charles.attributes #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: 'Prince' object has no attribute 'attributes'
</pre>
</blockquote>
<p>The transmission of metaclass attributes is not transitive:
instances of the metaclass inherits the attributes, but not the instances 
of the instances. This behavior is by design and is needed in order to avoid 
troubles with special methods. This point will be throughly 
explained in the last paragraph. For the moment, I my notice that the
behaviour is reasonable, since the abstract qualities  'Power,Richness,Beauty'
are more qualities of the 'Prince' class than of one specific representative.
They can always be retrieved via the <tt class="literal"><span class="pre">__class__</span></tt> attribute:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; charles.__class__.attributes
'Power,Richness,Beauty'
</pre>
</blockquote>
<p>Le me now define a metaclass 'Froggyness':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Frogginess(type): attributes=&quot;Powerlessness,Poverty,Uglyness&quot;
</pre>
</blockquote>
<p>Instances of 'Frogginess' are classes like 'Frog', 'Toad', etc.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Frog=Frogginess(&quot;Frog&quot;,(),{})
&gt;&gt;&gt; Frog.attributes
'Powerlessness,Poverty,Uglyness'
</pre>
</blockquote>
<p>However, in Python miracles can happen:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def miracle(Frog): Frog.__class__=Nobility
&gt;&gt;&gt; miracle(Frog); Frog.attributes
'Powerlessness,Richness,Beauty'
</pre>
</blockquote>
<p>In this example a miracle happened on the class 'Frog', by changing its
(meta)class to 'Nobility'; therefore its attributes have changed accordingly.</p>
<p>However, there is subtle point here. Suppose we explicitly specify the 'Frog'
attributes, in such a way that it can be inherited by one of its specific
representative:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Frog.attributes=&quot;poor, small, ugly&quot;
&gt;&gt;&gt; jack=Frog(); jack.attributes
'poor, small, ugly'
</pre>
</blockquote>
<p>Then the miracle cannot work:</p>
<blockquote>
<pre class="literal-block">
#&lt;fairytale2.py&gt;

class Nobility(type): attributes=&quot;Power, Richness, Beauty&quot;
Prince=Nobility(&quot;Prince&quot;,(),{})
charles=Prince()

class Frogginess(type): attributes=&quot;Inpuissance, Poverty, Uglyness&quot;
Frog=Frogginess(&quot;Frog&quot;,(),{})
Frog.attributes=&quot;poor, small, ugly&quot;
jack=Frog()

def miracle(Frog): Frog.__class__=Nobility

miracle(Frog)

print &quot;I am&quot;,Frog.attributes,&quot;even if my class is&quot;,Frog.__class__

#&lt;/fairytale2.py&gt;
</pre>
</blockquote>
<p>Output:</p>
<blockquote>
<pre class="literal-block">
I am poor, small, ugly even if my class is &lt;class '__main__.Nobility'&gt;
</pre>
</blockquote>
<p>The reason is that Python first looks at specific attributes of an object
(in this case the object is the class 'Frog') an only if they are not found, 
it looks at the attributes of its class (here the metaclass 'Nobility').Since 
in this example the 'Frog' class has explicit attributes, the
result is <tt class="literal"><span class="pre">poor,</span> <span class="pre">small,</span> <span class="pre">ugly</span></tt>. If you think a bit, it makes sense.</p>
<p>Remark:</p>
<p>In Python 2.3 there are restrictions when changing the <tt class="literal"><span class="pre">__class__</span></tt> 
attribute for classes:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C=type('C',(),{})
&gt;&gt;&gt; C.__class__ = Nobility #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: __class__ assignment: only for heap types
</pre>
</blockquote>
<p>Here changing <tt class="literal"><span class="pre">C.__class__</span></tt> is not allowed, since 'C' is an instance
of the built-in metaclass 'type'. This restriction, i.e. the fact that 
the built-in metaclass cannot be changed, has been imposed for
security reasons, in order to avoid dirty tricks with the built-in
classes. For instance, if it was possible to change the metaclass
of the 'bool' class, we could arbitrarily change the behavior of
boolean objects. This could led to abuses. 
Thanks to this restriction,
the programmer is always sure that built-in classes behaves as documented.
This is also the reason why 'bool' cannot be subclassed:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print bool.__doc__ # in Python 2.2 would give an error
bool(x) -&gt; bool
Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.
</pre>
</blockquote>
<p>In any case, changing the class of a class is not a good idea, since it
does not play well with inheritance, i.e. changing the metaclass of a base 
class does not change the metaclass of its children:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M1(type): f=lambda cls: 'M1.f' #metaclass1
&gt;&gt;&gt; class M2(type): f=lambda cls: 'M2.f' #metaclass2
&gt;&gt;&gt; B=M1('B',(),{}) # B receives M1.f
&gt;&gt;&gt; class C(B): pass #C receives M1.f
&gt;&gt;&gt; B.f()
'M1.f'
B.__class__=M2 #change the metaclass
&gt;&gt;&gt; B.f() #B receives M2.f
'M2.f'
C.f() #however C does *not* receive M2.f
&gt;&gt;&gt; C.f()
'M1.f'
&gt;&gt;&gt; type(B)
&lt;class '__main__.M2'&gt;
&gt;&gt;&gt; type(C)
&lt;class '__main__.M1'&gt;
</pre>
</blockquote>
</div>
<div class="section" id="metaclasses-as-class-modifiers">
<h2><a class="toc-backref" href="#id113" name="metaclasses-as-class-modifiers">Metaclasses as class modifiers</a></h2>
<p>The interpretation of metaclasses in terms of class factories is quite
straightforward and I am sure that any Pythonista will be at home 
with the concept. However, metaclasses have such a reputation of black 
magic since their typical usage is <em>not</em> as class factories, but as 
<em>class modifiers</em>. This means that metaclasses are typically
used to modify <em>in fieri</em> classes. The trouble is that the
modification can be utterly magical.
Here there is another fairy tale example showing the syntax
(via the <tt class="literal"><span class="pre">__metaclass__</span></tt> hook) and the magic of the game:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class UglyDuckling(PrettyPrinted):
    &quot;A plain, regular class&quot;
    formatstring=&quot;Not beautiful, I am %s&quot;

class MagicallyTransformed(type):
    &quot;Metaclass changing the formatstring of its instances&quot;
    def __init__(cls,*args):
        cls.formatstring=&quot;Very beautiful, since I am %s&quot;
        
class TransformedUglyDuckling(PrettyPrinted):
    &quot;A class metamagically modified&quot;
    __metaclass__ = MagicallyTransformed
    formatstring=&quot;Not beautiful, I am %s&quot; # will be changed

#&lt;/oopp.py&gt;

&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; print UglyDuckling()
Not beautiful, I am &lt;UglyDuckling&gt;
</pre>
</blockquote>
<p>In this example, even if in 'TransformedUglyDuckling' we explicitely
set the formatstring to  &quot;Not beautiful, I am %s&quot;, the metaclass changes 
it to &quot;Very beautiful, even if I am %s&quot; and thus</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print TransformedUglyDuckling() # gives
Very beautiful, since I am &lt;TransformedUglyDuckling&gt;
</pre>
</blockquote>
<p>Notice that the <tt class="literal"><span class="pre">__metaclass__</span></tt> hook passes to the metaclass 
<tt class="literal"><span class="pre">MagicallyTransformed</span></tt> the name, bases and dictionary of the class 
being created, i.e. 'TransformedUglyDucking'.</p>
<p>Metaclasses, when used as class modifiers, act <em>differently</em>
from functions, when inheritance is
involved. To clarify this subtle point, consider a subclass 'Swan' 
of 'UglyDuckling':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; class Swan(UglyDuckling): 
...     formatstring=&quot;Very beautiful, I am %s&quot;
&gt;&gt;&gt; print Swan()
Very beautiful, I am &lt;Swan&gt;
</pre>
</blockquote>
<p>Now, let me define a simple function acting as a class modifier:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def magicallyTransform(cls): 
...    &quot;Modifies the class formatstring&quot;
...    customize(cls,formatstring=&quot;Very beautiful, even if I am %s&quot;)
...    return cls
</pre>
</blockquote>
<p>The function works:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; magicallyTransform(UglyDuckling)
&gt;&gt;&gt; print UglyDuckling()
Very beautiful, even if I am &lt;UglyDuckling&gt;
</pre>
</blockquote>
<p>This approach is destructive, since we cannot have the original 
and the transformed class at the same time, and has potentially bad side
effects in the derived classes. Nevertheless, in this case it works
and it is not dangereous for the derived class 'Swan', since 'Swan' 
explicitly overrides the 'formatstring' attribute and doesn't care about 
the change in 'UglyDuckling.formatstring'. Therefore the output
of</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print Swan()
Very beautiful, I am &lt;Swan&gt;
</pre>
</blockquote>
<p>is still the same as before the action of the function <tt class="literal"><span class="pre">magicallyTransform</span></tt>.
The situation is quite different if we use the 'MagicallyTransformed'
metaclass:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; class Swan(TransformedUglyDuckling): 
...     formatstring=&quot;Very beautiful, I am %s&quot;
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print TransformedUglyDuckling() 
Very beautiful, since I am &lt;UglyDuckling&gt;
&gt;&gt;&gt; print Swan() # does *not* print &quot;Very beautiful, I am &lt;Swan&gt;&quot;
Very beautiful, since I am &lt;Swan&gt; 
</pre>
</blockquote>
<p>Therefore,  not only the metaclass has magically transformed the 
'TransformedUglyDuckling.formatstring', it has also transformed the 
'Swan.formatstring'! And that, despite the fact that 
'Swan.formatstring' is explicitly set.</p>
<p>The reason for this behaviour is that since 'UglyDuckling' is a base 
class with metaclass 'MagicallyTransformed', and since 'Swan' inherits from
'UglyDuckling', then 'Swan' inherits the metaclass 'MagicallyTransformed',
which is automatically called at 'Swan' creation time.
That's the reason why metaclasses are much more magical and much 
more dangerous than
functions: functions do not override attributes in the derived classes,
metaclasses do, since they are automagically called at the time of
creation of the subclass. In other words, functions are explicit,
metaclasses are implicit. Nevertheless, this behavior can be pretty
useful in many circumstances, and it is a feature, not a bug. In the
situations where this behavior is not intended, one should use a function,
not a metaclass. In general, metaclasses are better than functions,
since metaclasses are classes and as such they can inherit one from each 
other. This means that one can improve a basic metaclass trough 
(multiple) inheritance, with <em>reuse</em> of code.</p>
</div>
<div class="section" id="a-few-caveats-about-the-usage-of-metaclasses">
<h2><a class="toc-backref" href="#id114" name="a-few-caveats-about-the-usage-of-metaclasses">A few caveats about the usage of metaclasses</a></h2>
<p>Let me start with some caveats about the <tt class="literal"><span class="pre">__metaclass__</span></tt> hook, which
commonly used and quite powerful, but also quite dangereous.</p>
<p>Let's imagine a programmer not
knowing about metaclasses and looking at the 'TransformedUglyDuckling'
code (assuming there are no comments): she would probably think
that &quot;__metaclass__&quot; is some special attribute used for introspection
purposes only, with no other effects, and she would probably expect
the output of the script to be &quot;Not much, I am the class 
TransformedUglyDucking&quot; whereas it is exacly the contrary! In other
words, when metaclasses are involved,  <em>what you see, is not what you get</em>.
The situation is even more implicit when the metaclass is inherited
from some base class, therefore lacking also the visual clue of the hook.</p>
<p>For these reasons, metaclasses are something to be used with great care; 
they can easily make your code unreadable and confuse inexpert programmers. 
Moreover, it is more difficult to debug programs involving metaclasses, since
methods are magically transformed by routines defined in the metaclass,
and the code you see in the class is <em>not</em> what Python sees. I think
the least confusing way of using metaclasses, is to concentrate all
the dynamics on them and to write empty classes except for the
metaclass hook. If you write a class with no methods such as</p>
<blockquote>
<pre class="literal-block">
class TransformedUglyDuckling(object):
    __metaclass__=MagicallyTransformed
</pre>
</blockquote>
<p>then the only place to look at, is the metaclass. I have found extremely
confusing to have some of the methods defined in the class and some in
the metaclass, especially during debugging.</p>
<p>Another point to make, is that the <tt class="literal"><span class="pre">__metaclass__</span></tt>
hook should not be used to modify pre-existing classes, 
since it requires modifying the source code (even if it is enough to 
change one line only). Moreover, it is confusing, since adding a 
<tt class="literal"><span class="pre">__metaclass__</span></tt> attribute <em>after</em> the class creation would not do the job:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import UglyDuckling, MagicallyTransformed
&gt;&gt;&gt; UglyDuckling.__metaclass__=MagicallyTransformed
&gt;&gt;&gt; print UglyDuckling()
&quot;Not much, I am the class UglyDuckling&quot;
</pre>
</blockquote>
<p>The reason is that we have to think of UglyDuckling as an instance of 
<tt class="literal"><span class="pre">type</span></tt>, the built-in metaclasses; merely adding a <tt class="literal"><span class="pre">__metaclass__</span></tt> 
attribute does not re-initialize the class.
The problem is elegantly solved by avoiding the hook and creating
an enhanced copy of the original class trough <tt class="literal"><span class="pre">MagicallyTransformed</span></tt>
used as a class factory.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; name=UglyDuckling.__name__
&gt;&gt;&gt; bases=UglyDuckling.__bases__
&gt;&gt;&gt; dic=UglyDuckling.__dict__.copy()
&gt;&gt;&gt; UglyDuckling=MagicallyTransformed(name,bases,dic)
</pre>
</blockquote>
<p>Notice that I have recreated 'UglyDuckling', giving to the new class
the old identifier.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print UglyDuckling()
Very beautiful, since I am &lt;UglyDuckling&gt;&gt;
</pre>
</blockquote>
<p>The metaclass of this new 'UglyDuckling' has been specified and will 
accompanies all future children of 'UglyDuckling':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Swan(UglyDuckling): pass
...
&gt;&gt;&gt; type(Swan)
&lt;class '__main__.MagicallyTransformed'&gt;
</pre>
</blockquote>
<p>Another caveat, is in the overridding of `` __init__`` in the metaclass.
This is quite common in the case of metaclasses called trough the
<tt class="literal"><span class="pre">__metaclass__</span></tt> hook mechanism, since in this case the class
has been already defined (if not created) in the class statement,
and we are interested in initializing it, more than in recreating
it (which is still possible, by the way). 
The problem is that overriding <tt class="literal"><span class="pre">__init__</span></tt> has severe limitations 
with respect to overriding <tt class="literal"><span class="pre">__new__</span></tt>,
since the 'name', 'bases' and 'dic' arguments cannot be directly
changed. Let me show an example:</p>
<blockquote>
<pre class="literal-block">
#&lt;init_in_metaclass.py&gt;

from oopp import *

class M(type):
    &quot;Shows that dic cannot be modified in __init__, only in __new__&quot;
    def __init__(cls,name,bases,dic):
        name='C name cannot be changed in __init__'
        bases='cannot be changed'
        dic['changed']=True

class C(object):
    __metaclass__=M
    changed=False

print C.__name__  # =&gt; C
print C.__bases__ # =&gt; (&lt;type 'object'&gt;,)
print C.changed   # =&gt; False

#&lt;/init_in_metaclass.py&gt;
</pre>
</blockquote>
<p>The output of this script is <tt class="literal"><span class="pre">False</span></tt>: the dictionary cannot be changed in 
<tt class="literal"><span class="pre">__init__</span></tt> method. However, replacing <tt class="literal"><span class="pre">dic['changed']=True</span></tt> with 
<tt class="literal"><span class="pre">cls.changed=True</span></tt> would work. Analougously, changing  <tt class="literal"><span class="pre">cls.__name__</span></tt> 
would work. On the other hand, <tt class="literal"><span class="pre">__bases__</span></tt> is a read-only attribute and 
cannot be changed once the class has been created, therefore there is no 
way it can be touched in <tt class="literal"><span class="pre">__init__</span></tt>. However, <tt class="literal"><span class="pre">__bases__</span></tt> could be
changed in <tt class="literal"><span class="pre">__new__</span></tt> before the class creation.</p>
</div>
<div class="section" id="metaclasses-and-inheritance">
<h2><a class="toc-backref" href="#id115" name="metaclasses-and-inheritance">Metaclasses and inheritance</a></h2>
<p>It is easy to get confused about the difference between a metaclass
and a mix-in class in multiple inheritance, since 
both are denoted by adjectives and both share the same idea of 
enhancing a hierarchy. Moreover, both mix-in classes and metaclasses 
can be inherited in the whole hierarchy.
Nevertheless, they behaves differently
and there are various subtle point to emphasize. We have already
noticed in the first section that attributes of a metaclass
are transmitted to its instances, but not to the instances of the
instances, whereas the normal inheritance is transitive: the 
grandfather transmits its attributes to the children and to the grandchild 
too. The difference can be represented with the following picture, where
'M' is the metaclass, 'B' a base class, 'C' a children of 'B'
and c an instance of 'C':</p>
<blockquote>
<pre class="literal-block">
M (attr)         B (attr)   
:                |
C (attr)         C (attr)    
:                :
c ()             c (attr)    
</pre>
</blockquote>
<p>Notice that here the relation of instantiation is denoted by a dotted line.</p>
<p>This picture is valid when C has metaclass M but not base class, on when C
has base class but not metaclass. However, what happens whrn the class C has 
both a metaclass M and a base class B ?</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M(type): a='M.a'
&gt;&gt;&gt; class B(object): a='B.a'
&gt;&gt;&gt; class C(B): __metaclass__=M
&gt;&gt;&gt; c=C()
</pre>
</blockquote>
<p>The situation can be represented by in the following graph,</p>
<blockquote>
<pre class="literal-block">
(M.a)   M   B  (B.a)
        :  /
        : /
   (?)  C
        :
        :
   (?)  c
</pre>
</blockquote>
<p>Here the metaclass M and the base class B are fighting one against the other.
Who wins ? C should inherit the attribute 'B.a' from its base B, however,
the metaclass would like to induce an attribute 'M.a'.
The answer is that the inheritance constraint wins on the metaclass contraint:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C.a
'B.a'
&gt;&gt;&gt; c.a
'B.a'
</pre>
</blockquote>
<p>The reason is the same we discussed in the fairy tale example: 'M.a' is
an attribute of the metaclass, if its instance C has already a specified
attributed C.a (in this case specified trough inheritance from B), then
the attribute is not modified. However, one could <em>force</em> the modification:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M(type):
...     def __init__(cls,*args): cls.a='M.a'
&gt;&gt;&gt; class C(B): __metaclass__=M
&gt;&gt;&gt; C.a
'M.a'
</pre>
</blockquote>
<p>In this case the metaclass M would win on the base class B. Actually,
this is not surprising, since it is explicit. What could be surprising,
had we not explained why inheritance silently wins, is that</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c.a
'B.a'
</pre>
</blockquote>
<p>This explain the behaviour for special methods like  
<tt class="literal"><span class="pre">__new__,__init__,__str__</span></tt>, 
etc. which are defined both in the class and the metaclass with the same 
name (in both cases,they are inherited from <tt class="literal"><span class="pre">object</span></tt>).</p>
<p>In the chapter on objects, we learned that the printed representation of
an object can be modified by overring the <tt class="literal"><span class="pre">__str__</span></tt> methods of its
class. In the same sense, the printed representation of a class can be 
modified by overring the <tt class="literal"><span class="pre">__str__</span></tt> methods of its metaclass. Let me show an 
example:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Printable(PrettyPrinted,type):
   &quot;&quot;&quot;Apparently does nothing, but actually makes PrettyPrinted acting as
      a metaclass.&quot;&quot;&quot;

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Instances of 'Printable' are classes with a nice printable representation:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Printable 
&gt;&gt;&gt; C=Printable('Classname',(),{})
&gt;&gt;&gt; print C
Classname
</pre>
</blockquote>
<p>However, the internal string representation stays the same:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C # invokes Printable.__repr__
&lt;class '__main__.Classname'&gt;
</pre>
</blockquote>
<p>Notice that the name of class 'C' is <tt class="literal"><span class="pre">Classname</span></tt> and not 'C' !</p>
<p>Consider for instance the following code:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M(type):
...    def __str__(cls):
...        return cls.__name__
...    def method(cls):
...        return cls.__name__
...
&gt;&gt;&gt; class C(object):
...    __metaclass__=M
&gt;&gt;&gt; c=C()
</pre>
</blockquote>
<p>In this case the <tt class="literal"><span class="pre">__str__</span></tt> method in <tt class="literal"><span class="pre">M</span></tt> cannot override the 
<tt class="literal"><span class="pre">__str__</span></tt> method in C, which is inherited from <tt class="literal"><span class="pre">object</span></tt>.
Moreover, if you experiment a little, you will see that</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print C # is equivalent to print M.__str__(C)
C
&gt;&gt;&gt; print c # is equivalent to print C.__str__(c)
&lt;__main__.C object at 0x8158f54&gt;
</pre>
</blockquote>
<p>The first <tt class="literal"><span class="pre">__str__</span></tt> is &quot;attached&quot; to the metaclass and the
second to the class.</p>
<p>Consider now the standard method &quot;method&quot;. It is both attached to the
metaclass</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print M.method(C)
C
</pre>
</blockquote>
<p>and to the class</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print C.method() #in a sense, this is a class method, i.e. it receives 
C                    #the class as first argument
</pre>
</blockquote>
<p>Actually it can be seen as a class method of 'C' (cfr. Guido van Rossum
&quot;Unifying types and classes in Python 2.2&quot;. When he discusses
classmethods he says: <em>&quot;Python also has real metaclasses, and perhaps 
methods defined in a metaclass have more right to the name &quot;class method&quot;; 
but I expect that most programmers won't be using metaclasses&quot;</em>). Actually,
this is the SmallTalk terminology, Unfortunately, in Python the word
<tt class="literal"><span class="pre">classmethod</span></tt> denotes an attribute descriptor, therefore it is better
to call the methods defined in a metaclass <em>metamethods</em>, in order to avoid
any possible confusion.</p>
<p>The difference between <tt class="literal"><span class="pre">method</span></tt> and <tt class="literal"><span class="pre">__str__</span></tt> is that you cannot use the
syntax</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print C.__str__() #error
TypeError: descriptor '__str__' of 'object' object needs an argument
</pre>
</blockquote>
<p>because of the confusion with the other __str__; you can only use the
syntax</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print M.__str__(C)
</pre>
</blockquote>
<p>Suppose now I change C's definition by adding a method called &quot;method&quot;:</p>
<blockquote>
<pre class="literal-block">
class C(object):
    __metaclass__=M
    def __str__(self):
        return &quot;instance of %s&quot; % self.__class__
    def method(self):
        return &quot;instance of %s&quot; % self.__class__
</pre>
</blockquote>
<p>If I do so, then there is name clashing and the previously working
statement print C.method() gives now an error:</p>
<blockquote>
<pre class="literal-block">
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 24, in ?
TypeError: unbound method method() must be called with C instance as
first argument (got nothing instead)
</pre>
</blockquote>
<p>Conclusion: <tt class="literal"><span class="pre">__str__,</span> <span class="pre">__new__,</span> <span class="pre">__init__</span></tt> etc. defined in the metaclass
have name clashing with the standard methods defined in the class, therefore
they must be invoked with the extended syntax (ex. <tt class="literal"><span class="pre">M.__str__(C)</span></tt>),
whereas normal methods in the metaclass with no name clashing with the methods
of the class can be used as class methods (ex. <tt class="literal"><span class="pre">C.method()</span></tt> instead of
<tt class="literal"><span class="pre">M.method(C)</span></tt>).
Metaclass methods are always bound to the metaclass, they bind to the class 
(receiving the class as first argument) only if there is no name clashing with 
already defined methods in the class. Which is the case for <tt class="literal"><span class="pre">__str__</span></tt>,
<tt class="literal"><span class="pre">___init__</span></tt>, etc.</p>
</div>
<div class="section" id="conflicting-metaclasses">
<h2><a class="toc-backref" href="#id116" name="conflicting-metaclasses">Conflicting metaclasses</a></h2>
<p>Consider a class 'A' with metaclass 'M_A' and a class 'B' with 
metaclass 'M_B'; suppose I derive 'C' from 'A' and 'B'. The question is: 
what is the metaclass of 'C' ? Is it 'M_A' or 'M_B' ?</p>
<p>The correct answer (see &quot;Putting metaclasses to work&quot; for a thought 
discussion) is 'M_C', where 'M_C' is a metaclass that inherits from 
'M_A' and 'M_B', as in the following graph:</p>
<blockquote>
<div class="figure">
<p><img alt="fig1.gif" src="fig1.gif" /></p>
</div>
</blockquote>
<p>However, Python is not yet that magic, and it does not automatically create 
'M_C'. Instead, it will raise a <tt class="literal"><span class="pre">TypeError</span></tt>, warning the programmer of
the possible confusion:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M_A(type): pass
&gt;&gt;&gt; class M_B(type): pass
&gt;&gt;&gt; A=M_A('A',(),{})
&gt;&gt;&gt; B=M_B('B',(),{})
&gt;&gt;&gt; class C(A,B): pass #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: metatype conflict among bases
</pre>
</blockquote>
<p>This is an example where the metaclasses 'M_A' and 'M_B' fight each other
to generate 'C' instead of cooperating. The metatype conflict can be avoided 
by assegning the correct metaclass to 'C' by hand:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class C(A,B): __metaclass__=type(&quot;M_AM_B&quot;,(M_A,M_B),{})
&gt;&gt;&gt; type(C)
&lt;class '__main__.M_AM_B'&gt;
</pre>
</blockquote>
<p>In general, a class A(B, C, D , ...) can be generated without conflicts only
if type(A) is a  subclass of each of type(B), type(C), ...</p>
<p>In order to avoid conflicts, the following function, that generates
the correct metaclass by looking at the metaclasses of the base
classes, is handy:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

metadic={}

def _generatemetaclass(bases,metas,priority):
    trivial=lambda m: sum([issubclass(M,m) for M in metas],m is type)
    # hackish!! m is trivial if it is 'type' or, in the case explicit
    # metaclasses are given, if it is a superclass of at least one of them
    metabs=tuple([mb for mb in map(type,bases) if not trivial(mb)])
    metabases=(metabs+metas, metas+metabs)[priority]
    if metabases in metadic: # already generated metaclass
        return metadic[metabases]
    elif not metabases: # trivial metabase
        meta=type 
    elif len(metabases)==1: # single metabase
        meta=metabases[0]
    else: # multiple metabases
        metaname=&quot;_&quot;+''.join([m.__name__ for m in metabases])
        meta=makecls()(metaname,metabases,{})
    return metadic.setdefault(metabases,meta)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>This function is particularly smart since:</p>
<blockquote>
<ol class="arabic simple">
<li>Avoid duplications ..</li>
<li>Remember its results.</li>
</ol>
</blockquote>
<p>We may generate the child of a tuple of base classes with a given metaclass 
and avoiding metatype conflicts thanks to the following <tt class="literal"><span class="pre">child</span></tt> function:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def makecls(*metas,**options):
    &quot;&quot;&quot;Class factory avoiding metatype conflicts. The invocation syntax is
    makecls(M1,M2,..,priority=1)(name,bases,dic). If the base classes have 
    metaclasses conflicting within themselves or with the given metaclasses,
    it automatically generates a compatible metaclass and instantiate it. 
    If priority is True, the given metaclasses have priority over the 
    bases' metaclasses&quot;&quot;&quot;

    priority=options.get('priority',False) # default, no priority
    return lambda n,b,d: _generatemetaclass(b,metas,priority)(n,b,d)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class C(A,B): __metaclass__=makecls()
&gt;&gt;&gt; print C,type(C)
&lt;class 'oopp.AB_'&gt; &lt;class 'oopp._M_AM_B'&gt;
</pre>
</blockquote>
<p>Notice that the automatically generated metaclass does not pollute the 
namespace:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; _M_A_M_B #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: name '_M_A_M_B' is not defined
</pre>
</blockquote>
<p>It can only be accessed as <tt class="literal"><span class="pre">type(C)</span></tt>.</p>
<p>Put it shortly, the <tt class="literal"><span class="pre">child</span></tt> function allows to generate a child from bases 
enhanced by different custom metaclasses, by generating under the hood a 
compatibile metaclass via multiple inheritance from the original metaclasses. 
However, this logic can only work if the original metaclasses are
cooperative, i.e. their methods are written in such a way to avoid
collisions. This can be done by using the cooperative the <tt class="literal"><span class="pre">super</span></tt> call 
mechanism discussed in chapter 4.</p>
</div>
<div class="section" id="cooperative-metaclasses">
<h2><a class="toc-backref" href="#id117" name="cooperative-metaclasses">Cooperative metaclasses</a></h2>
<p>In this section I will discuss how metaclasses can be composed with
classes and with metaclasses, too. Since we will discusss even
complicated hierarchies, it is convenient to have an utility 
routine printing the MRO of a given class:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def MRO(cls):
    count=0; out=[]
    print &quot;MRO of %s:&quot; % cls.__name__
    for c in cls.__mro__:
        name=c.__name__
        bases=','.join([b.__name__ for b in c.__bases__])
        s=&quot;  %s - %s(%s)&quot; % (count,name,bases)
        if type(c) is not type: s+=&quot;[%s]&quot; % type(c).__name__
        out.append(s); count+=1
    return '\n'.join(out)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Notice that <tt class="literal"><span class="pre">MRO</span></tt> also prints the metaclass' name in square brackets, for
classes enhanced by a non-trivial metaclass.</p>
<p>Consider for instance the following hierarchy:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import MRO
&gt;&gt;&gt; class B(object): pass
&gt;&gt;&gt; class M(B,type): pass
&gt;&gt;&gt; class C(B): __metaclass__=M
</pre>
</blockquote>
<p>Here 'M' is a metaclass that inherits from 'type' and the base class 'B'
and 'C' is both an instance of 'M' and a child of 'B'. The inheritance
graph can be draw as</p>
<blockquote>
<pre class="literal-block">
 object
 /   \
B    type
| \  /
|  M
\  :
 \ :     
   C
</pre>
</blockquote>
<p>Suppose now we want to retrieve the <tt class="literal"><span class="pre">__new__</span></tt> method of B's superclass
with respect to the MRO of C: obviously, this is <tt class="literal"><span class="pre">object.__new__</span></tt>, since</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print MRO(C)
MRO of C:
  0 - C(B)[M]
  1 - B(object)
  2 - object()
</pre>
</blockquote>
<p>This allows to create an instance of 'C' in this way:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; super(B,C).__new__(C) 
&lt;__main__.C object at 0x4018750c&gt;
</pre>
</blockquote>
<p>It is interesting to notice that this would not work in Python 2.2,
due to a bug in the implementation of <tt class="literal"><span class="pre">super</span></tt>, therefore do not
try this trick with older version of Python.</p>
<p>Notice that everything works 
only because <tt class="literal"><span class="pre">B</span></tt> inherits the <tt class="literal"><span class="pre">object.__new__</span></tt> staticmethod that 
is cooperative and it turns out that it calls <tt class="literal"><span class="pre">type.__new__</span></tt>. However, 
if I give to 'B' a non-cooperative method</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; B.__new__=staticmethod(lambda cls,*args: object.__new__(cls))
</pre>
</blockquote>
<p>things do not work:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; M('D',(),{}) #error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;lambda&gt;
TypeError: object.__new__(M) is not safe, use type.__new__()
</pre>
</blockquote>
<p>A cooperative method would solve the problem:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; B.__new__=staticmethod(lambda m,*args: super(B,m).__new__(m,*args))
&gt;&gt;&gt; M('D',(),{}) # calls B.__new__(M,'D',(),{})
&lt;class '__main__.D'&gt;
</pre>
</blockquote>
</div>
<div class="section" id="metamethods-vs-class-methods">
<h2><a class="toc-backref" href="#id118" name="metamethods-vs-class-methods">Metamethods vs class methods</a></h2>
<p>Meta-methods, i.e. methods defined in
a metaclass.</p>
<p>Python has already few built-in metamethods: <tt class="literal"><span class="pre">.mro()</span></tt> 
and <tt class="literal"><span class="pre">__subclass__</span></tt>. These are methods of the metaclass 'type' and
there of any of its sub-metaclasses.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; dir(type)
['__base__', '__bases__', '__basicsize__', '__call__', '__class__', 
 '__cmp__', '__delattr__', '__dict__', '__dictoffset__', '__doc__', 
 '__flags__', '__getattribute__', '__hash__', '__init__', '__itemsize__', 
 '__module__', '__mro__', '__name__', '__new__', '__reduce__', '__repr__', 
 '__setattr__', '__str__', '__subclasses__', '__weakrefoffset__', 'mro']
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print type.mro.__doc__
mro() -&gt; list
return a type's method resolution order
&gt;&gt;&gt; print type.__subclasses__.__doc__
__subclasses__() -&gt; list of immediate subclasses
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; class A(object): pass
&gt;&gt;&gt; class B(A): pass
&gt;&gt;&gt; B.mro()
[&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;]
&gt;&gt;&gt; A.__subclasses__()
[&lt;class '__main__.B'&gt;]
</pre>
</blockquote>
<p>Notice that <tt class="literal"><span class="pre">mro()</span></tt> and <tt class="literal"><span class="pre">__subclasses__</span></tt> are not retrieved by <tt class="literal"><span class="pre">dir</span></tt>.</p>
<p>Let me constrast metamethods with the more traditional classmethods.
In many senses, the to concepts are akin:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class M(type): 
...    &quot;Metaclass with a (meta)method mm&quot;
...    def mm(cls): return cls
&gt;&gt;&gt; D=M('D',(),{'cm':classmethod(lambda cls: cls)}) 
&gt;&gt;&gt; # instance of M with a classmethod cm
&gt;&gt;&gt; D.mm # the metamethod
&lt;bound method M.mm of &lt;class '__main__.C'&gt;&gt;
&gt;&gt;&gt; D.cm # the classmethod
&lt;unbound method D.&lt;lambda&gt;&gt;
</pre>
</blockquote>
<p>Notice the similarities between the classmethod and the metamethod:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; D.mm.im_self, D.cm.im_self # the same
(&lt;class '__main__.D'&gt;, &lt;class '__main__.D'&gt;)
&gt;&gt;&gt; D.mm.im_class, D.cm.im_class # still the same
(&lt;class '__main__.M'&gt;, &lt;class '__main__.M'&gt;)
</pre>
</blockquote>
<p>There are no surprises for <tt class="literal"><span class="pre">im_func</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; D.mm.im_func, D.cm.im_func
(&lt;function mm at 0x402c272c&gt;, &lt;function &lt;lambda&gt; at 0x402c280c&gt;)
</pre>
</blockquote>
<p>Nevertheless, there are differences: metamethods are not bounded to
instances of the class</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; D().cm() # the classmethod works fine
&lt;class '__main__.D'&gt;
&gt;&gt;&gt; D().mm() # the metamethod does not: error
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: 'D' object has no attribute 'mm'
</pre>
</blockquote>
<p>and they are not retrieved by <tt class="literal"><span class="pre">dir</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; attributes(D).keys() # mm is not retrieved, only cm
['cm']
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; cm.__get__('whatever') #under Python 2.2.0 would give a serious error
Segmentation fault
&gt;&gt;&gt; cm.__get__(None) #under Python 2.3 there is no error
&lt;bound method type.&lt;lambda&gt; of &lt;type 'NoneType'&gt;&gt;
</pre>
</blockquote>
<p>Moreover metamethods behaves differently with respect to multiple
inheritance. If a class A define a classmethod cA and a class B
defines a classmethod cB, then the class C(A,B) inherits both the
classmethods cA and cB. In the case of metamethods defined in M_A
and M_B, the same is true only if one resolves the meta-type
conflict by hand, by generating the metaclass M_C(M_A,M_B). In this
sense, classmethods are simpler to use than metamethods.</p>
</div>
</div>
<div class="section" id="the-magic-of-metaclasses-part-2">
<h1><a class="toc-backref" href="#id119" name="the-magic-of-metaclasses-part-2">THE MAGIC OF METACLASSES - PART 2</a></h1>
<p>Metaclasses are so powerful that a single chapter is not enough to make
justice to them ;) In this second chapter on metaclasses I will 
unravel their deepest secrets, covering topics such as meta-metaclasses,
anonymous inner metaclasses, global metaclasses and advanced class factories.</p>
<p>Moreover, I will give various magical applications of metaclasses,
in the realm of enhancing the Python language itself. Actually, this is
probably the most idiomatic application of metaclasses (Guido's examples
on the metaclass usage are all in this area). I will show
how metaclasses can be used to enhance the <tt class="literal"><span class="pre">super</span></tt> cooperatice call
mechanism.</p>
<p>This is not a chapter for the faint of heart.</p>
<div class="section" id="the-secrets-of-the-metaclass-hook">
<h2><a class="toc-backref" href="#id120" name="the-secrets-of-the-metaclass-hook">The secrets of the <tt class="literal"><span class="pre">__metaclass__</span></tt> hook</a></h2>
<p>In the previous chapter we have seen how the <tt class="literal"><span class="pre">__metaclass__</span></tt> hook can
be used as a way of metaclass enhancing pre-existing classes 
with a minimal change of the sourcecode.</p>
<p>But it has much deeper secrets.</p>
<p>The first and simplest of them, 
is the fact that the hook can be used it can also be defined 
at the module level, <em>outside</em> the class. This allows a number of neat 
tricks, since in presence of a  <tt class="literal"><span class="pre">__metaclass__</span></tt> hook at the module
level <em>all</em> the old style classes in the module (including nested ones!)
acquire that hook. A first application is to rejuvenate old style classes 
to new style classes.</p>
<p>I remind that old style classes are retained with compability with old 
code, but they are a pain in the back, if you want to use features 
intended for new style classes only (for instance properties etc.). 
Naively, one would expect the conversion from old style classes
to new style to be long and error prone: suppose you have a very large 
application with hundreds of old style classes defined in dozens of modules. 
Suppose you want to update your application to Python 2.2+ classes in order
to take advantage of the new features I have discussed extensively in this
book: the naive way to go would be to go trough the source, look for
all classes definitions and change</p>
<blockquote>
<pre class="literal-block">
Classname: --&gt; Classname(object)
</pre>
</blockquote>
<p>One could solve this problem with a regular expression search and replace
in all modules, but this would require to change <em>all</em> the source.
This is againt the spirit of OOP, we must <em>reuse</em> old code.</p>
<p>Metaclasses are particularly handy to solve this problem: actually it is
enough to add to your modules the following line as first line:</p>
<blockquote>
<pre class="literal-block">
__metaclass__ = type
</pre>
</blockquote>
<p>Then, all your old style classes will have 'type' as their metaclass: this
is akin to say that all the old style classes  are <em>automagically</em> rejuvenate 
to new style classes! And this also works for <em>nested</em> classes!!</p>
<blockquote>
<pre class="literal-block">
#&lt;rejuvenate.py&gt;

__metaclass__ = type # this rejuvanate all the class in the module

class C:
   class D: pass

print dir(C)   # both C and C.D
print dir(C.D) # are now new style classes

#&lt;/rejuvenate.py&gt;
</pre>
</blockquote>
<p>This very first example add consistence (if needed) to the
widespread belief that metaclasses have a well deserved reputation of magic.</p>
<p>The explanation is that defining a global metaclass called <tt class="literal"><span class="pre">__metaclass__</span></tt>
automatically makes all old style classes (new style class simply ignore 
the existence of the global <tt class="literal"><span class="pre">__metaclass__</span></tt>)  defined in you module 
instances of the given metaclass; this automatically converts them to 
new style classes.</p>
</div>
<div class="section" id="anonymous-inner-metaclasses">
<h2><a class="toc-backref" href="#id121" name="anonymous-inner-metaclasses">Anonymous inner metaclasses</a></h2>
<p>A second, deeper secret of the <tt class="literal"><span class="pre">__metaclass__</span></tt> hook is that it can be
used to define anonymous <em>inner metaclasses</em>. The following example
explain what I mean:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def totuple(arg):
    &quot;Converts the argument to a tuple, if need there is&quot;
    if isinstance(arg,tuple): return arg # do nothing
    else: return (arg,) # convert to tuple

class BracketCallable(object):
    &quot;&quot;&quot;Any subclass C(BracketCallable) can be called with the syntax C[t], 
    where t is a tuple of arguments stored in bracket_args;  returns the 
    class or an instance of it, depending on the flag 'returnclass'.&quot;&quot;&quot;

    returnclass=True
    class __metaclass__(type): # anonymous inner metaclass
        def __getitem__(cls,args): # non cooperative metamethod
            if cls.returnclass: 
                c=type(cls.__name__,(cls,),{'bracket_args':totuple(args)})
                return c # a customized copy of the original class
            else:
                self=cls(); self.bracket_args=totuple(args)
                return self

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>In this code 'BracketCallable.__metaclass__' is the anonymous (actually 
it has a special name, <tt class="literal"><span class="pre">__metaclass__</span></tt>) inner metaclass of 'BracketCallable'.</p>
<p>The effect of 'BracketCallable.__metaclass__' is the following: it makes
'BracketCallable' and its descendants callable with brackets. Since
the 'returnclass' flag is set, <tt class="literal"><span class="pre">__getitem__</span></tt> returns the class
with an attribute 'bracket_args' containing the tuple of the passed
arguments (otherwise it returns an instance of the class).
This works since when 
Python encounters an expression of kind <tt class="literal"><span class="pre">cls[arg]</span></tt> it interprets it 
as  <tt class="literal"><span class="pre">type(cls).__getitem__(cls,arg)</span></tt>. Therefore, if <tt class="literal"><span class="pre">cls</span></tt> is a subclass 
of  'BracketCallable', this means that</p>
<blockquote>
<pre class="literal-block">
cls[arg] &lt;=&gt; BracketCallable.__metaclass__.__getitem__(cls,arg)
</pre>
</blockquote>
<p>Let me give few examples:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import BracketCallable
&gt;&gt;&gt; type(BracketCallable)
&lt;class 'oopp.__metaclass__'&gt;
&gt;&gt;&gt; print type(BracketCallable).__name__ # not really anonymous
__metaclass__
&gt;&gt;&gt; print BracketCallable['a1'].bracket_args
('a1',)
&gt;&gt;&gt; print BracketCallable['a1','a2'].bracket_args
('a1', 'a2')
</pre>
</blockquote>
<p>This syntactical feature is an example of a thing that can be done 
<em>trough metaclasses only</em>: it cannot be emulated by functions.</p>
<p>Anonymous inner metaclasses are the least verbose manner 
of defining metamethods. Moreover, they are a neat trick to define 
mix-in classes that, when inherited, can metamagically enhance 
an entire multiple inheritance hierarchy.</p>
<p>In the previous example <tt class="literal"><span class="pre">__getitem__</span></tt> is noncooperative, but nothing
forbids anonymous inner metaclasses from being made cooperative. However,
there is some subtlety one must be aware of.
Let me give an example. My 'WithCounter' class counts how many instances
of 'WithCounter' and its subclasses are generated. However, it does not
distinguishes bewteen different subclasses. 
This was correct in the pizza shop example, simple only the total
number of produced pizzas mattered, however, in other situations,
one may want to reset the counter each time a new subclass is created. 
This can be done automagically by a cooperative inner metaclass:</p>
<blockquote>
<pre class="literal-block">
class WithMultiCounter(WithCounter):
    &quot;&quot;&quot;Each time a new subclass is derived, the counter is reset&quot;&quot;&quot;
    class __metaclass__(type):
        def __init__(cls,*args):
            cls.counter=0
            super(cls.__this,cls).__init__(*args)
    reflective(__metaclass__)
</pre>
</blockquote>
<p>Notice that the order of execution of this code is subtle:</p>
<ol class="arabic simple">
<li>first, the fact that WithMulticounter has a non-trivial metaclass is
registered, but nothing else is done;</li>
<li>then, the line <tt class="literal"><span class="pre">reflective(__metaclass__)</span></tt> is executed: this means
that the inner metaclass (and therefore its instances) get an
attribute <tt class="literal"><span class="pre">._metaclass__this</span></tt> containing a reference to the
inner metaclass;</li>
<li>then, the outer class is passed to its inner metaclass and created
by the inherited metaclass' <tt class="literal"><span class="pre">__new__</span></tt> method;</li>
<li>at this point  <tt class="literal"><span class="pre">cls</span></tt> exists and <tt class="literal"><span class="pre">cls.__this</span></tt> is inherited from
<tt class="literal"><span class="pre">__metaclass__._metaclass__this</span></tt>; this means that the expression
<tt class="literal"><span class="pre">super(cls.__this,cls).__init__(*args)</span></tt> is correctly recognized and
'WithMultiCounter' can be initialized;</li>
<li>only after that, the name 'WithMultiCounter' enters in the global namespace
and can be recognized.</li>
</ol>
<p>Notice in particular that inside <tt class="literal"><span class="pre">super</span></tt>, we could also
use <tt class="literal"><span class="pre">cls.__metaclass__</span></tt> instead of <tt class="literal"><span class="pre">cls.__this</span></tt>, but this
would not work inside <tt class="literal"><span class="pre">__new__</span></tt>, whereas <tt class="literal"><span class="pre">__this</span></tt> would be
recognized even in <tt class="literal"><span class="pre">__new__</span></tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; print MRO(WithMultiCounter)
1 - WithMultiCounter(WithCounter)[__metaclass__]
2 - WithCounter(object)
3 - object()
</pre>
</blockquote>
<p>For sake of readability, often it is convenient
to give a name even to inner classes:</p>
<pre class="literal-block">
#&lt;oopp.py&gt;

class WithMultiCounter(WithCounter):
    &quot;&quot;&quot;Each time a new subclass is derived, the counter is reset&quot;&quot;&quot;
    class ResetsCounter(type):
        def __init__(cls,*args):
            cls.counter=0
            super(cls.ResetsCounter,cls).__init__(*args)
    __metaclass__=ResetsCounter

#&lt;/oopp.py&gt;
</pre>
<p>Notice that inside super we used the expression <tt class="literal"><span class="pre">cls.ResetsCounter</span></tt> and
not <tt class="literal"><span class="pre">WithMultiCounter.ResetsCounter</span></tt>: doing that would generate a
<tt class="literal"><span class="pre">NameError:</span> <span class="pre">global</span> <span class="pre">name</span> <span class="pre">'WithMultiCounter'</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">defined</span></tt> since at the
time when  <tt class="literal"><span class="pre">ResetsCounter.__init__</span></tt> is called for the first time, 
the class <tt class="literal"><span class="pre">WithMultiCounter</span></tt> exists but is has not yet entered the global
namespace: this will happens only after the initialization in the
<tt class="literal"><span class="pre">ResetsCounter</span></tt> metaclass, as we said before.</p>
<p>Without the metaclass one can reset the counter by hand each time, or
can reset the counter on all the classes of the hierarchy with a
convenient function (akin to the 'traceH' routine defined in chapter 6).</p>
<p>Example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; class GrandFather(WithMultiCounter): pass
&gt;&gt;&gt; class Father(GrandFather): pass
&gt;&gt;&gt; class Child(Father): pass
&gt;&gt;&gt; GrandFather()
&lt;__main__.GrandFather object at 0x402f7f6c&gt; # first GrandFather instance
&gt;&gt;&gt; Father()
&lt;__main__.Father object at 0x402f79ec&gt; # first Father instance
&gt;&gt;&gt; Father()
&lt;__main__.Father object at 0x402f7d4c&gt; # second Father instance
&gt;&gt;&gt; Child.counter # zero instances
0
&gt;&gt;&gt; Father.counter # two instances
2
&gt;&gt;&gt; GrandFather.counter # one instance
1
</pre>
</blockquote>
<p>I leave as an exercise for the reader to show that the original 'WithCounter'
would fail to count correctly the different subclasses and would put the 
total number of instances in 'Child'.</p>
</div>
<div class="section" id="passing-parameters-to-meta-classes">
<h2><a class="toc-backref" href="#id122" name="passing-parameters-to-meta-classes">Passing parameters to (meta) classes</a></h2>
<p>Calling a class with brackets is a way of passing parameters to it (or
to its instances, if the 'returnclass' flag is not set). 
There additional ways for of doing that. 
One can control the instantiation syntax of classes by redefining the 
<tt class="literal"><span class="pre">__call__</span></tt> method of the metaclass. The point is that when we instantiate 
an object with the syntax <tt class="literal"><span class="pre">c=C()</span></tt>, Python looks
at the <tt class="literal"><span class="pre">__call__</span></tt> method of the metaclass of 'C'; the default behaviour
it is to call <tt class="literal"><span class="pre">C.__new__</span></tt> and <tt class="literal"><span class="pre">C.__init__</span></tt> in succession, however, that
behavior can be overridden. Let me give an example without using
anonymous metaclasses (for sake of clarity only).</p>
<blockquote>
<pre class="literal-block">
#&lt;metacall.py&gt;

class M(type): # this is C metaclass
    def __call__(cls):
        return &quot;Called M.__call__&quot; 

C=M('C',(),{}) # calls type(M).__call__
c=C() # calls type(C).__call__
# attention: c is a string!
print c #=&gt; Called M.__call__

#&lt;/metacall.py&gt;
</pre>
</blockquote>
<p>In this example, <tt class="literal"><span class="pre">M.__call__</span></tt> simply 
returns the string <tt class="literal"><span class="pre">Called</span> <span class="pre">M.__call__</span></tt>, and the class
'C' is <em>not</em> instantiated. Overriding the metaclass
<tt class="literal"><span class="pre">__call__</span> <span class="pre">``</span> <span class="pre">method</span> <span class="pre">therefore</span> <span class="pre">provides</span> <span class="pre">another</span> <span class="pre">way</span> <span class="pre">to</span> <span class="pre">implement</span>
<span class="pre">the</span> <span class="pre">``Singleton</span></tt> pattern. However, savage overridings as the one in
this example, are not a good idea, since it will confuse everybody.
This is an example where metaclasses change the semantics: whereas
usually the notation <tt class="literal"><span class="pre">C()</span></tt> means &quot;creates a C instance&quot;, the
metaclass can give to the syntax <tt class="literal"><span class="pre">C()</span></tt> any meaning we want.
Here there is both the power and the danger of metaclasses: they
allows to make both miracles and disasters. Nevertheless, used with
a grain of salt, they provide a pretty nice convenience.</p>
<p>Anyway, overriding the '__call__' method of the metaclass can be 
confusing, since parenthesis are usually reserved to mean instantion,
therefore I will prefere to pass arguments trough brackets.</p>
<p>The beauty and the magic of metaclasses stays in the fact that this mechanism 
is completely general: since metaclasses themselves are classes, we can
'CallableWithBrackets' to pass arguments to a metaclass, i.e.
'CallableWithBrackets' can also be used as a meta-metaclass!</p>
<p>I leave as an exercise for the reader to figure out
how to define meta-meta-metaclasses, meta-meta-meta-metaclasses, etc.
etc. (there is no limit to the abstraction level you can reach with 
metaclasses;-)</p>
<p>Let me show an example: a magical way of making methods cooperative.
This can be done trough a 'Cooperative' metaclass that inherits from
'BracketCallable' and therefore has 'BracketCallable.__metaclass__'
as (meta)metaclass:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Cooperative(BracketCallable,type):
    &quot;&quot;&quot;Bracket-callable metaclass implementing cooperative methods. Works
    well for plain methods returning None, such as __init__&quot;&quot;&quot;
    def __init__(cls,*args):
        methods=cls.bracket_args
        for meth in methods: 
            setattr(cls,meth,cls.coop_method(meth,vars(cls).get(meth)))
    def coop_method(cls,name,method): # method can be None
        &quot;&quot;&quot;Calls both the superclass method and the class method (if the 
        class has an explicit method). Implemented via a closure&quot;&quot;&quot;
        def _(self,*args,**kw):
            getattr(super(cls,self),name)(*args,**kw) # call the supermethod
            if method: method(self,*args,**kw) # call the method
        return _

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>The code above works for methods returing <tt class="literal"><span class="pre">None</span></tt>, such as <tt class="literal"><span class="pre">__init__</span></tt>.
Here I give a first example of application: a hierarchy where the <tt class="literal"><span class="pre">__init__</span></tt>
methods are automatically called (similar to automatic initialization
in Java).</p>
<blockquote>
<pre class="literal-block">
#&lt;cooperative.py&gt;

from oopp import Cooperative

class B(object):
    &quot;&quot;&quot;Cooperative base class; all its descendants will automagically 
    invoke their ancestors __init__ methods in chain.&quot;&quot;&quot;
    __metaclass__=Cooperative['__init__']
    def __init__(self,*args,**kw):
        print &quot;This is B.__init__&quot;

class C(B):
    &quot;Has not explicit __init__&quot;

class D(C):
    &quot;&quot;&quot;The metaclass makes D.__init__ to call C.__init__ and 
    therefore B.__init__&quot;&quot;&quot;
    def __init__(self,*args,**kw):
        print &quot;This is D.__init__&quot;

d=D()

print &quot;The metaclass of B is&quot;,type(B)
print &quot;The meta-metaclass of B is&quot;, type(type(B))

#&lt;/cooperative.py&gt;
</pre>
</blockquote>
<p>Output:</p>
<blockquote>
<pre class="literal-block">
This is B.__init__
This is D.__init__
The metaclass of B is &lt;class 'oopp.Cooperative'&gt;
The meta-metaclass of B  is &lt;class 'oopp.__metaclass__'&gt;
</pre>
</blockquote>
<p>A second example, is the following, an alternative way of
making the paleoanthropological hierarchy of chapter 4 cooperative:</p>
<blockquote>
<pre class="literal-block">
#&lt;paleo.py&gt;

from oopp import Cooperative,Homo

class HomoHabilis(Homo):
    __metaclass__=Cooperative['can']
    def can(self):
        print &quot; - make tools&quot;

class HomoSapiens(HomoHabilis):
    def can(self):
        print &quot; - make abstractions&quot;
    
class HomoSapiensSapiens(HomoSapiens):
    def can(self):
        print &quot; - make art&quot;

HomoSapiensSapiens().can()

# Output:

# &lt;HomoSapiensSapiens&gt; can:
#  - make tools
#  - make abstractions
#  - make art

#&lt;/paleo.py&gt;
</pre>
</blockquote>
<p>Metaclasses can be used to violate the old good rule &quot;explicit is
better than implicit&quot;. Looking at the source code for 'HomoSapiens'
and 'HomoSapiensSapiens' one would never imagine the <tt class="literal"><span class="pre">can</span></tt> is
somewhat special. That is why in the following I will prefer to
use the anonymous super call mechanism, which is explicit, instead
of the implicit cooperative mechanism.</p>
</div>
<div class="section" id="meta-functions">
<h2><a class="toc-backref" href="#id123" name="meta-functions">Meta-functions</a></h2>
<p>The third and deepest secret of the <tt class="literal"><span class="pre">__metaclass__</span></tt> hook is that, even if
it is typically used in conjunction with metaclasses, actually the hook 
can refer to generic class factories callable with the signature
<tt class="literal"><span class="pre">(name,bases,dic)</span></tt>. Let me show a few examples 
where <tt class="literal"><span class="pre">__metaclass__</span></tt> is a function or a generic callable object
instead of being a metaclass:</p>
<blockquote>
<pre class="literal-block">
#&lt;metafun.py&gt;

from oopp import kwdict

class Callable(object):
    def __call__(self,name,bases,dic):
        print name,bases,'\n',kwdict(dic)
        return type(name,bases,dic)

callableobj=Callable()

class C: __metaclass__=callableobj

print &quot;type of C:&quot;,C.__class__

def f(name,bases,dic):
    print name,bases,'\n',kwdict(dic)
    return type(name,bases,dic)

class D: __metaclass__=f

print &quot;type of D:&quot;,D.__class__

class B(object):
    def __metaclass__(name,bases,dic):
        &quot;&quot;&quot;In this form, the __metaclass__ attribute is a function. 
        In practice, it works as a special static method analogous 
        to __new__&quot;&quot;&quot;
        print &quot;name: &quot;, name
        print &quot;bases:&quot;, bases
        print &quot;dic:\n&quot;,kwdict(dic)
        return type(name,bases,dic)

class E(B): pass

print &quot;type of E:&quot;,E.__class__
print &quot;Non-called E.__metaclass__:&quot;, E.__metaclass__

#&lt;/metafun.py&gt;
</pre>
</blockquote>
<p>With output</p>
<blockquote>
<pre class="literal-block">
C () 
__metaclass__ = &lt;Callable object at 0x401c964c&gt;
__module__ = __builtin__
type of C: &lt;type 'type'&gt;
D () 
__metaclass__ = &lt;function f at 0x401c4994&gt;
__module__ = __builtin__
type of D: &lt;type 'type'&gt;
name:  B
bases: (&lt;type 'object'&gt;,)
dic: 
__metaclass__ = &lt;function __metaclass__ at 0x401c4a3c&gt;
__module__ = __builtin__
type of E: &lt;type 'type'&gt;
Non-called E.__metaclass__: &lt;unbound method E.__metaclass__&gt;
</pre>
</blockquote>
<p>The advantage/disadvantage of this solution is that the <tt class="literal"><span class="pre">__metaclass__</span></tt> 
hook is called only once, i.e. it is not called again if a new class
is derived from the original one. For instance in this example 'E' is
derived from 'B', but the function <tt class="literal"><span class="pre">B.__metaclass__</span></tt> is <em>not</em> called
during the creation of 'E'.</p>
<p>Metafunctions can also be used when one does not want to transmit the
metaclass contraint. Therefore they usage is convenient in exactly
the opposite situation of a cooperative metaclass.</p>
</div>
<div class="section" id="anonymous-cooperative-super-calls">
<h2><a class="toc-backref" href="#id124" name="anonymous-cooperative-super-calls">Anonymous cooperative super calls</a></h2>
<p>As I noticed in the previous chapters, the <tt class="literal"><span class="pre">super</span></tt> 
mechanism has an annoying 
problem: one needs to pass explicitely the name of the base class. Typically, 
this is simply an 
inelegance since it is annoying to be forced to retype the name of the base 
class. However, in particular
cases, it can be a problem. This happens for instance if we try to
pass the class's methods to a different class: one cannot do that,
since the methods contains an explicit reference to the original class
and would not work with the new one. Moreover, having named super calls
is annoying in view of refactoring. Consider for
instance the previous <tt class="literal"><span class="pre">supernew.py</span></tt> script: in the <tt class="literal"><span class="pre">__new__</span></tt> method
defined inside the class 'B', we called <tt class="literal"><span class="pre">Super</span></tt> with the syntax
<tt class="literal"><span class="pre">Super(B,cls)</span></tt> by repeating the name of the class 'B'. Now,
if in the following I decide to give to 'B' a more descriptive
name, I have to go trough the source, search all the <tt class="literal"><span class="pre">super</span></tt>
calls, and change them accordingly to the new name. It would be
nice having Python do the job for me. A first solution is to call
<tt class="literal"><span class="pre">super</span></tt> (or <tt class="literal"><span class="pre">Super</span></tt>) with the syntax <tt class="literal"><span class="pre">super(self.__this,obj)</span></tt>,
where the special name <tt class="literal"><span class="pre">__this</span></tt> is explicitly replaced by the name 
of the class where the call is defined by the 'reflective' function
of last chapter. This approach has the disadvantage that each time we
derive a new class, we need to invoke <em>explicitely</em> the routine 
<tt class="literal"><span class="pre">reflective</span></tt>. It would be marvelous to instruct Python to invoke
<tt class="literal"><span class="pre">reflective</span></tt> automatically at each class creation. Actually, this
seems to be deep magic and indeed it is: fortunately, a custom metaclass 
can perform this deep magic in few lines:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;
  
class Reflective(type):
    &quot;&quot;&quot;Cooperative metaclass that defines the private variable __this in
    its instances. __this contains a reference to the class, therefore
    it allows anonymous cooperative super calls in the class.&quot;&quot;&quot;
    def __init__(cls,*args):
        super(Reflective,cls).__init__(*args)
        reflective(cls)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Now, let me show how 'Reflective' can be used in a practical example.</p>
<p>By deriving new metaclasses from 'Reflective', one can easily 
create powerful class factories that generate reflective classes.</p>
<p>Suppose I want to define a handy class 
factory with the abilitity of counting the number of its instances.</p>
<p>This can be done by noticing that metaclasses are just classes, therefore 
they can be composed with regular classes in multiple inheritance. In 
particular one can derive a 'Logged' metaclass from 'WithLogger': in
this way we send a message to a log file each time a new class is created.
This can be done by composing 'WithLogger' with 'WithMultiCounter.__metaclass__'
and with 'Reflective':</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Logged(WithLogger,Reflective): 
    &quot;&quot;&quot;Metaclass that reuses the features provided by WithLogger. In particular
    the classes created by Logged are Reflective, PrettyPrinted 
    and Customizable.&quot;&quot;&quot; #WithLogger provides logfile and verboselog
    def __init__(cls,*args,**kw):
        super(Logged,cls).__init__(*args,**kw) 
        bases=','.join([c.__name__ for c in cls.__bases__])
        print &gt;&gt; cls.logfile, &quot;%s is a child of %s&quot; % (cls,bases)
        print &gt;&gt; cls.logfile,'and an instance of %s' % type(cls).__name__

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>The MRO is</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print MRO(Logged)
MRO of Logged:
  0 - Logged(WithLogger,Reflective)
  1 - WithLogger(WithCounter,PrettyPrinted)
  2 - WithCounter(object)
  3 - PrettyPrinted(object)
  4 - Reflective(type)
  5 - type(object)
  6 - object()
</pre>
</blockquote>
<p>and the inheritance graph can be drawn as follows:</p>
<blockquote>
<pre class="literal-block">
       _____________________ object 6 ___
      /                        /         \
2 WithCounter        3 PrettyPrinted        type 5
         \                /               /
          \              /               /
           \            /               /
            \          /               /
             \        /               /
              \      /               /
             1 WithLogger       Reflective 4
                  \           /
                   \         /
                    \       /
                     \     /
                Logged 0
                        :
                        :
                        C1
</pre>
</blockquote>
<p>'WithCounter' acts now as a metaclass, since WithCounter.__new__ invokes
type.__new__. Since <tt class="literal"><span class="pre">type.__new__</span></tt> is non-cooperative,
in the composition of a metaclass with a regular class, the metaclass
should be put first: this guarantees that <tt class="literal"><span class="pre">__new__</span></tt> derives from
<tt class="literal"><span class="pre">type.__new__</span></tt>, thus avoiding the error message.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; Logged.verboselog=True
&gt;&gt;&gt; C1=Logged('C1',(),{})
*****************************************************************************
Tue Apr 22 18:47:05 2003
1. Created 'C1'
with accessibile non-special attributes:
_C1__this = 'C1'
'C1' is a child of object
and an instance of Logged
</pre>
</blockquote>
<p>Notice that any instance of 'WithCounterReflective' inherits the 'WithCounter' 
attribute <tt class="literal"><span class="pre">counter</span></tt>, that counts the number of classes that have been 
instantiated (however it is not retrieved by <tt class="literal"><span class="pre">dir</span></tt>; moreover the 
instances of 'WithCounterReflective' instances have no <tt class="literal"><span class="pre">counter</span></tt> attribute).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; C1.counter
1
</pre>
</blockquote>
</div>
<div class="section" id="more-on-metaclasses-as-class-factories">
<h2><a class="toc-backref" href="#id125" name="more-on-metaclasses-as-class-factories">More on metaclasses as class factories</a></h2>
<p>A slight disadvantage of the approach just described, 
is that 'Logged'  cooperatively invokes the <tt class="literal"><span class="pre">type.__new__</span></tt> 
static method, therefore, when we invoke the metaclass, we must explicitly 
provide a name, a tuple of base classes and a dictionary, since the 
<tt class="literal"><span class="pre">type.__new__</span></tt> staticmethod requires that signature. Actually, 
the expression</p>
<blockquote>
<pre class="literal-block">
C=Logged(name,bases,dic)
</pre>
</blockquote>
<p>is roughly syntactic sugar for</p>
<blockquote>
<pre class="literal-block">
C=Logged.__new__(Logged,name,bases,dic) 
assert isinstance(C,Logged)
Logged.__init__(C,name,bases,dic)
</pre>
</blockquote>
<p>If a different interface is desired, the best way is to use a class
factory 'ClsFactory' analogous to the object factory 'Makeobj' 
defined in chapter 4. It is convenient to make 'ClsFactory'
bracket-callable.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class ClsFactory(BracketCallable):
    &quot;&quot;&quot;Bracket callable non-cooperative class acting as 
    a factory of class factories.

    ClsFactory instances are class factories accepting 0,1,2 or 3 arguments. 
  . They automatically converts functions to static methods 
    if the input object is not a class. If an explicit name is not passed
    the name of the created class is obtained by adding an underscore to 
    the name of the original object.&quot;&quot;&quot;
    
    returnclass=False # ClsFactory[X] returns an *instance* of ClsFactory

    def __call__(self, *args):
        &quot;&quot;&quot;Generates a new class using self.meta and avoiding conflicts.
        The first metaobject can be a dictionary, an object with a
        dictionary (except a class), or a simple name.&quot;&quot;&quot;
        
        # default attributes
        self.name=&quot;CreatedWithClsFactory&quot;    
        self.bases=()
        self.dic={}
        self.metas=self.bracket_args

        if len(args)==1:
            arg=args[0]
            if isinstance(arg,str): # is a name 
                self.name=arg
            elif hasattr(arg,'__name__'): # has a name
                self.name=arg.__name__+'_'
            self.setbasesdic(arg)
        elif len(args)==2: 
            self.name=args[0] 
            assert isinstance(self.name,str) # must be a name
            self.setbasesdic(args[1])
        elif len(args)==3: # must be name,bases,dic
            self.name=args[0]
            self.bases+=args[1]
            self.dic.update(args[2])
        if len(args)&lt;3 and not self.bases: # creating class from a non-class
            for k,v in self.dic.iteritems():
                if isfunction(v): self.dic[k]=staticmethod(v)
        #return child(*self.bases,**vars(self))
        return makecls(*self.metas)(self.name,self.bases,self.dic)

    def setbasesdic(self,obj):
        if isinstance(obj,tuple): # is a tuple
            self.bases+=obj
        elif hasattr(obj,'__bases__'): # is a class
            self.bases+=obj.__bases__
        if isinstance(obj,dict): # is a dict
            self.dic.update(obj)
        elif hasattr(obj,&quot;__dict__&quot;): # has a dict
            self.dic.update(obj.__dict__)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>'ClsFactory[X]' where 'X' is a metaclass returns callable objects acting as
class factories. For instance</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

Class=ClsFactory[type] # generates non-conflicting classes
Mixin=ClsFactory[Reflective] # generates reflective classes
  
#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>can be used as a class factories that automatically provides a default name,
base classes and dictionary, and avoids meta-type conflicts.
'Mixin' generates reflective classes that can be used as mixin in multiple
inheritance hierarchies. Here I give few example of usage of 'Class':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; C1,C2,C3=[Class('C'+str(i+1)) for i in range(3)]
&gt;&gt;&gt; C1
&lt;class 'oopp.C1'&gt;
&gt;&gt;&gt; C2
&lt;class 'oopp.C2'&gt;
&gt;&gt;&gt; C3
&lt;class 'oopp.C3'&gt;]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; Clock=Class('Clock',{'get_time':get_time})
&gt;&gt;&gt; Clock
&lt;class 'oopp.Clock'&gt;
&gt;&gt;&gt; Clock.get_time()
16:01:02
</pre>
</blockquote>
<p>Another typical usage of 'Class' is the conversion of a module in a class: 
for instance</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; time_=Class(time)
&gt;&gt;&gt; time_
&lt;class 'oopp.time_'&gt;
</pre>
</blockquote>
<p>Notice the convention of adding an underscore to the name of the class 
generated from the 'time' module.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; time_.asctime()
'Mon Jan 20 16:33:21 2003'
</pre>
</blockquote>
<p>Notice that all the functions in the module <tt class="literal"><span class="pre">time</span></tt> has been magically 
converted in staticmethods of the class <tt class="literal"><span class="pre">time_</span></tt>. An advantage of this 
approach is that now the module is a class and can be enhanced with 
metaclasses: for instance we could add tracing capabilities, debugging 
features, etc.</p>
<p>By design, 'Class' and 'Reflective' also works when the first argument 
is a class or a tuple of base classes:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ClsFactory_=Class(ClsFactory)
&gt;&gt;&gt; type(ClsFactory_)
&lt;class 'oopp.__metaclass__'&gt;
&gt;&gt;&gt; ClsFactory_=Mixin(ClsFactory) 
&gt;&gt;&gt; type(ClsFactory_) # automagically generated metaclass
&lt;class 'oopp._Reflective__metaclass__'&gt;
</pre>
</blockquote>
</div>
<div class="section" id="programming-with-metaclasses">
<h2><a class="toc-backref" href="#id126" name="programming-with-metaclasses">Programming with metaclasses</a></h2>
<p>In order to how a non-trivial application of metaclasses in real life,
let me come back to the pizza shop example discussed in chapter 4 and 6.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def Pizza(toppings,**dic): 
     &quot;&quot;&quot;This function produces classes inheriting from GenericPizza and 
     WithLogger, using a metaclass inferred from Logged&quot;&quot;&quot;
     toppinglist=toppings.split()
     name='Pizza'+''.join([n.capitalize() for n in toppinglist])
     dic['toppinglist']=toppinglist
     return ClsFactory[Logged](name,
            (GenericPizza,WithLogger,WithMultiCounter),dic)

#&lt;/oopp.py&gt;

&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; Margherita=Pizza('tomato mozzarella',verboselog=True)
*****************************************************************************
Tue May 13 14:42:17 2003
1. Created 'PizzaTomatoMozzarella'
with accessibile non-special attributes:
ResetsCounter = &lt;class 'oopp.ResetsCounter'&gt;
_GenericPizza__this = &lt;class 'oopp.GenericPizza'&gt;
_WithCounter__this = &lt;class 'oopp.WithCounter'&gt;
_WithLogger__this = &lt;class 'oopp.WithLogger'&gt;
baseprice = 1
counter = 0
formatstring = %s
logfile = &lt;open file '&lt;stdout&gt;', mode 'w' at 0x402c2058&gt;
price = &lt;unbound method PizzaTomatoMozzarella.price&gt;
sizefactor = {'small': 1, 'large': 3, 'medium': 2}
topping_unit_price = 0.5
toppinglist = ['tomato', 'mozzarella']
toppings_price = &lt;unbound method PizzaTomatoMozzarella.toppings_price&gt;
verboselog = True
'PizzaTomatoMozzarella' is a child of GenericPizza,WithLogger,
WithMultiCounter and an instance of _LoggedResetsCounter
</pre>
</blockquote>
<p>Notice the <em>deep</em> magic: <tt class="literal"><span class="pre">Pizza</span></tt> invokes <tt class="literal"><span class="pre">ClsFactory[Logged]</span></tt> which in 
turns calls the class factory <tt class="literal"><span class="pre">child</span></tt> that creates 'Margherita' from 
'GenericPizza', 'WithLogger' and 'WithMultiCounter' by using the
metaclass 'Logged': however, since 'WithMultiCounter', has the internal
metaclass 'ResetsCounter' , there is a metatype conflict:
<tt class="literal"><span class="pre">child</span></tt> <em>automagically</em> solves the conflict by creating the metaclass
'_LoggedResetsCounter' that inherits both from 'Logged' and 'ResetsCounter'. 
At this point, 'Margherita' can be safely created
by '_LoggedResetsCounter'. As such, the creation of 'Margherita'
will be registered in the log file and 'Margherita' (with all its
children) will continue to be able to recognize the special identifier 
<tt class="literal"><span class="pre">this</span></tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print Margherita('large')
*****************************************************************************
Tue May 13 14:47:03 2003
1. Created large pizza with tomato,mozzarella, cost $ 6.0
with accessibile non-special attributes:
ResetsCounter = &lt;class 'oopp.ResetsCounter'&gt;
_GenericPizza__this = &lt;class 'oopp.GenericPizza'&gt;
_WithCounter__this = &lt;class 'oopp.WithCounter'&gt;
_WithLogger__this = &lt;class 'oopp.WithLogger'&gt;
baseprice = 1
counter = 1
formatstring = %s
logfile = &lt;open file '&lt;stdout&gt;', mode 'w' at 0x402c2058&gt;
price = &lt;bound method PizzaTomatoMozzarella.price of 
&lt;oopp.PizzaTomatoMozzarella object at 0x4032764c&gt;&gt;
size = large
sizefactor = {'small': 1, 'large': 3, 'medium': 2}
topping_unit_price = 0.5
toppinglist = ['tomato', 'mozzarella']
toppings_price = &lt;bound method PizzaTomatoMozzarella.toppings_price of 
&lt;oopp.PizzaTomatoMozzarella object at 0x4032764c&gt;&gt;
verboselog = True
large pizza with tomato,mozzarella, cost $ 6.0
&gt;&gt;&gt; print MRO(Margherita)
MRO of PizzaTomatoMozzarella:
  0 - PizzaTomatoMozzarella(GenericPizza,WithLogger)[_LoggedResetsCounter]
  1 - GenericPizza(object)
  2 - WithLogger(WithCounter,Customizable,PrettyPrinted)
  3 - WithMultiCounter(WithCounter)[ResetsCounter]
  4 - WithCounter(object)
  5 - PrettyPrinted(object)
  6 - object()
</pre>
</blockquote>
<p>Notice that</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print Margherita
'PizzaTomatoMozzarella'
</pre>
</blockquote>
<p>The power of inheritance in this example is quite impressive, since
I have reused the same class 'WithLogger' (and its children) both in the 
metaclass hierarchy and in the regular hierarchy: this means that I have added
logging capabilities both to classes and their instances in a
strike! And there is no confusion between the two. For instance,
there is a <tt class="literal"><span class="pre">counter</span></tt> attribute for the metaclass 'Logged' 
and many independent <tt class="literal"><span class="pre">counter</span></tt> attributes for any generated class,
i.e. for any kind of pizza.</p>
<blockquote>
It is interesting to notice that '' itself is an instance of
its inner metaclass, as <tt class="literal"><span class="pre">type()</span></tt> would show. This technique
avoids the need for inventing a new name for the metaclass. The inner
metaclass is automatically inherited by classes inheriting from the outer
class.</blockquote>
</div>
<div class="section" id="metaclass-aided-operator-overloading">
<h2><a class="toc-backref" href="#id127" name="metaclass-aided-operator-overloading">Metaclass-aided operator overloading</a></h2>
<p>As we discussed in chapter 4, inheriting from built-in types is generally
painful. The problem is that if P is a primitive class, i.e. a 
Python built-in type, and D=D(P) is a derived class, then the 
primitive methods returning P-objects have to be modified (wrapped) in 
such a way to return D-objects.</p>
<p>The problem is expecially clear in the context of operator overloading.</p>
<p>Consider for instance the problem of defining a 'Vector' class in the 
mathematical sense. Mathematically-speaking, vectors are defined as objects 
that can be summed each other and multiplied by numbers; they can be represented 
by (finite or infinite) sequences. In the case of finite sequences, vectors 
can be represented with lists and a vector class can be naturally
implemented by subclassing <tt class="literal"><span class="pre">list</span></tt>:</p>
<blockquote>
<pre class="literal-block">
#&lt;vector.py&gt;

class Vector(list):
    &quot;&quot;&quot;Implements finite dimensional vectors as lists. Can be instantiated
    as Vector([a,b,c,..]) or as Vector(a,b,c ..)&quot;&quot;&quot;
    def __add__(self,other):
        return [el+other[i] for i,el in enumerate(self)]
    __radd__=__add__
    def __mul__(self,scalar):
        return [el*scalar for el in self]
    def __rmul__(self,scalar):
        return [scalar*el for el in self]

v=Vector([1,0])
w=Vector([0,1])

print v+w, type(v+w) 
print 2*v, type(2*v) 
print v*2, type(v*2) 

#&lt;/vector.py&gt;
</pre>
</blockquote>
<p>With output</p>
<blockquote>
<pre class="literal-block">
[1, 1] &lt;type 'list'&gt;
[2, 0] &lt;type 'list'&gt;
[2, 0] &lt;type 'list'&gt;
</pre>
</blockquote>
<p>The problem is that the overloaded methods must be wrapped in such a way
to return <tt class="literal"><span class="pre">Vector</span></tt> object and not <tt class="literal"><span class="pre">list</span></tt> object; moreover, if
<tt class="literal"><span class="pre">Vector</span></tt> is subclassed (for instance by defining a <tt class="literal"><span class="pre">NumericVector</span></tt>),
the overloaded methods must return instances of the subclass. There is
only one way of doing that automatically: trough the magic of metaclasses.</p>
<p>Here is the solution, involving an <tt class="literal"><span class="pre">autowrappedmethod</span></tt> descriptor class,
that wraps the overloaded operators and is automatically invoked by
the metaclass <tt class="literal"><span class="pre">AutoWrapped</span></tt>.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class autowrappedmethod(wrappedmethod):
    &quot;&quot;&quot;Makes the method returning cls instances, by wrapping its
    output with cls&quot;&quot;&quot;
    klass=None # has to be fixed dynamically from outside
    def __init__(self,meth):
        super(autowrappedmethod,self).__init__(meth) # cooperative
        self.klass=self.klass # class variable -&gt; instance variable
    def wrapper(self): # closure
        return lambda *args,**kw: self.klass(self.func(*args,**kw))

class AutoWrapped(type):
    &quot;&quot;&quot;Metaclass that looks at the methods declared in the attributes 
    builtinlist and wraplist of its instances and wraps them with
    autowrappedmethod.&quot;&quot;&quot;
    def __init__(cls,name,bases,dic):
        super(AutoWrapped,cls).__init__(name,bases,dic) # cooperative
        cls.builtinlist=getattr(cls,'builtinlist',[])
        if not hasattr(cls,'diclist') : # true only at the first call
            cls.diclist=[(a,vars(bases[0])[a]) for a in cls.builtinlist]
        if dic.has_key('wraplist'): # can be true at any call
            cls.diclist+=[(a,dic[a]) for a in cls.wraplist] 
        wrapper=autowrappedmethod.With(klass=cls)
        d=dict([(a,wrapper(v)) for a,v in cls.diclist])
        customize(cls,**d)
    
#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Now the <tt class="literal"><span class="pre">Vector</span></tt> class can be written as</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Vector(list):
    &quot;&quot;&quot;Implements finite dimensional vectors as lists. Can be instantiated
    as Vector([a,b,c,..]) or as Vector(a,b,c ..)&quot;&quot;&quot;
    __metaclass__=AutoWrapped
    wraplist='__add__ __radd__ __mul__ __rmul__'.split()
    def __add__(self,other):
        return [el+other[i] for i,el in enumerate(self)]
    __radd__=__add__
    def __mul__(self,scalar):
        return [scalar*el for el in self]
    def __rmul__(self,scalar):
        return [el*scalar for el in self]

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here the <tt class="literal"><span class="pre">AutoWrapped</span></tt> metaclass wraps the output of <tt class="literal"><span class="pre">__add__,</span> 
<span class="pre">__radd__,</span> <span class="pre">__mul__,</span> <span class="pre">__rmul__</span></tt>, guaranteeing that they returns <tt class="literal"><span class="pre">Vector</span></tt>
instances or instances of some subclass of <tt class="literal"><span class="pre">Vector</span></tt>, if <tt class="literal"><span class="pre">Vector</span></tt> is
subclassed. This is an example of usage:</p>
<blockquote>
<!-- doctest -->
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Vector
&gt;&gt;&gt; v=Vector([1,0])
&gt;&gt;&gt; v
&lt;oopp.Vector object at 0x4032858c&gt;
&gt;&gt;&gt; w=Vector([0,1])
&gt;&gt;&gt; v+2*w
&lt;oopp.Vector object at 0x403190ac&gt;
&gt;&gt;&gt; print v+2*w
[1, 2]
</pre>
</blockquote>
<p>It should be clear by now that metaclasses are the natural framework where
to discuss operator overloading
(at least in languages that have metaclasses ;-). After all, operator
overloading is another kind of (very nice) syntactic sugar and we know
already that metaclasses are very good when we need syntactic sugar.</p>
</div>
</div>
<div class="section" id="advanced-metaprogramming-techniques">
<h1><a class="toc-backref" href="#id128" name="advanced-metaprogramming-techniques">ADVANCED METAPROGRAMMING TECHNIQUES</a></h1>
<p>In elementary OOP, the programmer works with objects; in advanced OOP,
the programmer works with classes, taking full advantage of
(multiple) inheritance and metaclasses. Metaprograming is the activity of 
building, composing and modifying classes.</p>
<p>I will give various examples of metaprogramming techniques
using run-time class modifications
multiple inheritance, metaclasses, attribute descriptors and
even simple functions.</p>
<p>Moreover, I will show show metaclasses can change the
semantics of Python programs: hence theire reputation of <em>black</em> magic. 
That is to say that the techniques explained here are dangerous!</p>
<div class="section" id="on-code-processing">
<h2><a class="toc-backref" href="#id129" name="on-code-processing">On code processing</a></h2>
<p>It is a good programming practice to avoid the direct modification
of source code. Nevertheless, there are situations where the ability of 
modifying the source code <em>dynamically</em> is invaluable. Python has the
capability of</p>
<ol class="arabic simple">
<li>generating new code from scratch;</li>
<li>modifying pre-existing source code;</li>
<li>executing the newly created/modified code at run-time.</li>
</ol>
<p>The capability of creating source code and executing it <em>immediately</em> has
no equivalent in static languages such as C/C++/Java and it is maybe the 
most poweful feature of dynamics languages such as Java/Python/Perl.
This feature has been exploited to its ultimate consequences in the languages
of the Lisp family, in which one can use incredibly poweful macros, which
in a broad sense, are programs that write themselves</p>
<p>In this chapter I will discuss how to implement macros in Python and I will
present some of the miracles you may perform with this technique. To this
aim, I will discuss various ways of manipulating Python source code, by
using regular expressions and state machines.</p>
</div>
<div class="section" id="regular-expressions">
<h2><a class="toc-backref" href="#id130" name="regular-expressions">Regular expressions</a></h2>
<blockquote>
<pre class="line-block">
<em>Some people, when confronted with a problem, 
think &quot;I know, I'll use regular expressions.&quot; 
Now they have two problems.</em>
   -- Jamie Zawinski
</pre>
</blockquote>
<p>Python source code is a kind of text and can manipulated with the same
techniques that are used to manipulate text:</p>
<ol class="arabic simple">
<li>the trivial search and replace;</li>
<li>regular expressions;</li>
<li>state machines;</li>
<li>parsers</li>
</ol>
<p>There is not very much to say about the search and replace methods: it
is fast, efficient and it works. It should always be used whenever
possible. However, in this chapter I will only be interested in cases
where something more sophisticated than a plain search and replace is
needed. Cases that can be managed with regular expressions
or with something even more sophisticated than them: a state machine or
even a full featured parser.</p>
<p>I will <em>not</em> give a primer on regular expression here, since they are
already well documented in the standard documentation (see Andrew's
Kuchling 'Howto') as well in many books (for instance 'Mastering Regular
Expression' first edition and 'Python in a Nutshell'). 
Instead, I will give various practical examples of usage.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import re
&gt;&gt;&gt; reobj=re.compile(r'x')
</pre>
</blockquote>
</div>
<div class="section" id="more-on-metaclasses-and-subclassing-built-in-types">
<h2><a class="toc-backref" href="#id131" name="more-on-metaclasses-and-subclassing-built-in-types">More on metaclasses and subclassing built-in types</a></h2>
<p>Subclassing <tt class="literal"><span class="pre">list</span></tt> is easy since there are no methods returning lists
except the methods correspondings to the '+' and '*' operators. 
Subclassing <tt class="literal"><span class="pre">str</span></tt> is more complicated, since one has many methods
that return strings. Nevertheless, it can be done with the <tt class="literal"><span class="pre">AutoWrapped</span></tt>
metaclass, simply by specifying the list of the builtins to be wrapped.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Str(str):
    __metaclass__=AutoWrapped
    builtinlist=&quot;&quot;&quot;__add__ __mod__ __mul__ __rmod__ __rmul__ capitalize
        center expandtabs join ljust lower lstrip replace rjust rstrip strip
        swapcase title translate upper zfill&quot;&quot;&quot;.split()

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here I show various tests.</p>
<blockquote>
<!-- doctest -->
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Str
&gt;&gt;&gt; sum=Str('a')+Str('b') # check the sum
&gt;&gt;&gt; print sum, type(sum)
ab &lt;class 'oopp.Str'&gt;
&gt;&gt;&gt; rprod=Str('a')*2 # check the right product 
&gt;&gt;&gt; print rprod,type(rprod)
aa &lt;class 'oopp.Str'&gt;
&gt;&gt;&gt; lprod=2*Str('a') # check the left product 
&gt;&gt;&gt; print lprod,type(lprod)
aa &lt;class 'oopp.Str'&gt;
&gt;&gt;&gt; r=Str('a').replace('a','b') # check replace
&gt;&gt;&gt; print r,type(r)
b &lt;class 'oopp.Str'&gt;
&gt;&gt;&gt; r=Str('a').capitalize() # check capitalize
&gt;&gt;&gt; print r,type(r)
A &lt;class 'oopp.Str'&gt;
</pre>
</blockquote>
<p><tt class="literal"><span class="pre">Str</span></tt> acts as a nice base class to built abstractions based on strings.
In particular, regular expressions can be built on top of strings describing
their representation (I remind that if <tt class="literal"><span class="pre">x</span></tt> is a regular expression object, 
<tt class="literal"><span class="pre">x.pattern</span></tt> is its string representation). Then, the sum of two regular 
expressions <tt class="literal"><span class="pre">x</span></tt> and <tt class="literal"><span class="pre">y</span></tt> can be defined as the sum of their string 
representation, <tt class="literal"><span class="pre">(x+y).pattern=x.pattern+y.pattern</span></tt>. Moreover, it is
convenient to define the <tt class="literal"><span class="pre">__or__</span></tt> method of two regular expression in
such a way that <tt class="literal"><span class="pre">(x</span> <span class="pre">|</span> <span class="pre">y).pattern=x.pattern+'|'+y.pattern</span></tt>.
All this can be achieved trough the following class:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class BaseRegexp(Str):

    builtinlist=['__radd__', '__ror__']
    wraplist=['__add__','__or__']

    __add__ = lambda self,other: self.pattern + other 
    __or__  = lambda self,other: self.pattern+'|'+other

    def __init__ (self,regexp):
        &quot;Adds to str methods the regexp methods&quot;
        reobj=re.compile(regexp)
        for attr in dir(reobj)+['pattern']:
            setattr(self,attr,getattr(reobj,attr))

#&lt;/oopp.py&gt;

&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; aob=BaseRegexp('a')|BaseRegexp('b'); print aob
a|b
&gt;&gt;&gt; print pretty(attributes(aob))
encode = &lt;built-in method encode of BaseRegexp object at 0x401b25cc&gt;
endswith = &lt;built-in method endswith of BaseRegexp object at 0x401b25cc&gt;
expandtabs = &lt;function _ at 0x401b69cc&gt;
find = &lt;built-in method find of BaseRegexp object at 0x401b25cc&gt;
findall = &lt;built-in method findall of _sre.SRE_Pattern object at 0x4019b890&gt;
finditer = &lt;built-in method finditer of _sre.SRE_Pattern object at 
0x4019b890&gt;
index = &lt;built-in method index of BaseRegexp object at 0x401b25cc&gt;
isalnum = &lt;built-in method isalnum of BaseRegexp object at 0x401b25cc&gt;
isalpha = &lt;built-in method isalpha of BaseRegexp object at 0x401b25cc&gt;
isdigit = &lt;built-in method isdigit of BaseRegexp object at 0x401b25cc&gt;
islower = &lt;built-in method islower of BaseRegexp object at 0x401b25cc&gt;
isspace = &lt;built-in method isspace of BaseRegexp object at 0x401b25cc&gt;
istitle = &lt;built-in method istitle of BaseRegexp object at 0x401b25cc&gt;
isupper = &lt;built-in method isupper of BaseRegexp object at 0x401b25cc&gt;
join = &lt;function _ at 0x401b6a74&gt;
ljust = &lt;function _ at 0x401b6b1c&gt;
lower = &lt;function _ at 0x401b6cdc&gt;
lstrip = &lt;function _ at 0x401b6d84&gt;
match = &lt;built-in method match of _sre.SRE_Pattern object at 0x4019b890&gt;
pattern = ba
replace = &lt;function _ at 0x401b6ed4&gt;
rfind = &lt;built-in method rfind of BaseRegexp object at 0x401b25cc&gt;
rindex = &lt;built-in method rindex of BaseRegexp object at 0x401b25cc&gt;
rjust = &lt;function _ at 0x401ba0d4&gt;
rstrip = &lt;function _ at 0x401ba10c&gt;
scanner = &lt;built-in method scanner of _sre.SRE_Pattern object at 0x4019b890&gt;
search = &lt;built-in method search of _sre.SRE_Pattern object at 0x4019b890&gt;
split = &lt;built-in method split of _sre.SRE_Pattern object at 0x4019b890&gt;
splitlines = &lt;built-in method splitlines of BaseRegexp object at 0x401b25cc&gt;
startswith = &lt;built-in method startswith of BaseRegexp object at 0x401b25cc&gt;
strip = &lt;function _ at 0x401ba25c&gt;
sub = &lt;built-in method sub of _sre.SRE_Pattern object at 0x4019b890&gt;
subn = &lt;built-in method subn of _sre.SRE_Pattern object at 0x4019b890&gt;
swapcase = &lt;function _ at 0x401ba294&gt;
title = &lt;function _ at 0x401ba4fc&gt;
translate = &lt;function _ at 0x401ba534&gt;
upper = &lt;function _ at 0x401ba5dc&gt;
wraplist = ['__add__', '__radd__', '__or__', '__ror__']
zfill = &lt;function _ at 0x401ba614&gt;

#&lt;oopp.py&gt;

class Regexp(BaseRegexp):
    class __metaclass__(BaseRegexp.__metaclass__):
        def __setattr__(cls,name,value):
            if name==name.upper(): # all caps means regexp constant
                if not isinstance(value,cls): value=cls(value)
                value.name=name # set regexp name
            BaseRegexp.__metaclass__.__setattr__(cls,name,value)
            # basic setattr

    def named(self,name=None):
        name=getattr(self,'name',name)
        if name is None: raise 'Unnamed regular expression'
        return self.__class__('(?P&lt;%s&gt;%s)' % (name,self.pattern))

    generateblocks=generateblocks

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>The magic of <tt class="literal"><span class="pre">Regexp.__metaclass__</span></tt> allows to generate a library of 
regular expressions in an elegant way:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

r=Regexp

customize(r,
    DOTALL =r'(?s)' ,      # starts the DOTALL mode; must be at the beginning
    NAME   =r'\b[a-zA-Z_]\w*', # plain Python name
    EXTNAME=r'\b[a-zA-Z_][\w\.]*', # Python name with or without dots
    DOTNAME=r'\b[a-zA-Z_]\w*\.[\w\.]*',# Python name with (at least one) dots
    COMMENT=r&quot;#.*?(?=\n)&quot;, # Python comment
    QUOTED1=&quot;'.+?'&quot;,       # single quoted string '
    QUOTED2='&quot;.+?&quot;',       # single quoted string &quot;
    TRIPLEQ1=&quot;'''.+?'''&quot;,  # triple quoted string '
    TRIPLEQ2='&quot;&quot;&quot;.+?&quot;&quot;&quot;'   # triple quoted string &quot; 
  )

r.STRING=r.TRIPLEQ1|r.TRIPLEQ2|r.QUOTED1|r.QUOTED2
r.CODESEP=r.DOTALL+r.COMMENT.named()|r.STRING.named()

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>The trick is in the redefinition of <tt class="literal"><span class="pre">__setattr__</span></tt>, which magically converts
all caps attributes in <tt class="literal"><span class="pre">Regexp</span></tt> objects.</p>
<p>The features of <tt class="literal"><span class="pre">Regexp</span></tt> can be tested with the following code:</p>
<blockquote>
<pre class="literal-block">
#&lt;test_re.py&gt;

&quot;&quot;&quot;This script looks at its own source code and extracts dotted names,
i.e. names containing at least one dot, such as object.attribute or
more general one, such as obj.attr.subattr.&quot;&quot;&quot;

# Notice that dotted.names in comments and literal strings are ignored

from oopp import *
import __main__

text=inspect.getsource(__main__)

regexp=Regexp.CODESEP| Regexp.DOTNAME.named()

print 'Using the regular expression',regexp

print &quot;I have found the following dotted names:\n%s&quot; % [
    MO.group() for MO in regexp.finditer(text) if MO.lastgroup=='DOTNAME']

#&lt;/test_re.py&gt;
</pre>
</blockquote>
<p>with output:</p>
<blockquote>
<pre class="literal-block">
Using the regular expression (?s)(?P&lt;COMMENT&gt;#.*?(?=\n))|(?P&lt;STRING&gt;
'''.+?'''|&quot;&quot;&quot;.+?&quot;&quot;&quot;|'.+?'|&quot;.+?&quot;)|(?P&lt;DOTNAME&gt;[a-zA-Z_]\w*\.[\w\.]*)
I have found the following dotted names:
['inspect.getsource', 'Regexp.CODESEP', 'Regexp.DOTNAME.named', 'MO.group', 
 'dotname.finditer', 'MO.lastgroup']
</pre>
</blockquote>
<p>Now one can define a good <tt class="literal"><span class="pre">CodeStr</span></tt> class with replacing features</p>
<p>Let me consider for instance the solution to the problem discussed in chapter
4, i.e. the definition of a <tt class="literal"><span class="pre">TextStr</span></tt> class able to indent and dedent
blocks of text.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def codeprocess(code,TPO): # TPO=text processing operator
    code=code.replace(&quot;\\'&quot;,&quot;\x01&quot;).replace('\\&quot;','\x02')
    genblock,out = Regexp.CODESEP.generateblocks(code),[]
    for block in genblock:
        out.append(TPO(block))
        out.append(genblock.next())
    return ''.join(out).replace(&quot;\x01&quot;,&quot;\\'&quot;).replace('\x02','\\&quot;')

def quotencode(text):
    return text.replace(&quot;\\'&quot;,&quot;\x01&quot;).replace('\\&quot;','\x02')

def quotdecode(text):
    return text.replace(&quot;\x01&quot;,&quot;\\'&quot;).replace('\x02','\\&quot;')

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here is an example of usage: replacing 'Print' with 'print' except in
comments and literal strings.</p>
<blockquote>
<pre class="literal-block">
#&lt;codeproc.py&gt;

from oopp import codeprocess

wrongcode=r'''
&quot;&quot;&quot;Code processing example: replaces 'Print' with 'print' except in
comments and literal strings&quot;&quot;&quot;
Print &quot;This program prints \&quot;Hello World!\&quot;&quot; # look at this line!
'''

fixPrint=lambda s: s.replace('Print','print')
validcode=codeprocess(wrongcode,fixPrint)

print 'Source code:\n',validcode
print 'Output:\n'; exec validcode

#&lt;/codeproc.py&gt;
</pre>
</blockquote>
<p>with output</p>
<blockquote>
<pre class="literal-block">
Source code:

&quot;&quot;&quot;Code processing example: replaces 'Print' with 'print' except in
comments and literal strings&quot;&quot;&quot;
print &quot;Prints \&quot;Hello World!\&quot;&quot; # look at this line!

Output:

This program prints &quot;Hello World!&quot;
</pre>
</blockquote>
</div>
<div class="section" id="a-simple-state-machine">
<h2><a class="toc-backref" href="#id132" name="a-simple-state-machine">A simple state machine</a></h2>
<p>Regular expression, however powerful, are limited in scope since they
cannot recognize recursive structures. For instance, they cannot parse
parenthesized expression.</p>
<p>The simplest way to parse a parenthesized expression is to use a state
machine.</p>
<blockquote>
<pre class="literal-block">
(?:...) non-grouping
(?P&lt;name&gt;...) 

(?=...) look-ahead 
(?!...) negative
(?&lt;=...) look-behind 
(?&lt;!...) negative

dec=\
&quot;&quot;&quot;
paren   = ( .. )
bracket = [ .. ]
brace   = { .. }
comment = # .. \n
&quot;&quot;&quot;

actions=\
&quot;&quot;&quot;
reobj1  : R' .. (?&lt;!\\)' -&gt; Regexp(r''' .. ''')
reobj2  : R&quot; .. (?&lt;!\\)&quot; -&gt; Regexp(r&quot;&quot;&quot; .. &quot;&quot;&quot;)
string1 : (?&lt;!')'(?!') .. (?&lt;!\\)'(?!') -&gt; ''' .. '''
string2 : (?&lt;!&quot;)&quot;(?!&quot;) .. (?&lt;!\\)&quot;(?!&quot;) -&gt; &quot;&quot;&quot; .. &quot;&quot;&quot;
&quot;&quot;&quot;

beg=0; end=1

string1[beg]=r&quot;(?&lt;!')'(?!')&quot; # an isolated single quote
string2[beg]=r'(?&lt;!&quot;)&quot;(?!&quot;)' # an isolated double quote
string1[end]=r&quot;(?&lt;!\\)'(?!')&quot; # ending single quote
string2[end]=r'(?&lt;!\\)&quot;(?!&quot;)' # ending double quote

reobj1[beg]=r&quot;R'&quot;       
reobj2[beg]=r'R&quot;' 
reobj1[end]=string1[end] # ending single quote
reobj2[end]=string2[end] # ending double quote

actions=\
&quot;&quot;&quot;
reobj1  : R' .. (?&lt;!\\)' -&gt; Regexp(r''' .. ''')
reobj2  : R&quot; .. (?&lt;!\\)&quot; -&gt; Regexp(r&quot;&quot;&quot; .. &quot;&quot;&quot;)
string1 : (?&lt;!')'(?!') .. (?&lt;!\\)'(?!') -&gt; ''' .. '''
string2 : (?&lt;!&quot;)&quot;(?!&quot;) .. (?&lt;!\\)&quot;(?!&quot;) -&gt; &quot;&quot;&quot; .. &quot;&quot;&quot;
&quot;&quot;&quot;

beg={}; end={}; ls=[]
for line in decl.splitlines():
   mode,rest=line.split(' : ')
   s,r=rest.split(' -&gt; ')

 beg[mode],end[mode]=s.split(' .. ')
 ls.append('(?P&lt;beg_%s&gt;%s)' % (mode,beg[mode]))
 ls.append('(?P&lt;end_%s&gt;%s)' % (mode,end[mode]))

 beg2[mode],end2[mode]=r.split(' .. ')
 ls.append(beg2[mode])
 ls.append(end2[mode])

delimiters='(%s)' % re.compile('|'.join(ls))
splitlist=['']+delimiters.split(source)
for delim,text in splitlist:
    delimiters.match(delim).lastgroup
</pre>
</blockquote>
</div>
<div class="section" id="creating-classes">
<h2><a class="toc-backref" href="#id133" name="creating-classes">Creating classes</a></h2>
<p>TODO</p>
</div>
<div class="section" id="modifying-modules">
<h2><a class="toc-backref" href="#id134" name="modifying-modules">Modifying modules</a></h2>
<p>Metaclasses are extremely
useful since they allows to change the behaviour of the code without
changing the sources. For instance, suppose you have a large library written 
by others that you want to enhance in some way.</p>
<p>Typically, it is always a bad idea to modify the sources, for many reasons:</p>
<ul class="simple">
<li>touching code written by others, you may introduce new bugs;</li>
<li>you may have many scripts that requires the original version 
of the library, not the modified one;</li>
<li>if you change the sources and then you buy the new version of the
library, you have to change the sources again!</li>
</ul>
<p>The solution is to enhance the proprierties of the library at run
time, when the module is imported, by using metaclasses.</p>
<p>To show a concrete example, let me consider the case of the module
<em>commands</em> in the Standard Library. This module is Unix-specific,
and cannot be used under Windows. It would be nice to have a
metaclass able to enhance the module in such a way that
when it is invoked on a Windows platform, Windows specific replacement
of the Unix functions provided in the module are used. However,
for sake of brevity, I will only give a metaclasses that display
a nice message in the case we are in a Window platform, without
raising an error (one could easily implement such a behaviour,
however).</p>
<blockquote>
<pre class="literal-block">
#&lt;recognizewindows.py&gt;

import oopp,sys,commands

class WindowsAware(type):
    def __init__(cls,*args): 
        if sys.platform=='win32': 
            for key,val in vars(cls).iteritems():
                if isinstance(val,staticmethod):
                    setattr(cls,key,staticmethod(lambda *args: 
                         &quot;Sorry, you are (or I pretend you are) on Windows,&quot;
                         &quot; you cannot use the %s.module&quot; % cls.__name__))
          
sys.platform=&quot;win32&quot; #just in case you are not on Windows

commands=oopp.ClsFactory[WindowsAware](commands)

print commands.getoutput('date') #cannot be executed on Windows

#&lt;/recognizewindows.py&gt;
</pre>
</blockquote>
<p>The output of this script is</p>
<blockquote>
<pre class="literal-block">
Sorry, you are on Windows, you cannot use the commands.module
</pre>
</blockquote>
<p>However, if you are on Linux and you comment out the line</p>
<blockquote>
<pre class="literal-block">
sys.platform=&quot;win32&quot; 
</pre>
</blockquote>
<p>you will see that the script works.</p>
<p>Notice that the line <tt class="literal"><span class="pre">commands=WindowsAware(commands)</span></tt> actually
converts the 'commands' module in a 'commands' class, but since
the usage is the same, this will fool all programs using the
commands module. In this case the class factory 'WindowsAware'
can also be thought as a module modifier. In this sense, it is
very useful to denote the metaclass with an <em>adjective</em>.</p>
</div>
<div class="section" id="metaclasses-and-attribute-descriptors">
<h2><a class="toc-backref" href="#id135" name="metaclasses-and-attribute-descriptors">Metaclasses and attribute descriptors</a></h2>
<p>Descriptors are especially useful in conjunction with metaclasses, since
a custom metaclass can use them as low level tools to modify the methods 
and the attributes of its instances. This allows to implement very 
sophisticated features with few lines of code.</p>
<p>Notice, anyway, that
even plain old function can be thought of as of descriptors.</p>
<p>Descriptors share at least two features with metaclasses:</p>
<ol class="arabic simple">
<li>as metaclasses, descriptors are best used as adjectives, since they
are intended to modify and enhance standard methods and attributes, in the
same sense metaclasses modify and enhance standard classes;</li>
<li>as metaclasses, descriptors can change the <em>semantics</em> of Python, i.e.
what you see is not necessarely what you get. As such, they are a 
dangerous feature. Use them with judgement!</li>
</ol>
<p>Now I will show a possible application of properties.
Suppose one has a given class with various kind of
attributes (plain methods, regular methods, static methods,
class methods, properties and data attributes) and she wants
to trace to access to the data attributes (notice that the motivation
for the following problem come from a real question asked in
comp.lang.python). Then one needs to retrieve data
attributes from the class and convert them in properties
controlling their access syntax. The first problem is solved
by a simple function</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def isplaindata(a):
    &quot;&quot;&quot;A data attribute has no __get__ or __set__ attributes, is not
    a built-in function, nor a built-in method.&quot;&quot;&quot; 
    return not(hasattr(a,'__get__') or hasattr(a,'__set__')
               or isinstance(a,BuiltinMethodType) or
               isinstance(a,BuiltinFunctionType))

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>whereas the second problem is elegantly solved by a custom metaclass:</p>
<blockquote>
<pre class="literal-block">
#&lt;tracedaccess.py&gt;

from oopp import isplaindata,inspect

class TracedAccess(type):
    &quot;Metaclass converting data attributes to properties&quot;
    def __init__(cls,name,bases,dic):
        cls.datadic={}
        for a in dic:
            if isplaindata(a):
                cls.datadic[a]=dic[a]
                def get(self,a=a):
                    v=cls.datadic[a]
                    print &quot;Accessing %s, value=%s&quot; % (a,v)
                    return v
                def set(self,v,a=a):
                    print &quot;Setting %s, value=%s&quot; % (a,v)
                    cls.datadic[a]=v
                setattr(cls,a,property(get,set))

class C(object):
    __metaclass__ = TracedAccess
    a1='x'

class D(C): # shows that the approach works well with inheritance
    a2='y'

i=D()
i.a1 # =&gt; Accessing a1, value=x
i.a2 # =&gt; Accessing a2, value=y
i.a1='z' # =&gt; Setting a1, value=z
i.a1 # =&gt; Accessing a1, value=z

#&lt;/tracedaccess.py&gt;
</pre>
</blockquote>
<p>In this example the metaclass looks at the plain data attributes (recognized
thanks ot the <tt class="literal"><span class="pre">isplaindata</span></tt> function) of its instances and put them
in the dictionary <tt class="literal"><span class="pre">cls.datadic</span></tt>. Then the original attributes are replaced
with property objects tracing the access to them. The solution is a 4-line 
custom metaclass doing the boring job for me:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class Wrapped(Customizable,type):
    &quot;&quot;&quot;A customizable metaclass to wrap methods with a given wrapper and
    a given condition&quot;&quot;&quot;
    __metaclass__=Reflective
    wrapper=wrappedmethod
    condition=lambda k,v: True # wrap all
    def __init__(cls,*args):
        super(cls.__this,cls).__init__(*args)
        wrap(cls,cls.wrapper,cls.condition.im_func)

Traced=Wrapped.With(wrapper=tracedmethod,__name__='Traced')
Timed=Wrapped.With(wrapper=timedmethod,__name__='Timed')

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; time_=ClsFactory[Traced](time)
&gt;&gt;&gt; print time_.asctime()
[time_] Calling 'asctime' with arguments
(){} ...
-&gt; 'time_.asctime' called with result: Sun May  4 07:30:51 2003
Sun May  4 07:30:51 2003
</pre>
</blockquote>
<p>Another is</p>
<blockquote>
<pre class="literal-block">
#&lt;tracemain.py&gt;

from oopp import ClsFactory,Traced,Reflective

def f1(x): return x     # nested functions 
def f2(x): return f1(x) # we want to trace

f1orf2=lambda k,v : v is f1 or v is f2
make=ClsFactory[Reflective,Traced.With(condition=f1orf2)]
traced=make('traced',globals())

traced.f2('hello!') # call traced.f2

#&lt;/tracemain.py&gt;
</pre>
</blockquote>
<p>with output</p>
<blockquote>
<pre class="literal-block">
[__main__] Calling 'f2' with arguments
('hello!',){} ...
[__main__] Calling 'f1' with arguments
('hello!',){} ...
-&gt; '__main__.f1' called with result: hello!
-&gt; '__main__.f2' called with result: hello!
</pre>
</blockquote>
</div>
<div class="section" id="id46">
<h2><a class="toc-backref" href="#id136" name="id46">Modifying hierarchies</a></h2>
<p>Suppose one wants to enhance a pre-existing class, for instance
by adding tracing capabilities to it. The problem is non-trivial
since it is not enough to derive a new class from the original
class using the 'Traced' metaclass. For instance, we could imagine of 
tracing the 'Pizza' class introduced in chapter 4 by defining</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import *
&gt;&gt;&gt; class TracedTomatoPizza(GenericPizza,WithLogger):
...     __metaclass__=ClsFactory[Traced] 
...     toppinglist=['tomato']
</pre>
</blockquote>
<p>However, this would only trace the methods of the newly defined class,
not of the original one. Since the new class does not introduce any 
non-trivial method, the addition of 'Traced' is practically without
any effect:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; marinara=TracedTomatoPizza('small') # nothing happens
*****************************************************************************
Tue Apr 15 11:00:17 2003
1. Created small pizza with tomato, cost $ 1.5
</pre>
</blockquote>
</div>
<div class="section" id="tracing-hierarchies">
<h2><a class="toc-backref" href="#id137" name="tracing-hierarchies">Tracing hierarchies</a></h2>
<blockquote>
<pre class="literal-block">
#&lt;traceH.py&gt;

from oopp import *

def wrapMRO(cls,wrapped):
    for c in cls.__mro__[:-1]:
        wrap(c,wrapped)

tracing=tracedmethod.With(logfile=file('trace.txt','w'))
wrapMRO(HomoSapiensSapiens,tracing)
HomoSapiensSapiens().can()

#&lt;/traceH.py&gt;
</pre>
</blockquote>
<p>with output in trace.txt</p>
<blockquote>
<pre class="literal-block">
[HomoSapiensSapiens] Calling 'can' with arguments
 (&lt;oopp.HomoSapiensSapiens object at 0x4020364c&gt;,){} ...
    [HomoSapiens] Calling 'can' with arguments
     (&lt;oopp.HomoSapiensSapiens object at 0x4020364c&gt;,){} ...
        [HomoHabilis] Calling 'can' with arguments
         (&lt;oopp.HomoSapiensSapiens object at 0x4020364c&gt;,){} ...
            [Homo] Calling 'can' with arguments
             (&lt;oopp.HomoSapiensSapiens object at 0x4020364c&gt;,){} ...
                [PrettyPrinted] Calling '__str__' with arguments
                 (&lt;oopp.HomoSapiensSapiens object at 0x4020364c&gt;,){} ...
                [PrettyPrinted.__str__] called with result: 
                 &lt;HomoSapiensSapiens&gt;
            [Homo.can] called with result: None
        [HomoHabilis.can] called with result: None
    [HomoSapiens.can] called with result: None
[HomoSapiensSapiens.can] called with result: None
</pre>
</blockquote>
</div>
<div class="section" id="modifying-source-code">
<h2><a class="toc-backref" href="#id138" name="modifying-source-code">Modifying source code</a></h2>
<p>The real solution would be to derive the original class 'GenericPizza'
from 'Traced' and not from 'object'. One could imagine of creating
a new class inhering from 'Traced' and with all the methods of the
original 'GenericPizza' class; then one should create copies of
all the classes in the whole multiple inheritance hierarchy.
This would be a little annoying, but feasable; the real problem is
that this approach would not work with cooperative methods, since 
cooperative calls in the derived classes would invoked methods in 
the original classes, which are not traced.</p>
<p>This is a case where the modification of the original source code is 
much more appealing and simpler that any other method: it is enough 
to perform a search and replace in the original source code, by adding
the metaclass 'Traced', to enhance the whole multiple inheritance hierarchy.
Let me assume that the hierarchy is contained in a module (which is
typical case). The idea, is to generate <em>dynamically</em> a new module from the
modified source code, with a suitable name to avoid conflicts with the
original module. Incredibily enough, this can be done in few lines:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def modulesub(s,r,module):
    &quot;Requires 2.3&quot;
    name=module.__name__
    source=inspect.getsource(module).replace(s,r)
    dic={name: module}; exec source in dic # exec the modified module
    module2=ModuleType(name+'2') # creates an an empty module 
    customize(module2,**dic) # populates it with dic
    return module2
  
#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Notice that the <tt class="literal"><span class="pre">sub</span></tt> function, that modifies the source code of
a given module and returns a modified module, requires Python 2.3
to work. This is a due to a subtle bug in <tt class="literal"><span class="pre">exec</span></tt> in Python 2.2.
Anyway, the restriction to Python 2.3 allows me to take advantage
of one of the most elegant convenience of Python 2.3: the name in
the <tt class="literal"><span class="pre">types</span></tt> module acts are type factories and in particular
<tt class="literal"><span class="pre">ModuleType(s)</span></tt> returns an (empty) module named <tt class="literal"><span class="pre">s</span></tt>.
Here is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import oopp
&gt;&gt;&gt; s='GenericPizza(object):'
&gt;&gt;&gt; oopp2=oopp.modulesub(s,s+'\n    __metaclass__=oopp.Traced',oopp) 
</pre>
</blockquote>
<p>Name clashes are avoided, being 'oopp2' a different module from 
'oopp'; we have simultaneously access to both the original hierarchy
in 'oopp' (non-traced) and the modified one in 'oopp2' (traced).
In particular 'oopp2.CustomizablePizza' is traced and therefore</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class PizzaLog(oopp2.CustomizablePizza,oopp2.WithLogger):
...     __metaclass__=makecls()
&gt;&gt;&gt; marinara=PizzaLog.With(toppinglist=['tomato'])('small')
</pre>
</blockquote>
<p>gives the output</p>
<blockquote>
<pre class="literal-block">
[PizzaLog] Calling '__init__' with arguments
(&lt;oopp.PizzaLog object at 0x40470dac&gt;, 'small'){} ...
-&gt; 'PizzaLog.__init__' called with result: None

*****************************************************************************
Thu Mar 27 09:18:28 2003
[PizzaLog] Calling '__str__' with arguments
(&lt;oopp.PizzaLog object at 0x40470dac&gt;,){} ...
[PizzaLog] Calling 'price' with arguments
(&lt;oopp.PizzaLog object at 0x40470dac&gt;,){} ...
[PizzaLog] Calling 'toppings_price' with arguments
(&lt;oopp.PizzaLog object at 0x40470dac&gt;,){} ...
-&gt; 'PizzaLog.toppings_price' called with result: 0.5

-&gt; 'PizzaLog.price' called with result: 1.5

-&gt; 'PizzaLog.__str__' called with result: small pizza with tomato, cost $ 1.5

1. Created small pizza with tomato, cost $ 1.5
</pre>
</blockquote>
<p>From that we understand what is happening:</p>
<ul class="simple">
<li><tt class="literal"><span class="pre">PizzaLog.__init__</span></tt> calls <tt class="literal"><span class="pre">GenericPizza.__init__</span></tt> that defines size and
cooperatively calls <tt class="literal"><span class="pre">WithLogger.__init__</span></tt></li>
<li>WithLogger.__init__ cooperatively calls <tt class="literal"><span class="pre">WithCounter.__init__</span></tt> 
that increments the count attribute;</li>
<li>at this point, the instruction 'print self' in <tt class="literal"><span class="pre">WithLogger.__init__</span></tt> calls 
<tt class="literal"><span class="pre">PizzaLog.__str__</span></tt> (inherited from <tt class="literal"><span class="pre">GenericPizza.__str__</span></tt>);</li>
<li><tt class="literal"><span class="pre">GenericPizza.__str__</span></tt> calls 'price' that in turns calls 
'toppings_price'.</li>
</ul>
<p>On top of that, notice that the metaclass of 'PizzaLog' is
<tt class="literal"><span class="pre">_TracedReflective</span></tt> that has been automagically generated by 
<tt class="literal"><span class="pre">makecls</span></tt> from the metaclasses of 'CustomizablePizza' (i.e. 'Traced')
and of 'WithLogger' (i.e. 'Reflective'); the leading underscore helps 
to understand the dynamical origin of '_TracedReflective'.
It turns out that '_TracedReflective' has a dynamically
generated (meta-meta)class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print type(type(PizzaLog)) #meta-metaclass
&lt;class 'oopp._WithWrappingCapabilitiesReflective'&gt;
</pre>
</blockquote>
<p>Therefore this example has a non-trivial class hierarchy</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print oopp.MRO(PizzaLog)
MRO of PizzaLog:
  0 - PizzaLog(CustomizablePizza,WithLogger)[Traced]
  1 - CustomizablePizza(GenericPizza,Customizable)[Traced]
  2 - GenericPizza(object)[Traced]
  3 - WithLogger(WithCounter,Customizable,PrettyPrinted)
  4 - WithCounter(object)
  5 - Customizable(object)
  6 - PrettyPrinted(object)
  7 - object()
</pre>
</blockquote>
<p>a non-trivial metaclass hierarchy,</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print oopp.MRO(type(PizzaLog)) # the metaclass hierarchy
MRO of Traced:
  0 - Traced(Reflective)[WithWrappingCapabilities]
  1 - Reflective(type)
  2 - type(object)
  3 - object()
</pre>
</blockquote>
<p>and a non-trivial meta-metaclass hierarchy:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print oopp.MRO(type(type(PizzaLog))) # the meta-metaclass hierarchy
MRO of WithWrappingCapabilities:
  0 - WithWrappingCapabilities(BracketCallable)
  1 - CallableWithBrackets(type)
  2 - type(object)
  3 - object()
</pre>
</blockquote>
<p>Pretty much complicated, isn't it ? ;)</p>
<p>This example is there to show what kind of maintenance one can have
with programs doing a large use of metaclasses, particularly, when
they should be understood by somebody else than the autor ...</p>
</div>
<div class="section" id="metaclass-regenerated-hierarchies">
<h2><a class="toc-backref" href="#id139" name="metaclass-regenerated-hierarchies">Metaclass regenerated hierarchies</a></h2>
<blockquote>
<pre class="literal-block">
import types
  
def hierarchy(self,cls):
    d=dict([(t.__name__,t) for t in vars(types).itervalues()
            if isinstance(t,type)])
    def new(c):
        bases=tuple([d[b.__name__] for b in c.__bases__])
        return self(c.__name__, bases, c.__dict__.copy())
    mro=list(cls.__mro__[:-1])
    mro.reverse()
    for c in mro:
        if not c.__name__ in d:
            d[c.__name__]=new(c)
    customize(self,**d)

ClsFactory.hierarchy=hierarchy
traced=ClsFactory[Traced,Reflective]
</pre>
</blockquote>
<p>Unfortunately, this approach does not work if the original hierarchy makes
named cooperative super calls.</p>
<p>Therefore the source-code run-time modification has its advantages.</p>
</div>
</div>
<div class="section" id="the-programmable-programming-language">
<h1><a class="toc-backref" href="#id140" name="the-programmable-programming-language">THE PROGRAMMABLE PROGRAMMING LANGUAGE</a></h1>
<blockquote>
<em>I think that lisp is a better applications language than Python.
However, Python is close enough, or at least so much better than the
alternatives, that Python's social and glue language advantages are
often decisive.</em>  -- Andy Freeman on c.l.p.</blockquote>
<p>I go in <em>really</em> DEEP BLACK MAGIC here.</p>
<p>Lisp has been called the <em>programmable programming language</em> <a class="footnote-reference" href="#id43" id="id47" name="id47">[22]</a>
since its macros allow the  programmer to change the <em>syntax</em> of
the language. Python has no macros and the syntax of the language
cannot be changed. Nevertheless, Python metaclasses allows
to change the <em>semantics</em> of the language. In this sense, they
are even more powerful and more dangerous than Lisp macros.
Python metaclass allow the user to customize the language (if not
its syntax). This is cool enough, however it can make your programs
unreadable by others. The techniques explained in this
chapter should be used with care. Nevertheless, I trust the judgement
of the programmer who has been able to reach this chapter, and I don't
mind providing him further rope to shoot in his/her foot ;)</p>
<table class="footnote" frame="void" id="id48" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id48">[24]</a></td><td>Paul Graham, 'OnLisp'
citing</td></tr>
</tbody>
</table>
<div class="section" id="enhancing-the-python-language">
<h2><a class="toc-backref" href="#id141" name="enhancing-the-python-language">Enhancing the Python language</a></h2>
<p>Let me start with some minor usage of metaclasses. In this section I
will show how the user can implement in few lines features that are
built-in in other languages, through a minimal usage of metaclasses.</p>
<p>For instance, suppose one wants to define a class which cannot be 
derived: in Java this can be done with the &quot;final&quot; keyword. 
In Python there is no need to add a new keyword to the language:</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class NonDerivableError(Exception): pass

class Final(type): # better derived from WithCounter,type
    &quot;Instances of Final cannot be derived&quot;
    def __new__(meta,name,bases,dic):
        try:
            meta.already_called is True
        except AttributeError: # not already called
            meta.already_called=True
            return super(Final,meta).__new__(meta,name,bases,dic)
        else: #if already called
            raise NonDerivableError(&quot;I cannot derive from %s&quot; % bases)

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>Here there is an example of usage:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import Final
&gt;&gt;&gt; class C:
...    __metaclass__=Final
...
&gt;&gt;&gt; class D(C): pass #error
...
NonDerivableError: D not created from (&lt;class 'oopp.C'&gt;,)
</pre>
</blockquote>
<p>It is interesting to notice that a similar effect can be reached
with a <tt class="literal"><span class="pre">singletonClass</span></tt> class factory: a 'MetaSingleton' inherits
from <tt class="literal"><span class="pre">Singleton</span></tt> and from 'type' (therefore it is a metaclass):</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

class S(Singleton,type): pass
singletonClass=ClsFactory[S]

#&lt;/oopp.py&gt;
</pre>
</blockquote>
<p>If we write</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from oopp import singletonClass
&gt;&gt;&gt; C=singletonClass()
&gt;&gt;&gt; class D(C):
...    pass
</pre>
</blockquote>
<p>we see that actually 'D' is not a new instance of 'Singleton', but
it coincides with 'C', instead:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; id(C),id(D)
(135622140, 135622140)
&gt;&gt;&gt; C is D
True
&gt;&gt;&gt; type(C)
&lt;class '__main__._Singleton'&gt;
&gt;&gt;&gt; type(C).__bases__
(&lt;class 'oopp.Singleton'&gt;, &lt;type 'type'&gt;)
&gt;&gt;&gt; c=C(); d=D()
&gt;&gt;&gt; id(c),id(d)
(1075378028, 1075378924)
</pre>
</blockquote>
<p>Notice the order: 'SingletonClass' must inherit from 'Singleton' 
first and from <tt class="literal"><span class="pre">Class</span></tt> second, otherwise the <tt class="literal"><span class="pre">Class.__new__</span></tt> method would
override the  <tt class="literal"><span class="pre">Singleton.__new__</span></tt>, therefore losing the 'Singleton'
basic property of having only one instance. On the other hand, in
the correct order, 'Singleton' first and 'Class' second, the inheritance
diagram is</p>
<blockquote>
<pre class="literal-block">
               object   5
             (__new__)
            /          \
           /            \
2      WithCounter          type    4
      (__new__)       (__new__)
          |              |
          |              |
1     Singleton         Class    3
      (__new__)       (__new__)
           \             /
            \           /
            SingletonClass    0
         (Singleton.__new__)
</pre>
<pre class="literal-block">
      object
     /     \
    /       |
WithCounter     | 
    |       |
Singleton  type
     \     /
      \   /
   MetaSingleton
        :
        :       
        :   instantiation
        :
        :
      C = D
</pre>
</blockquote>
<p>whereas 'SingletonClass' inherits <tt class="literal"><span class="pre">Singleton.__new__</span></tt> which, trough
the <tt class="literal"><span class="pre">super</span></tt> mechanism, calls 'type.__new__' and therefore creates
the class 'C'. Notice that class 'D' is never created, it is simply
an alias for 'C'.</p>
<p>I think it is simpler to write down the class 'Final' explicitely
(explicit is better than implicit) as I did; however a fanatic of code
reuse could derive it from 'SingletonClass':</p>
<blockquote>
<pre class="literal-block">
#&lt;final.py&gt;

from oopp import *

class Final(Singleton,type):
    &quot;Inherits the 'instance' attribute from Singleton (default None)&quot;
    def __new__(meta,name,bases,dic):
        if meta.counter==0: # first call
            return super(Final,meta).__new__(meta,name,bases,dic)
        else:
            raise NonDerivableError(&quot;I cannot derive from %s&quot; % bases)
  
class C:  __metaclass__=Final

try:
    class D(C): pass
except NonDerivableError,e:
    print e

#&lt;/final.py&gt;
</pre>
</blockquote>
<p>The reader can check that this script has the correct output 
&quot;I cannot derive from &lt;class 'oopp.C'&gt;&quot;. I leave to the reader
to understand the issues with trying to implement 'NonDerivable'
from 'NonInstantiable'. #And why an inner metaclass would not work.</p>
</div>
<div class="section" id="restricting-python-dynamism">
<h2><a class="toc-backref" href="#id142" name="restricting-python-dynamism">Restricting Python dynamism</a></h2>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

def frozen(self,name,value):
    if hasattr(self,name):
        type(self).__bases__[0].__setattr__(self,name,value) 
    else:
        raise AttributeError(&quot;You cannot add attributes to %s&quot; % self)

class Frozen(object):
    &quot;&quot;&quot;Subclasses of Frozen are frozen, i.e. it is impossibile to add
     new attributes to them and their instances&quot;&quot;&quot;
    __setattr__ = frozen
    class __metaclass__(type):
        __setattr__ = frozen

#&lt;/oopp.py&gt;


#&lt;frozen.py&gt;

from oopp import *

class C(Frozen):
    c=1
    def __init__(self): 
        #self.x=5 # won't work anymore, __new__ will be okay
        pass

class D(C):
    d=2
  
C.c=2

print D().d

#&lt;/frozen.py&gt;
</pre>
</blockquote>
</div>
<div class="section" id="changing-the-language-without-changing-the-language">
<h2><a class="toc-backref" href="#id143" name="changing-the-language-without-changing-the-language">Changing the language without changing the language</a></h2>
<p>In Lisp the user has the possibility of changing the syntax of the 
language to suit her purposes (or simply to fit her taste). 
In Python, the user cannot change the basic grammar of the language,
nevertheless, to a great extent, metaclasses allows to emulate this effect. 
Notice that using metaclasses to this aim is not necessarely 
a good idea, since once you start
changing the Python standard behaviour, it will become impossible for
others  to understand your programs (which is what happened to Lisp ;).</p>
<p>Let me show how metaclasses can be used to provide notational convenience 
(i.e. syntactic sugar) for Python.</p>
<p>As first example, I will show how we may use metaclasses to provide some
convenient notation for staticmethods and classmethods:</p>
<blockquote>
<pre class="literal-block">
class MetaSugar(type):
    def __init__(cls,name,bases,clsdict):
        for key,value in clsdict.iteritems():
            if key.startswith(&quot;static_&quot;):
                setattr(cls,key[7:],staticmethod(value))
            elif key.startwith(&quot;class_&quot;):
                setattr(cls,key[6:],classmethod(value))
</pre>
</blockquote>
<p>The same effect can be obtained trough normal inheritance</p>
<blockquote>
<pre class="literal-block">
class SyntacticSugar(object):
    def __init__(self):
        for k,v in self.__class__.__dict__.iteritems():
            if k.startswith('static_'):
                self.__class__.__dict__[k[7:]] = staticmethod(v)
            if k.startswith('static_'):
                self.__class__.__dict__[k[7:]] = staticmethod(v)
</pre>
</blockquote>
<p>Let me now implement some syntactic sugar for the __metaclass__ hook.</p>
<blockquote>
<pre class="literal-block">
#&lt;oopp.py&gt;

import re
squarednames=re.compile('\[([A-Za-z_][\w\., ]*)\]')

def inferredfromdocstring(name,bases,dic):
    docstring=dic['__doc__']
    match=squarednames.match(docstring)
    if not match: return ClsFactory[Reflective](name,bases,dic)
    metanames=[name.strip() for name in match.group(1).split(',')]
    metaname=''.join(metanames)  
    if len(metanames)&gt;1: # creates a new metaclass
        metaclass=type(metaname,tuple(map(eval,metanames)),{})
    else:
        metaclass=eval(metaname)
    return ClsFactory[metaclass](name,bases,dic)

#&lt;/oopp.py&gt;

#&lt;sugar.py&gt;

from oopp import *
__metaclass__ = inferredfromdocstring
class B:
    &quot;Do nothing class&quot;

class C: 
    &quot;[Reflective]&quot;
    &quot; Do nothing class&quot;

class D:
    &quot;[WithLogger,Final]&quot;
    &quot;Do nothing class&quot;

class E(C):
    pass

#&lt;/sugar.py&gt;
</pre>
</blockquote>
<p>With output:</p>
<blockquote>
<pre class="literal-block">
*****************************************************************************
Fri Feb 21 09:35:58 2003
Creating class Logged_C descending from (),
instance of &lt;class 'oopp.Logged'&gt;

Logged_C dictionary:
 __doc__ = Do nothing class
*****************************************************************************
Fri Feb 21 09:35:58 2003
Creating class Logged_Final_D descending from (),
instance of &lt;class 'oopp.LoggedFinal'&gt;

Logged_Final_D dictionary:
__doc__ = Do nothing class
*****************************************************************************
Fri Feb 21 09:35:58 2003
Creating class E descending from (&lt;class 'oopp.Logged_C'&gt;,),
instance of &lt;class 'oopp.Logged'&gt;

E dictionary:
&lt;EMPTY&gt; 
</pre>
</blockquote>
<p>At the end, let me point out few observations:
Metaclasses can be used to provide syntactic sugar, as I have shown
in the previous example. However, I have given the previous
routines as a proof of concept: I do <em>not</em> use these routines in
my actual code for many good reasons:</p>
<ol class="arabic simple">
<li>At the end a convenient notation will be provided in Python 2.4</li>
<li>I don't want to use magic tricks on my code, I want others to
be able to understand what the code is doing;</li>
<li>I want to be able myself to understand my own code in six months
from today ;)</li>
</ol>
<p>Anyway, I think it is a good thing to know about this potentiality
of metaclasses, that can turn out to be very convenient in certain
applications: but this does not mean that should be blindly used
and/or abused. In other words: with great powers come 
great responsabilities ;)</p>
</div>
<div class="section" id="recognizing-magic-comments">
<h2><a class="toc-backref" href="#id144" name="recognizing-magic-comments">Recognizing magic comments</a></h2>
<p>In this section, I will begin to unravel the secrets of the black magic art 
of changing Python semantics and I will show that with few lines 
involving metaclasses
and the standard library 'inspect' module, even comments can be made
significant! (let me continue with my series &quot;how to do what should not
be done&quot;).</p>
<p>To this aim, I need a brief digression on regular expressions.</p>
<blockquote>
<pre class="literal-block">
class RecognizesMagicComments(object):
   form=r'def %s(NAME)(args):#!\s?staticmethod'
   class __metaclass__(type):
       def __new__(meta,name,bases,dic):
           code=[]
           for attr in dic:
               source=inspect.getsource(dic[attr]).splitlines()
               for line in source:
                   split=line.split('#!')
                   if len(split)==2:
                       descriptor=split[1]; code.append(split[0])
                   else: code.append(line)
             
class C(RecognizesMagicComments):
    #!staticmethod
    def f(x): #!staticmethod
        return x
</pre>
</blockquote>
</div>
<div class="section" id="interpreting-python-source-code-on-the-fly">
<h2><a class="toc-backref" href="#id145" name="interpreting-python-source-code-on-the-fly">Interpreting Python source code on the fly</a></h2>
<p>At this point, I can really go <em>DEEP</em> in black magic.</p>
<blockquote>
<pre class="literal-block">
import sys, inspect, linecache, re

def cls_source(name,module):
    lines = linecache.getlines(inspect.getsourcefile(module))
    if not lines: raise IOError, 'could not get source code'
    pat = re.compile(r'^\s*class\s*' + name + r'\b')
    for i in range(len(lines)):
        if pat.match(lines[i]): break
    else: raise IOError, 'could not find class definition'
    lines, lnum = inspect.getblock(lines[i:]), i + 1
    return ''.join(lines)

class Interpreter(object):
    def __init__(self,CPO): # possible composition of code processing opers
        self.repl=CPO
    def __call__(self,name,bases,dic):
        try:
           modulename=dic['__module__'] # module where the class is defined
        except KeyError: # no __module__ attribute
           raise IOError(&quot;Class %s cannot be defined dynamically or in the\n&quot;
           &quot;interpreter and the source code cannot came from a pipe&quot;% name)
        module=sys.modules[modulename] 
        source=self.repl(cls_source(name,module))
        source=re.sub('__metaclass__=.*','__metaclass__=type',source)
        #print source
        loc={}; exec source in vars(module),loc
        return loc[name]

regexp_expand=Interpreter(regexp)
</pre>
</blockquote>
</div>
<div class="section" id="implementing-lazy-evaluation">
<h2><a class="toc-backref" href="#id146" name="implementing-lazy-evaluation">Implementing lazy evaluation</a></h2>
<p>At this point of our knowledge, it becomes trivial to implement lazy 
evaluation and then a ternary operator. (My original, simpler, implementation
is posted on c.l.p.; see the thread 'PEP 312 (and thus 308) implemented 
with a black magic trick')</p>
</div>
<div class="section" id="implementing-a-ternary-operator">
<h2><a class="toc-backref" href="#id147" name="implementing-a-ternary-operator">Implementing a ternary operator</a></h2>
<blockquote>
<pre class="literal-block">
# module ternary.py

&quot;PEP 308 and 312 implemented via a metaclass-powered dirty trick&quot;

import inspect,__main__

# the ternary operator:

def if_(cond,f,g):
    &quot;Short circuiting ternary operator implemented via lambdas&quot;
    if cond: return f()
    else: return g()

# the metaclass black magic:

class DirtyTrick(type):
    &quot;&quot;&quot;Cooperative metaclass that looks at the source code of its instances 
    and replaces the string '~' with 'lambda :' before the class creation&quot;&quot;&quot;
    def __new__(meta,name,bases,dic):
        for attr in dic.values():
            if inspect.isfunction(attr): 
                code=inspect.getsource(attr)
                if code.find('~')==-1: continue # no '~' found, skip
                code=code.replace('~','lambda :')
                code=dedent(code)+'\n'
                exec code in __main__.__dict__,dic # modifies dic
        return super(DirtyTrick,meta).__new__(meta,name,bases,dic)

# a convenient base class:

class RecognizesImplicitLambdas:
    &quot;Children of this class do recognize implicit lambdas&quot;
    __metaclass__=DirtyTrick
</pre>
</blockquote>
<p>Here there is an example of usage:</p>
<blockquote>
<pre class="literal-block">
from ternary import if_, RecognizesImplicitLambdas
from math import sqrt

class C(RecognizesImplicitLambdas):
   def safesqrt(self,x):
        return if_( x&gt;0, ~sqrt(x), ~0) #short-circuiting ternary operator

c=C()
print c.safesqrt(4), c.safesqrt(-4) 
</pre>
</blockquote>
</div>
</div>
</div>
</body>
</html>
