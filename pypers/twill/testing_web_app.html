<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.9: http://docutils.sourceforge.net/" />
<title>Testing Web Applications with Python</title>
<meta name="author" content="Michele Simionato" />
<meta name="date" content="June 2005" />
</head>
<body>
<div class="document" id="testing-web-applications-with-python">
<h1 class="title">Testing Web Applications with Python</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Michele Simionato</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>June 2005</td></tr>
</tbody>
</table>
<div class="section" id="introduction">
<h1><a name="introduction">Introduction</a></h1>
<p>You have just finished your beautiful Web application, with
lots of pages, links, forms and buttons; you have spent weeks
making sure that everything works fine, 
that the special cases are handled correctly, that the user cannot 
crash your system whatever she does.</p>
<p>Now you are happy and you are ready to ship. But at the last minute
the customer ask for a change: you have the time to apply the change,
but not the time - nor the will - to pass trough another testing 
ordalia. So you ship anyway, hoping that your last little fix did not break 
some other part of the application. The result is that the hidden bug 
shows up at the first day of usage.</p>
<p>If you recognized yourself in this situation then this paper 
is for you, keep reading. If not, well, keep reading anyway,
I am sure you will find something interesting, among the following topics:</p>
<ul class="simple">
<li>how to separate unit tests from functional tests;</li>
<li>how to test web applications (written in any language) using 
standard Python libraries;</li>
<li>how to use twill, a nice and easy to learn web testing tool.</li>
</ul>
</div>
<div class="section" id="to-test-or-not-to-test-this-is-the-problem">
<h1><a name="to-test-or-not-to-test-this-is-the-problem">To test or not to test, this is the problem</a></h1>
<p>Let me begin with a brief personal recollection of how I became 
interested in testing methodologies, and of what I have learned in
the last couple of years.</p>
<p>I have been aware of the importance of testing from the beginning, and
I have heard about automatic testing for years. However, having 
heard about automatic testing is not the same as doing automatic testing, 
and not the same as doing automatic testing well.
It takes some time and experience to get into the testing mood, as well
as the ability to challenge some widespread misconceptions.</p>
<p>For instance, when I began studying test driven methodologies, 
I had gathered two wrong ideas:</p>
<ul class="simple">
<li>that testing was all about unit testing;</li>
<li>that the more you test, the better.</li>
</ul>
<p>After some experience I quickly realized myself that unit tests were
not the only tool, nor the best tool to effectively test my application <a class="footnote-reference" href="#id11" id="id1" name="id1">[1]</a>.
But to overcome the second misconception, I needed some help.</p>
<p>The help come from an XP seminar I attended last year, were I
actually asked the question &quot;how do I test the user interface of
a Web application, i.e. that when the user click on a given page she gets 
the expected result?&quot;.</p>
<p>The answer was: &quot;You don't. Why do you want to test that your browser is 
working?&quot;</p>
<div class="section" id="the-case-for-not-testing-everything">
<h2><a name="the-case-for-not-testing-everything">The case for not testing everything</a></h2>
<p>The answer made me rethink many things. Obviously I was well aware
from the beginning that full test coverage is a myth, still I thought
one programmer should try to test as much as he can.</p>
<p>But this is not the right approach. Instead, it is important to
discriminate about the infinite amount of things that could be
tested, and focus on the things that are of your responsability.</p>
<p>If your customer wants functionality X, you must be sure functionality X
is there. But if in order to get functionality X you need to rely on
functionalities X1, X2 ,... XN, you don't need to test for all
of them. You test only the functionality you are payed to
implement. You don't test that the browser is working, it is
not your job.</p>
<p>For instance, in the case of a Web application, 
you can interact with it <em>indirectly</em>, via the HTTP protocol, or <em>directly</em>, 
via the internal API. If you check that when the user clicks
on button B method M is called and the result R is displayed, you are
testing both your application <em>and</em> the correctness of the
HTTP protocol implementation both in the browser and in the server. This is
way too much. You may rely on the HTTP protocol and just test the API, i.e
just test that if method M is called the right result R is returned.</p>
<p>Of course, a similar viewpoint is applicable to GUIs. In the same
vein, you must test that the interface to the DB you wrote is working, but
you don't need to test that the database itself is working, this
is not your responsability.</p>
<p>The basic point is to separate the indirect testing of the user 
interface - via the HTTP protocol - from the testing of the inner API. 
To this aim, it is important to write your 
application in such a way that you can test the logic independently 
from the user interface. Working in this way you also have the additional 
bonus that you can change the user interface later, without having to 
change a single tests for the logic part.</p>
<p>The problem is that typically the customer will give his specifications
in terms of the user interface. He will tell you &quot;There must be a page where 
the user will enter her order, then she will enter her credit card number,
then the system must send a confirmation email, ...&quot;</p>
<p>This kind of specification is a kind of very high level test - a 
functional test - which has to be converted into a low-level test: 
for instance you may have unit testing telling you that the ordered 
item has been registered in the database, that the 
<tt class="docutils literal"><span class="pre">send_confirmation_email</span> <span class="pre">method</span></tt> has been called etc.</p>
<p>The conversion requires some thinking and practice and it an art more
than a science. Actually I think that the art of testing is not in <em>how</em> 
to test, but in <em>what</em> to test. The best advice and best answer to somebody 
asking about &quot;how do I  test a Web application?&quot; is probably &quot;make a priority 
lists of the things you would like to test and test as little as possible&quot;.</p>
<p>For instance, one should never tests the details of the
implementation. If you make this mistake (as I did at the beginning) 
your tests will get in your way at refactoring time, i.e. they will
have exactly the opposite of the intended effect. Generally speaking,
good advices are: don't spend time testing third party software, don't 
waste time testing code which API is likely to change, split
the UI testing from the application logic testing.</p>
<p>Ideally you should be able to determine what is the minimal set 
of tests needed to make your customer happy, and restrict yourself to
those tests.</p>
</div>
<div class="section" id="the-case-for-testing-everything">
<h2><a name="the-case-for-testing-everything">The case for testing everything</a></h2>
<p>The previous advice is nice and reasonable, especially in an ideal world 
where third party software is bug free and everything is configured correctly.
Unfortunately, the real world is a bit different.</p>
<p>For instance you must be aware that your application 
does not work on some buggy browser, or that it cannot work in specific
circumstances with some database. Also, you may have a nice and 
comprehensive test suite which runs flawlessly
on your development machine, but still
that the application may not work correctly when installed on a different 
machine, because the database could be installed improperly, or 
the mail server settings could be incorrect, or the Internet
connection could be down, etc. In the same vein, if you want
to really be sure that if the user - using a specifing browser in a
specific environment - clicks on that button she gets that result, 
you have to emulate exactly that situation.</p>
<p>It looks like we are back to square one, i.e. the need of testing everything.
But we have learned something in the process: whereas <em>in principle</em>
you would like to test everything, <em>in practice</em> you can effectively
prioritize your tests, focusing on some more than on others,and
splitting them in separate categories to be run separately at
different times.</p>
<p>You definitely need to test that the 
application is working as intended when deployed on a different
machine: and from the failures to these installation tests you may also infer
what is wrong and correct the problem. These installation tests
- tests of the environment where your software is running - must
be kept decoupled from the unit tests checking the 
application logic. If you are sure that the logic is right, then you are 
sure also sure that the problems are in the environment, and you can 
focus your debugging skills in the right direction.</p>
<p>In any case, you need to have both high level (functional, integration, 
installation) tests and low level tests (unit tests, doctests). High level 
tests include tests of the user interface. In particular, you need a test to 
make sure that if an user click X he gets Y, so you are sure that the
Internet connection, the web server, the database, the mail
server, your application, the browser, all work nicely
together. But you should not focus on these global kind
of tests. You don't need to write a thousands of these 
high level tests, if you already have many specific low-level 
tests checking that the logic and the various components
of your application are working.</p>
</div>
</div>
<div class="section" id="how-to-test-the-user-interface">
<h1><a name="how-to-test-the-user-interface">How to test the user interface</a></h1>
<p>Having structured your application properly, you will need a smaller
number of user interface tests, but still you will need at
least a few. How do you write these tests then?</p>
<p>There are two possibilities: the hard way and the easy way.</p>
<p>The hard way is just doing everything by hand, by using your
favorite programming language Web libraries to perform GET and POST
requests and to verify the results. The easy way is to leverage on
tools built by others. Of course,internally these tools work just by calling 
the low level libraries, so it is convenient to say a couple of words on the 
hard way, just to understand what is going on, in case the high level tool 
give you some problem. Moreover, there is always the possibility than
you need something more customized, and knowledge of
the low level libraries can be precious.</p>
<p>The interaction between the user and a Web application
passes through the HTTP protocol, so it is perfectly possible
to simulate the action of an user clicking on a browser
just by sending to the server an equivalent HTTP request (let me
ignore the existence of Javascript for the moment).</p>
<p>Any modern programming language has libraries to interact with the 
HTTP protocol, but here I will give my examples in Python, since Python 
is both a common language for Web programming and a readable one. In Python 
the interaction with the Web is managed via the urllib libraries <a class="footnote-reference" href="#id12" id="id2" name="id2">[2]</a>.
You have two of them: urllib, which can be used in absence of authentication,
and urllib2 which can also manage cookie-based authentication. A complete
discussion of these two libraries would take a long
time, but explaining the basics is pretty simple. I will just give
a couple of recipes based on urllib2, the newest and most powerful library.</p>
<p>I will notice here that the support for cookies in Python 2.4
has improved (essentially by including the third party ClientCookie
library) so you may not be aware of the trick I am going to explain, even 
if have used the urllib libraries in the past. So, don't skip the
next two sections ;)</p>
<div class="section" id="recipe-1-how-to-send-get-and-post-requests">
<h2><a name="recipe-1-how-to-send-get-and-post-requests">Recipe 1: how to send GET and POST requests</a></h2>
<p>Suppose you want to access a site which does not require authentication.
Then making a GET request is pretty easy, just type at the intepreter
prompt</p>
<pre class="doctest-block">
&gt;&gt;&gt; from urllib2 import urlopen
&gt;&gt;&gt; page = urlopen(&quot;http://www.example.com&quot;)
</pre>
<p>Now you have a file like-object which contains the HTML code
of the page <a class="reference" href="http://www.example.com">http://www.example.com</a>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; for line in page: print line,
&lt;HTML&gt;
&lt;HEAD&gt;
  &lt;TITLE&gt;Example Web Page&lt;/TITLE&gt;
&lt;/HEAD&gt; 
&lt;body&gt;  
&lt;p&gt;You have reached this web page by typing &amp;quot;example.com&amp;quot;,
&amp;quot;example.net&amp;quot;,
  or &amp;quot;example.org&amp;quot; into your web browser.&lt;/p&gt;
&lt;p&gt;These domain names are reserved for use in documentation and are not available 
  for registration. See &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc2606.txt&quot;&gt;RFC 
  2606&lt;/a&gt;, Section 3.&lt;/p&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</pre>
<p>If you try to access a non-existent page, or if your Internet
connection is down, you will get an <tt class="docutils literal"><span class="pre">urllib2.URLError</span></tt> instead. 
Incidentally, this is why the <tt class="docutils literal"><span class="pre">urllib2.urlopen</span></tt> function is better 
than the older <tt class="docutils literal"><span class="pre">urllib.urlopen</span></tt>, which would just silently retrieve 
a page containing the error message.</p>
<p>You can easily imagine how to use urlopen to check your Web application:
for instance, you could retrieve a page, extract all the links and
check that they refer to existing pages; or you can verify that
the retrieved page contains the right information, for instance
by matching it with a regular expression. In practice, <tt class="docutils literal"><span class="pre">urlopen</span></tt>
(possibly coupled with a third party HTML parsing tool, such as
BeautifulSoup <a class="footnote-reference" href="#id13" id="id3" name="id3">[3]</a>) gives you all the fine granted control you may wish for.</p>
<p>Moreover, <tt class="docutils literal"><span class="pre">urlopen</span></tt> gives you the possibility to make a POST: 
just pass the query
string as second argument to urlopen. As an example, I will make a POST
to <a class="reference" href="http://issola.caltech.edu/~t/qwsgi/qwsgi-demo.cgi/widgets">http://issola.caltech.edu/~t/qwsgi/qwsgi-demo.cgi/widgets</a>, which is a
page containing the example form coming with Quixote, a nice small
Pythonic Web Framework <a class="footnote-reference" href="#id14" id="id4" name="id4">[4]</a>.</p>
<pre class="doctest-block">
&gt;&gt;&gt; page = urlopen(&quot;http://issola.caltech.edu/~t/qwsgi/qwsgi-demo.cgi/widgets&quot;,
...        &quot;name=MICHELE&amp;password=SECRET&amp;time=1118766328.56&quot;)
&gt;&gt;&gt; print page.read()
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Quixote Widget Demo&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;You entered the following values:&lt;/h2&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;name&lt;/th&gt;&lt;td&gt;MICHELE&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;password&lt;/th&gt;&lt;td&gt;SECRET&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;confirmation&lt;/th&gt;&lt;td&gt;False&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;eye colour&lt;/th&gt;&lt;td&gt;&lt;i&gt;nothing&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;pizza size&lt;/th&gt;&lt;td&gt;&lt;i&gt;nothing&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;pizza toppings&lt;/th&gt;&lt;td&gt;&lt;i&gt;nothing&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;It took you 163.0 sec to fill out and submit the form&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Now <tt class="docutils literal"><span class="pre">page</span></tt> will contain the result of your POST. Notice that I had to
pass explicitly a value for <tt class="docutils literal"><span class="pre">time</span></tt>, which is an hidden widget in
the form.</p>
<p>That was easy, isn't it?</p>
<p>If the site requires authentication, things are slightly more complicated,
but not much, at least if you have Python 2.4 installed.</p>
</div>
<div class="section" id="recipe-2-managing-authentication">
<h2><a name="recipe-2-managing-authentication">Recipe 2: managing authentication</a></h2>
<p>In order to manage cookie-based authentication procedures, 
you need to import a few utilities from urllib2:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from urllib2 import build_opener, HTTPCookieProcessor, Request
</pre>
<p>Notice that <tt class="docutils literal"><span class="pre">HTTPCookieProcessor</span></tt> is new in Python 2.4: if you have
an older version of Python you need third party libraries
such as <cite>ClientCookie</cite> <a class="footnote-reference" href="#id15" id="id5" name="id5">[5]</a>.</p>
<p><tt class="docutils literal"><span class="pre">build_opener</span></tt> and <tt class="docutils literal"><span class="pre">HTTPCookieProcessor</span></tt> are used to create an opener 
object that can manage the cookies sent by the Web server:</p>
<pre class="doctest-block">
&gt;&gt;&gt; opener = build_opener(HTTPCookieProcessor)
</pre>
<p>The opener object has an <tt class="docutils literal"><span class="pre">open</span></tt> method that can be used to retrieve
the Web page corresponding to a given request. The request itself is
encapsulated in a <tt class="docutils literal"><span class="pre">Request</span></tt> object, which is built from the
URL address, the query string, and some HTTP headers information.
In order togenerate the query string, it is pretty convenient
to use the <tt class="docutils literal"><span class="pre">urlencode</span></tt> function defined in <tt class="docutils literal"><span class="pre">urllib</span></tt> (<em>not</em> in <tt class="docutils literal"><span class="pre">urllib2</span></tt>):</p>
<pre class="doctest-block">
&gt;&gt;&gt; from urllib import urlencode
</pre>
<p><tt class="docutils literal"><span class="pre">urlencode</span></tt> generates the query string from a dictionary
or a list of pairs, taking care of the quoting and escaping
rules required by the HTTP protocol. For instance</p>
<pre class="doctest-block">
&gt;&gt;&gt; urlencode(dict(user=&quot;MICHELE&quot;, password=&quot;SECRET&quot;))
'password=SECRET&amp;user=MICHELE'
</pre>
<p>Notice that the order is not preserved when you use a dictionary 
(quite obviously), but this is usually
not an issue. Now, let me define a helper function:</p>
<pre class="doctest-block">
&gt;&gt;&gt; def urlopen2(url, data=None, user_agent='urlopen2'): 
...     &quot;&quot;&quot;Can be used to retrieve cookie-enabled Web pages (when 'data' is
...     None) and to post Web forms (when 'data' is a list, tuple or dictionary
...     containing the parameters of the form).
...     &quot;&quot;&quot;
...     if hasattr(data, &quot;__iter__&quot;):
...         data = urllib.urlencode(data)
...     headers = {'User-Agent' : user_agent}
...     return opener.open(urllib2.Request(url, data, headers))
</pre>
<p>With <tt class="docutils literal"><span class="pre">urlopen2</span></tt>, you can POST your form in just one line. 
On the other hand, if the page you are posting to does not contain a form, 
you will get an HTTPError:</p>
<pre class="doctest-block">
&gt;&gt;&gt; urlopen2(&quot;http://www.example.com&quot;, dict(user=&quot;MICHELE&quot;, password=&quot;SECRET&quot;))
Traceback (most recent call last):
  ...  
HTTPError: HTTP Error 405: Method Not Allowed
</pre>
<p>If you just need to perform a GET, simply forget about the second argument
to <tt class="docutils literal"><span class="pre">urlopen2</span></tt>, or use an empty dictionary or tuple. You can even fake a 
browser by passing a convenient user agent string, such as
&quot;Mozilla&quot;, &quot;Internet Explorer&quot;, etc. This is pretty useful if you want
to make sure that your application works with different browsers.</p>
<p>Using these two recipes it is not that difficilt to write your own web 
testing framework. But you may be better off by leveraging the work
of somebody else</p>
</div>
</div>
<div class="section" id="testing-web-applications-the-easy-way-twill">
<h1><a name="testing-web-applications-the-easy-way-twill">Testing web applications the easy way: twill</a></h1>
<p>I am a big fan of mini languages, i.e. small languages
written to perform a specific task (see for instance my O'Reilly article
on the graph-generation language &quot;dot&quot; <a class="footnote-reference" href="#id16" id="id6" name="id6">[6]</a>). I was very happy when I 
discovered that there a nice little language expressely designed to test 
Web applications. Actually there are two implementations of it: Titus Brown's
twill <a class="footnote-reference" href="#id17" id="id7" name="id7">[7]</a> and Cory Dodt's Python Browser Poseur, PBP  <a class="footnote-reference" href="#id18" id="id8" name="id8">[8]</a>.</p>
<p>PBP came first, but twill seems to be developing faster. At the time 
of this writing, twill is still pretty young (I am using 
version 0.7.1), but it already works pretty well in most situations.
Both PBP and twill are based on tools by 
John J. Lee, i.e. mechanize (inspired by Perl), ClientForm and ClientCookie,
that you may find at <a class="reference" href="http://wwwsearch.sourceforge.net">http://wwwsearch.sourceforge.net</a>. twill also use
Paul McGuire's PyParsing <a class="footnote-reference" href="#id19" id="id9" name="id9">[9]</a>. However, you don't need to install these
libraries: twill includes them as zipped libraries (leveraging on the 
new Python 2.3 <tt class="docutils literal"><span class="pre">zipimport</span></tt> module). As a consequence twill installation 
is absolutely obvious and painless (nothing more than the usual
<tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></tt>).</p>
<p>The simplest way to use twill is interactively from the command line.
Let me show a simple session example:</p>
<pre class="literal-block">
$ twill-sh
 -= Welcome to twill! =-

current page:  *empty page*
                 
&gt;&gt; go http://www.example.com
==&gt; at http://www.example.com

&gt;&gt; show
&lt;HTML&gt;
&lt;HEAD&gt;
  &lt;TITLE&gt;Example Web Page&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;body&gt;
&lt;p&gt;You have reached this web page by typing &amp;quot;example.com&amp;quot;,
&amp;quot;example.net&amp;quot;,
  or &amp;quot;example.org&amp;quot; into your web browser.&lt;/p&gt;
&lt;p&gt;These domain names are reserved for use in documentation and are not available
  for registration. See &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc2606.txt&quot;&gt;RFC
  2606&lt;/a&gt;, Section 3.&lt;/p&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</pre>
<p>twill recognizes a few intuitive commands, such as</p>
<blockquote>
<pre class="literal-block">
go, show, find, notfind, echo, code, back, reload, agent, follow
</pre>
</blockquote>
<p>and few others. The example shows how you can access
a particular HTML page and display its content.</p>
<p>The <tt class="docutils literal"><span class="pre">find</span></tt> command matches the page against a regular
expression: thus</p>
<pre class="literal-block">
&gt;&gt; find(&quot;Example Web Page&quot;)
</pre>
<p>is a test asserting that the current page contains what we expect.
Similarly, the <tt class="docutils literal"><span class="pre">notfind</span></tt> command asserts that the current page does
not match the given regular expression.</p>
<p>The other twill commands are pretty obvious: <tt class="docutils literal"><span class="pre">echo</span> <span class="pre">&lt;message&gt;</span></tt> 
prints a message on standard output, <tt class="docutils literal"><span class="pre">code</span> <span class="pre">&lt;http_error_code&gt;</span></tt> checks 
that you are getting the right HTTP error code (200 if everything is 
alright), <tt class="docutils literal"><span class="pre">back</span></tt> allows you to go back to the previously visited page, 
<tt class="docutils literal"><span class="pre">reload</span></tt> reloads the current page, <tt class="docutils literal"><span class="pre">agent</span> <span class="pre">&lt;user-agent&gt;</span></tt> allows you 
to change the current user agent, thus faking different browsers, 
<tt class="docutils literal"><span class="pre">follow</span> <span class="pre">&lt;regex&gt;</span></tt> finds the first matching link on the page and visit it.</p>
<p>The full lists of the commands can be obtained 
by giving <tt class="docutils literal"><span class="pre">help</span></tt> at the prompt; <tt class="docutils literal"><span class="pre">EOF</span></tt> of <tt class="docutils literal"><span class="pre">CTRL-D</span></tt> allows you to exit.</p>
<p>Once you have tested your application interactively, it is pretty easy
to cut &amp; paste your twill session and convert it in a twill script.
Then, you can run your twill script in a batch process:</p>
<pre class="literal-block">
$ twill-sh mytests.twill
</pre>
<p>As you may imagine, you can put more than one script in the command line and
test many of them at the same time. Since twill is written in Python, you
can control it from Python entirely, and you can even extends its command
set just by adding new commands in the <tt class="docutils literal"><span class="pre">commands.py</span></tt> module.</p>
<p>At the moment, twill is pretty young and it does not have the
capability to convert scripts in unit tests automatically, so that
you can easily run entire suites of regression tests. However,
it is not that difficult to implement that capability yourself,
and it is not unlikely that twill will gain good integration with 
unittest and doctest in the future.</p>
<div class="section" id="retrieving-and-submitting-web-forms">
<h2><a name="retrieving-and-submitting-web-forms">Retrieving and submitting web forms</a></h2>
<p>twill is especially good at retrieving and submitting web forms. The
form-related functionality is implemented with the following commands:</p>
<ul class="simple">
<li>showforms</li>
<li>formvalue &lt;form_id&gt; &lt;name&gt; &lt;value&gt;</li>
<li>submit &lt;button_id&gt;</li>
<li>formclear &lt;form_id&gt;</li>
</ul>
<p>Explaining the commands is pretty straightforward.</p>
<p><tt class="docutils literal"><span class="pre">showforms</span></tt> shows the forms contained in a web page. For instance, try
the following:</p>
<pre class="literal-block">
&gt;&gt; go http://issola.caltech.edu/~t/qwsgi/qwsgi-demo.cgi/widgets
&gt;&gt; showforms
Form #1
## __Name______ __Type___ __ID________ __Value__________________
   name         text      (None)
   password     password  (None)
   confirm      checkbox  (None)       [] of ['yes']
   colour       radio     (None)       [] of ['green', 'blue', 'brown', 'ot ...
   size         select    (None)       ['Medium (10&quot;)'] of ['Tiny (4&quot;)', 'S ...
   toppings     select    (None)       ['cheese'] of ['cheese', 'pepperoni' ...
   time         hidden    (None)       1118768019.17
1               submit    (None)       Submit
current page: http://issola.caltech.edu/~t/qwsgi/qwsgi-demo.cgi/widgets
</pre>
<p>Notice that <tt class="docutils literal"><span class="pre">twill</span></tt> makes a good job at emulating a browser, so it fills
the hidden <tt class="docutils literal"><span class="pre">time</span></tt> widget automatically, whereas
we had to fill it explicitely with <tt class="docutils literal"><span class="pre">urlopen</span></tt>.</p>
<p>Unnamed forms get an ordinal number to be used as form id
in the <tt class="docutils literal"><span class="pre">formvalue</span></tt> command, which fill a field
of the specified form with a given value. You can give many
formvalue commands in succession; if you are a lazy typist
you can also use <tt class="docutils literal"><span class="pre">fv</span></tt> as an alias for <tt class="docutils literal"><span class="pre">formvalue</span></tt>:</p>
<pre class="literal-block">
&gt;&gt; fv 1 name MICHELES
current page: http://issola.caltech.edu/~t/qwsgi/qwsgi-demo.cgi/widgets
&gt;&gt; fv 1 password SECRET
current page: http://issola.caltech.edu/~t/qwsgi/qwsgi-demo.cgi/widgets
</pre>
<p><tt class="docutils literal"><span class="pre">formclear</span></tt> reset all the fields in a form and <tt class="docutils literal"><span class="pre">submit</span></tt> allows
you to press a <tt class="docutils literal"><span class="pre">submit</span></tt> botton, thus submitting the form:</p>
<pre class="literal-block">
&gt;&gt; submit 1
current page: http://issola.caltech.edu/~t/qwsgi/qwsgi-demo.cgi/widgets
</pre>
<p>A simple <tt class="docutils literal"><span class="pre">show</span></tt> will convince you that the forms has been submitted.
The best way to understand how does it work is just experimenting
on your own. The base distribution contains a few examples you may
play with.</p>
</div>
</div>
<div class="section" id="enlarging-the-horizon">
<h1><a name="enlarging-the-horizon">Enlarging the horizon</a></h1>
<p>In this article I have shown two easy ways to test your web 
application: by hand, using urllib, or with a simple tool such as twill. 
There is more under the sun. Much more. There are many sophisticated 
Web testing frameworks out there, including enterprise-oriented ones,
with lots of functionalities and a steep learning curve. Here, on purpose,
I have decided to start from the small, and to discuss the topic from a 
do-it-yourself attitude, since sometimes the simplest things works best: or
because you don't need the sophistication, or because your preferred
testing framework lacks the functionality you wish for, or because
it is just buggy. If you need something more sophisticated, a great source for 
everything testing-related is Grig Gheorghiu's blog:</p>
<p><a class="reference" href="http://agiletesting.blogspot.com/2005/02/articles-and-tutorials.html">http://agiletesting.blogspot.com/2005/02/articles-and-tutorials.html</a></p>
<p>A new framework which is especially interesting is Selenium, which
is also used to test Plone applications. Selenium is <em>really</em> spectacular,
since it is Javascript based and it really tests your browser, clicking
on links, submitting forms, opening popup windows, all in real time. It 
completely emulates the user experience, at highest possible level. 
It also gives
you all kind of bells and whistles, eye candies and colored HTML output
(which you may like or not, but that surely will impress your customer
if you are going to demonstrate him that the application is conform to
the specifications).
I cannot render justice to Selenium in a few lines and maybe I should write 
a whole new paper on it, when I find the time. For the moment, however I make
no promises and I refer you to the available documentation <a class="footnote-reference" href="#id20" id="id10" name="id10">[10]</a>.</p>
</div>
<div class="section" id="references">
<h1><a name="references">References</a></h1>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id11">[1]</a></td><td>I am an early adopter and supporter of doctests, see for
instance my talk at the ACCU conference,
<a class="reference" href="http://www.reportlab.org/~andy/accu2005/pyuk2005_simionato_doctest.zip">http://www.reportlab.org/~andy/accu2005/pyuk2005_simionato_doctest.zip</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id12">[2]</a></td><td>For the <tt class="docutils literal"><span class="pre">urllib</span></tt> libraries see the Python docs
<a class="reference" href="http://docs.python.org/lib/module-urllib2.html">http://docs.python.org/lib/module-urllib2.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id13">[3]</a></td><td>For <cite>BeautifulSoup``</cite> see <a class="reference" href="http://www.crummy.com/software/BeautifulSoup">http://www.crummy.com/software/BeautifulSoup</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="id14">[4]</a></td><td>For Quixote see <a class="reference" href="http://www.mems-exchange.org/software/quixote">http://www.mems-exchange.org/software/quixote</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="id15">[5]</a></td><td>For <tt class="docutils literal"><span class="pre">mechanize</span></tt> and <tt class="docutils literal"><span class="pre">ClientCookie</span></tt> see  
<a class="reference" href="http://wwwsearch.sourceforge.net">http://wwwsearch.sourceforge.net</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6" name="id16">[6]</a></td><td><a class="reference" href="http://www.linuxdevcenter.com/pub/a/linux/2004/05/06/graphviz_dot.html">http://www.linuxdevcenter.com/pub/a/linux/2004/05/06/graphviz_dot.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="id17">[7]</a></td><td>For <tt class="docutils literal"><span class="pre">twill</span></tt> see
<a class="reference" href="http://darcs.idyll.org/%7Et/projects/twill/README.html">http://darcs.idyll.org/%7Et/projects/twill/README.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8" name="id18">[8]</a></td><td>For the <tt class="docutils literal"><span class="pre">Python</span> <span class="pre">Browser</span> <span class="pre">Poseur</span></tt> see <a class="reference" href="http://pbp.berlios.de">http://pbp.berlios.de</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9" name="id19">[9]</a></td><td>For <tt class="docutils literal"><span class="pre">PyParsing</span></tt> see <a class="reference" href="http://pyparsing.sourceforge.net">http://pyparsing.sourceforge.net</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10" name="id20">[10]</a></td><td>For <tt class="docutils literal"><span class="pre">Selenium</span></tt> see <a class="reference" href="http://selenium.thoughtworks.com/index.html">http://selenium.thoughtworks.com/index.html</a></td></tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
