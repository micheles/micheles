#|More on phase separation
===================================================================

More examples of macros depending on helper functions
-----------------------------------------------------------------

In the previous episode I have shown an example of a macro
(``assert-distinct``) depending by a helper function (``distinct?``)
appearing in a guarded pattern. This is not the only example of
macros depending on an external function; actually, external
functions appears more commonly in conjunction with the R6RS standard
form ``with-syntax``, which
allows to introduce auxiliary pattern variables
(a better name would have been ``let-pattern-vars``).
Here is a simple example of usage of ``with-syntax`` in conjunction
with the ``range`` function we introduced in episode 5_, to define
a compile-time indexer macro:

$$INDEXER-SYNTAX

Since both ``range`` and ``distinct?`` are defined in the list-utils
module and used at compile-time, everything works if you use
the import form ``(for (aps list-utils) expand)``.

You can understand how the macro works by expanding it; for instance
``(indexer-syntax a b c)`` expands into a macro transformer that
associates an index from 0 to 2 to each literal identifier from
``a`` to ``c``:

.. code-block:: scheme

 > (syntax-expand (indexer-syntax a b c))
 (syntax-match (a b c)
   (sub (ctx a) #'0)
   (sub (ctx b) #'1)
   (sub (ctx c) #'2))

The ``with-syntax`` form introduces the list of pattern variables ``(i ...)``
corresponding to the list ``(0 1 2)`` generated by the ``range`` function
by looking at the number of arguments, the ``(name ...)`` list.
The guarded pattern also checks that the names are distinct.
Thus, the following test passes:

$$TEST-INDEXER-SYNTAX

The basic feature of the indexer is that ``i`` is a macro and therefore literal
identifiers are turned into integers at compile time, *without runtime
penalty*. On the other hand, if you want to turn symbols known only
at runtime into integers, the previous approach does not work, and
you can define a runtime indexer as follows:

$$INDEXER

Here the indexer is a simple function; the acceptable symbols
are specified (and checked) at expand time, but the dispatch
is performed at runtime. Here is a test:

$$TEST-INDEXER

You may enjoy yourself with performance benchmarks comparing the macro
solution with the function solution; moreover you
can contrast this solution with the builtin way of R6RS Scheme
to build indexers as sets.

The problem with auxiliary macros
------------------------------------------------------------------

We said a few times that auxiliary functions are not available to macros
defined in the same module, but actually in general
there is the *same* problem for any identifier which is used in the
right hand side of a macro definition, *including auxiliary macros*.
For instance, we may regard the ``indexer-syntax`` macro 
as an auxiliary macro, to be used in the right hand side of a
``def-syntax`` form.

In systems with strong phase separation, like
PLT Scheme and Larceny, auxiliary macros
are not special, and they behave as auxiliary functions: you
must put them into a separare module and you must import them
with ``(for (only (module) helper-macro) expand)`` before using them.
This is why the following script

$$indexer-syntax:

fails in PLT scheme:


 $ plt-r6rs indexer-syntax.ss
 indexer-syntax.ss:9:0: def-syntax: bad syntax in: (def-syntax (indexer-syntax a b c))

  === context ===
 /usr/lib/plt/collects/rnrs/base-6.ss:492:6


The problem is that in PLT and Larceny, the second ``def-syntax`` does
not see the binding for the ``indexer-syntax`` macro.

This is a precise design choice: systems with strong phase
separation are making the life harder for programmers,
by forcing them to put auxiliary functions/macros/objects
in auxiliary modules, to keep absolute control on how the
names enter in the different phases and to make possible
to use different languages at different phases.

I have yet to see a convincing example of why keeping
different languages at different phases is worth
the annoyance.

On the other hand, in systems with weak phase separation,
like Ikarus/IronScheme/Mosh/Ypsilon,
*there is no need to put auxiliary
macros in an external module.* The reason is that all macro
definitions are read at the same time, and the compiler knows
about the helper macros, so it can use them. The consequence
is that a long as the compiler reads macro definitions, it expands
the compile-time namespace of recognized names which are available
to successive syntax definitions.

In Ikarus the script ``identifier-syntax.ss`` is
perfectly valid: the first syntax
definition would add a binding for ``identifier-syntax`` to the macro
namespace, so that it would be seen by the second syntax definition.


Systems with strong phase separation instead are effectively using
different namespaces for each phase.

Let me make an example. Consider the "colon" macro defined as follows:

$$lang:COLON

The colon macro expects as argument another macro, the
``let-form``, which can be any binding macro such that
``(let-form ((patt value) ...) expr)`` is a valid syntax. For instance
``(let ((name value) ...) expr)`` can be rewritten as ``(: let name value
... expr)``, by removing four parenthesis. The latest version of the
``aps`` package provides a colon form in the ``(aps lang)`` module.

Suppose you wanted to define the macros
``define-ct`` and ``alist`` in the same module:

.. code-block:: scheme

 (import (rnrs) (sweet-macros))

 (def-syntax (alist arg ...)
    <code here> ...)

  (def-syntax (define-ct kw (define name value) ...)
    #'(def-syntax kw
        (let ((a (alist (name value) ...)))
             <more code here> ...)))

Implementing a first class module system
-----------------------------------------

This is the same as implementing a Pythonic interface over hash tables
or association lists.

Working around phase separation
--------------------------------------------------------------

I have always hated being forced to put my helper functions in an
auxiliary module, because I often use auxiliary functions which
are intended to be used only once inside a given macro, thus
it makes sense to put those auxiliary functions *in the same
module* as the macro the are used in.
In principle you could solve the problem by definining all the
functions *inside* the macro, but I hate this, both for dogmatic
reasons (it is a Pythonista dogma that *flat is better than nested*)
and for pragmatic reasons, i.e. I want to be able to debug my
helper functions and this is impossible if they are hidden inside
the macro. They must be available at the top-level. Moreover, you
never know, and a functionality which was intended for use in a specific
macro my turn useful for another macro after all, and it is much
more convenient if the functionality is already encapsulated in
a nice exportable top level function.

I am not the only to believe that it should be possible to define
helper functions in the same module as the macro and actually
many Scheme implementations provide a way to do so via a
``define-for-syntax`` form which allows to define function
at *expand time*, so that they are available for usage in macros.

If your Scheme does not provide ``define-for-syntax``, which is not
part of the R6RS specification, you can still work around phase
separation with some clever hack. For instance, you could
use the following macro:

$$lang:literal-replace
|#
            
(import (rnrs) (sweet-macros) (for (aps list-utils) expand run)
        (for (aps lang) expand) (aps compat) (aps easy-test))

;;INDEXER-SYNTAX
(def-syntax (indexer-syntax name ...)
  (with-syntax (((i ...) (range (length #'(name ...)))))
    #'(syntax-match (name ...) (sub (ctx name) #'i) ...))
  (distinct? free-identifier=? #'(name ...))
  (syntax-violation 'assert-distinct "Duplicate name" #'(name ...)))
;;END


;;INDEXER
(def-syntax (indexer name ...)
  (with-syntax (((i ...) (range (length #'(name ...)))))
    #'(lambda (x) (case x ((name) i) ...)))
  (distinct? free-identifier=? #'(name ...))
  (syntax-violation 'assert-distinct "Duplicate name" #'(name ...)))
;;END

(display (syntax-expand (indexer-syntax a b c))) (newline)

(run

;;TEST-INDEXER-SYNTAX
(test "indexer-syntax"
      (let ()
        (def-syntax i (indexer-syntax a b c))
        (list (i a) (i b) (i c)))
      '(0 1 2))
;;END

;;TEST-INDEXER
(test "indexer"
      (let ()
        (define i (indexer a b c))
        (list (i 'a) (i 'b) (i 'c)))
      '(0 1 2))
;;END
)
