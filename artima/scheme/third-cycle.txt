`Episode #12`_ closes the second cycle of my *Adventures*.  I have
discussed at length Scheme macros, spending six episodes on the
subject. However, there is so much to say about Scheme macros that six
episodes are not enough to make them justice. Therefore I plan to
write a whole new cycle to discuss the deeper aspects of macros, such
as the hygiene issue, higher order macros and advanced
techniques. However, in this moment I think it is a good idea if I
pause for a while from macros, in order to give to my readers some
time to digest them. 

The third cycle of the *Adventures* will
not concerns macros. Instead, it will discuss another
interesting topic, i.e. the functional features of Scheme. 
It should be easier to follow since nowadays functional
programming is becoming popular (all scripting languages have some
support for functional programming, a lot of functional constructs
entered in the latest version of C#, Scala is getting traction
in the Java world, etc.).

Still, there is a substantial difference between an imperative
language with some support for functional programming and a truly
functional language.
A true functional language is based on functional data structures,
has strong support for recursion (it requires tail call optimization), 
and for higher order functions, and it features pattern matching. 
Scheme has all of those things and more, since it is a multiparadigm 
language.

I will devolve the next six episodes of the *Adventures* to the
exploration of these topics. However, you
will need to have patience since I have a few Python-related
papers to publish first, and the third cycle will
probably start next year.

Have fun!

.. _Haskell: http://www.haskell.org/
.. _currying: http://en.wikipedia.org/wiki/Currying
.. _Episode #12: http://www.artima.com/weblogs/viewpost.jsp?thread=240836
