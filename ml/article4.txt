Functional Programming For Dynamic Programmers - Part 4
=======================================================

:author: Michele Simionato
:date: December 2007

This is the fourth of a series of articles on functional programming in
statically typed languages. It is intended for dynamic programmers, i.e. 
for programmers with a background in dynamically typed languages, such as Perl, 
Python, Ruby, or languages in the Lisp family. The approch is eminently practical
and example-based; the main goal is to see if we can stole some good idea from
statically typed languages. In order to be concrete, I will consider languages
in the ML family, because they are pretty nice and much easier to understand
that Haskell.

The Standard ML type system
-------------------------------------------------------------------

You, the dynamic programmer, are surely familiar with the object
system of languages such as Python and Ruby, or Common Lisp and
Smalltalk.  In such languages you here often the mantra *everything is
an object* meaning that everything is a first class value which can
created and inspected at runtime. Moreover, any object has a class,
and classes themselves are objects, i.e. they are instances of
metaclasses.  SML has a type system which is completely different from
the object system of dynamic language. There a lots of things which
are not first class values (structures, exceptions, signatures, ...)
and even types are such: in SML any value has a type, but types itself
are not values.  Therefore passing the name of a type to the prompt
gives an error::

  - string;
  1.0-1.6: unknown value or constructor `string'

Just as structures  types live in a separated namespace.  
SML types are not classes in any OO sense of the term,
you cannot introspect them, there are no methods and no inheritance, 
thus the first step in order to learn the SML type system is to forget
everything you know about OOP. Having said that, you can certainly
program in an OO style in ML,  but you don't use types for OOP, types are used
internally by the compiler, but from the user's point of view they are just
labels attached to values.

The type system of SML is extensible, and the user can define new types (i.e.
new labels) in terms of primitive types. The labels are just that; but together
with a new label, the definition of a new type includes the definition
of one or more functions, the *constructors* of the type, which are first class
values and extremely useful for pattern matching.
Let me give a concrete example: an
``int_or_string`` datatype with two constructors ``INT`` and ``STR``, defined
as follows::

 - datatype int_or_string = INT of int | STR of string;
 datatype int_or_string = INT of int | STR of string

This definitions tells the compiler that the label ``int_or_string`` has to
be used when showing the signature of objects of the newly defined types;
but the important things are the constructors, which are able to convert (or *cast*)
primitive values to values of the new type::

 - val v1 = INT 1;
 val v1 : int_or_string = INT 1
 -  val v2 = STR "1";
 val v2 : int_or_string = STR "1"

Actually the constructors are perfectly ordinary functions::

 - INT;
 val it : int -> int_or_string = _fn
 - STR;
 val it : string -> int_or_string = _fn

Constructors are essential since you can use them in *pattern matching*.
For instance, suppose you want to define an utility function casting integer to strings.
You can do so as follows::

 - fun valueToString (INT x) = Int.toString x
        | valueToString (STR x) = x;
 val valueToString : int_or_string -> string = _fn

Let me check that it works::

 - valueToString (INT 1);
 val it : string = "1"
 - valueToString (STR "1");
 val it : string = "1"

In essence, we have just implemented type dispatching: ``valueToString``
is now emulating a C++ overloaded function (or a Lisp generic function) which 
accepts both integers and strings and behaves differently according to the type.
This in spirit, but technically ``valueToString`` is just an ordinary SML function
which takes in input the ``int_or_string`` type, so we are somewhat cheating,
but it works ;)

Consider for instance the issue of defining heterogeneous collections, i.e.
collections containing different types; in SML we cannot define a list containing
an integer and a string::

 - [1, "two"];
  1.0-1.2: ill-typed constructor argument:
    int * string list
 does not match argument type
    int * int list
 because type
    string
 does not unify with
    int

but we can define::

 - [INT 1, STR "two"];
 val it : int_or_string list = [INT 1, STR "two"]

As Harper puts it, *heterogenity is a special case of homogenity*.

It is also possible to define parametric types, where the constructor(s) can
accept any type as argument. For instance, we can define a parametric box type::

 - datatype 'a box = Box of 'a;
 datatype 'a box = Box of 'a

 - Box
 val it : 'a -> 'a box = _fn 

``box`` is a parametric type with constructor ``Box`` and parameter ``'a`` 
(to be read *alpha*), which corresponds to a generic type, so that you
can define ::

  - Box(1);
     val it : int box = Box 1
  - Box("hello");
     val it : string box = Box "hello"
  - Box(fn x =>  2*x);
  val it : (int -> int) box = Box (_fn)

In technical terms, we say that SML support *parametric polymorphism*.

Notice that it is pretty easy to define a function extracting the inner value from a box::

  - fun unbox (Box x) = x;

The builtin ``Ref`` type works as a box and the builtin``!`` function works
as ``unbox``, the different is that our ``Box`` is immutable, i.e. we do not
have an equivalent of the assigment function ``:=``.

Other examples of datatypes
-----------------------------------------------------------

We may define composite types, i.e. types with
*syntactic arity* greater than one, like the following::

 - datatype string_int = STRING_INT of string * int;
 datatype string_int = STRING_INT of string * int
 -

The uppercase identifier is called the constructors of the datatype, and can
be used to make concrete instances of the type::

 - STRING_INT("hello",  1);
 val it : string_int = STRING_INT ("hello", 1)
 -

where the constructor is a first class value, being simply a function taking
a pair ``(string, int)`` as input::

 - STRING_INT;
 val it  : string * int -> string_int = _fn

A more interesting example could be a *named_function* type corresponding
to a pair *(function, name)*, where *function* can be of any functions, whereas 
*name* is a string. 
We can define it as follows::

 - datatype ('a, 'b) named_function = NAMED_FUNCTION of ('a->'b) * string;
 datatype ('a, 'b) named_function = NAMED_FUNCTION of ('a -> 'b) * string
 -

*named_function* is a parametric type with parameter 'a (to be read *alpha*),
which corresponds to a generic type, and NAMED_FUNCTION is its associated 
constructor::

 - NAMED_FUNCTION;
 val it : ('a -> 'b) * string -> ('a, 'b) named_function = _fn
 -

In other words, NAMED_FUNCTION is a function converting a pair (value, name),
where *value* can be of any type, into a *named_function* parametric type.
Here is an example::

 - NAMED_FUNCTION (fn x=>2*x, "double");
  (* giving a  name to the function x=>2*x *)
 val it = NAMED_FUNCTION (fn,"double") : (int,int) named_function
 -

SML also allows to define enumeration types, like the following one::

 - datatype color = RED|GREEN|BLUE;
 datatype color = BLUE | GREEN | RED
 -

but for enumeration types the name is rather improper, since they are
just values::

 - RED;
 val it : color = RED
 -

 - GREEN;
 val it : color = GREEN
 -

 - BLUE;
 val it : color = BLUE
 -

Finally, SML let you define aliases for previously defined types,
or builtin types, by using the ``type`` keyword::

 - type c = color;
 type c = color

 - type func=named_function;
    type func=named_function
 - type ls = List.list;
    type ls = List.list

This is especially convenient when writing signatures.

Polymorphism
-------------------

 -  functor Sequence(ListOrVector:) = funct
     end


Two examples of simple structures in the standard library as List and Vector;
they act as modules with a mostly compatible interface, providing functions
to manipulate lists and vectors respectively. Since SML is a functional language,
both lists and vectors are immutable. Here are a few examples of usage::

 - val lst = [0,1,2];
 val lst : int list = [0, 1, 2]
 - val vec = #[0,1,2];
 val vec : int vector = #[0, 1, 2]

 - List.length(lst);
 val it : int = 3
 - Vector.length(vec);
 val it : int = 3

 -List.sub(lst, 1) (*) take the second element of the list
 val it : int = 1
 -Vector.sub(vec, 1) (*) take the second element of the vector
 val it : int = 1

 signature HAS_LENGTH = sig
  val length: 
 functor(F:HAS_LENGTH):
  
 polyLength(List)

Abstract types in signatures
-------------------------------------------------------

The common practice in SML is to define types inside structures,
so that you can associate structures with a types. For instance
here I define a ``ListOrVector`` structure associated with a
``list_or_vector`` datatype::

 - structure ListOrVector = struct
      datatype 'a list_or_vector = LST of 'a list | VEC of 'a vector
      type t =  list_or_vector
      fun length (LST x) = List.length x
          | length (VEC x) = Vector.length x
      fun sub (LST x, i) = List.sub (x,i)
          | sub (VEC x, i) = Vector.sub (x,i)   
    end;
    sig
       datatype 'a list_or_vector = LST of 'a list | VEC of 'a vector
       type t = ListOrVector.list_or_vector
       val length : 'a ListOrVector.list_or_vector -> int
       val sub : 'a ListOrVector.list_or_vector * int -> 'a
    end

The structure ``ListOrVector`` is associated to the parametric datatype  
``'a list_or_vector`` and contains the two constructors ``ListOrVector.LST``
and ``ListOrVector.VEC``. Moreover we defined the label ``ListOrVector.t``
to be an alias for ``ListOrVector.list_or_vector``, for a reason that will become
clear in the next paragraph. Here are two examples of usage::

 -  ListOrVector.length (ListOrVector.LST [1,2,3]);
 val it : int = 3

 - ListOrVector.length (ListOrVector.VEC #[1,2,3]);
 val it : int = 3


Functors
------------------------------------------------------

As we saw in the previous article, structures are not first class objects and 
they cannot be passed to and returned from regular functions.
To circumvent this restriction, the authors of ML invented
the concept of *functor*, which is basically a *sui generis* function
taking structures in input and to returning structures in output. Functors
are not-first-class objects themselves and therefore they require a specific
declaration, such as the following::

 - functor Wrap(SimpleIO:SIMPLE_IO) = struct
    val inputAll = SimpleIO.inputAll
    output = SimpleIO.output
    fun fileIn manage fname = let
        val file = openIn fname
    in
         manage file finally closeIn file
    end
    fun fileOut manage fname = let
        val file = openOut fname
    in
         manage file finally closeOut file
    end
 end

The functor here is important, since it shows how it is possible to write
generic code in SML. In this case, I have just written a library which is
able to wrap *any* structure matching the ``SimpleIO`` interface, and I have
avoided a potentially infinite code duplication.
The specification of which specific structure to use will be the job of the client
code, not of the library author; in particular a particular user of the library
may be interested in specializing it both for ``TextIO`` and ``BinIO``
by writing::

 - structure T = Wrap(TextIO)
 - structure B = Wrap(BinIO)

The operation of specializing a functor is also called *functor instantiation*;
since it happens in a structure declaration it is performed by the compiler
*at compile time*. The advantage is that the compiler can generate different optimized
code for  the structures``T`` and ``B`` in the *client* program.

``do print (IO.fileIn IO.inputAll "three-lines.txt")``
