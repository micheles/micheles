Functional Programming For Dynamic Programmers - Part 5
=======================================================================

:author:	Michele Simionato
:date:	December 2007

This is the fifth of a series of articles on functional programming in
statically typed languages. It is intended for dynamic programmers,
i.e. for programmers with a background in dynamically typed languages,
such as Perl, Python, Ruby, or languages in the Lisp family. The
approch is eminently practical and example-based; the main goal is to
see if we can stole some good idea from statically typed languages. In
order to be concrete, I will consider languages in the ML family,
because they are pretty nice and much easier to understand that
Haskell.

Records
-----------------------

The first level of grouping in ML is the record level: a record
roughly correspond to a *struct* in the C programming language and can
contain any kind of first class value. The record itself a first class value,
i.e. it can be passed to and returned from functions. I will give a few
examples of usage.

A record factory::

 - fun makeArticle {title:string, author:string} = {title, author};
 val makeArticle :  {author : string, title : string} -> {author : string, title : string} = _fn

An example record::

 - val article = makeArticle {title="Functional Programming", author="M. Simionato"};
 val article : {author : string, title : string} =
   {author = "M. Simionato", title = "Functional Programming"}

Extracting fields from a record::

 - #title article;
 val it : string = "Functional Programming"
 - #author article;
 val it : string = "M. Simionato"

A record containing functions::

 - val a = {makeArticle, printArticle = fn {title, author} => print (title^" "^author ^"\n") };
 - #printArticle a article;
 Functional Programming M. Simionato

Notice that the order of the fields is not specified and that there is no
concept of subrecord; for instance two records of kind 
``{title:string, author:string, publicationDate:string}``  and 
``{title:string, author:string}``
are considered completely different record types, the second one is not a subtype of 
the first one and you cannot substitute one with the other, possibly with default
values. Also, records are purely static and resolved at compile time: if you need
something more dynamic, you should use a map, not a record. Finally, records
are functional, i.e. immutable: there is no way to change the value of a field,
you must create an entirely new record with a different value if you want to
simulate a record update. 

Lists
---------------------------------------------------

Lists are the most common data structures in functional languages (they formed
the core of Lisp at its beginning) and there are many facilities to manage them and
to iterate over them. For instance, in the first article of this series, I showed the
``app`` builtin, to apply a function over the elements of a list; there is also
a ``map`` builtin to build a new list from an old one::

 - val doubles = map (fn x => 2*x) [1,2,3];
 val doubles : int list = [2, 4, 6]

and a ``filter`` function to extract the sublist of elements satisfying a given predicate::

 - fun isEven n = n mod 2 = 0;
 - val even = List.filter isEven [1,2,3];
 val even : int list = [2]

Moreover, you can append lists with the ``@`` operator::

 - [1] @ [2] @ [3,4];
 val it : int list = [1, 2, 3, 4]

There are other standard facilities and you can look at the documentation
http://www.standardml.org/Basis/list.html to find them all.

ML lists are linked lists in the same sense of Lisp or Scheme [#]_, however they 
are immutable. Just as in Scheme [#]_, where

  ``(list 1 2)``

is a shortcut for

 ``(cons 1 (cons 2 '()))``

in ML

  ``[1, 2]``

is a shortcut for

 ``1::2::[]``

and ``::`` is the *cons* operator (short for constructor).


.. [#] Python lists are actually arrays, not lists

.. [#] If you don't know Scheme, 

   [1, 2] (ML) => [1,[2,[]]] (Python)



It is also possible to apply a binary operator to a list, via the ``foldl`` and ``foldr``
functions::

 - val sum = foldl op+ 0 [1,2,3];
 val sum : int = 6


fun enum n = lazy n :: enum (n+1)

(for instance, a log file); how can we process it? The simplest possibility is
to convert it into a lazy list of lines, with the following code::

 fun textFileToList filename = let
     val file = TextIO.openIn filename
     fun lazy readLines () =
         case TextIO.inputLine file 
               handle ex => (TextIO.closeIn file; raise ex)
          of NONE => (TextIO.closeIn file; [])
           | SOME line => line :: readLines ()
 in
     readLines ()
 end


A smarter line counter
-----------------------------------------------------------

 - val countLines = length o textFileToList 




Python extended generators in Alice
---------------------------------------------------------

def consumer():
  result = []
   while True:
     inp = yield
     if inp = END:
       return result 

functor consumer(val ch: channel):
   while true do let
      val inp = Channel.gexst ch
      if inp = END:


In particular, what's the equivalent of the simple
Python one-liner ``for item in container: print item``?  The answer is
that there is no equivalent. The Python one-liner is completely
polymorphic, since it works for any kind of container and it is able
to print any kind of object. However, SML is a statically typed
language, and you must give to the compiler some information about the
types: it cannot predict the future, nor the type of the container and
the types of the items.  Here I will show how you can loop on
homogenous containers, i.e . containers where the items are all
instances of the same type;


 fun writeln (tostring, value)  =
    print(format (tostring o text "\n") value);


-  app (fn item => writeln(int, item)) [1,2,3];
1
2
3

fun sum lst = foldl op+ 0 lst

The thing to remember is that functions associate to the **right**, so

  ``a -> b -> c``

means

  ``a -> (b -> c)``

whereas type constructor associates to the **left**, so 

  ``int ref list``

means

   ``(int ref) list``


Timers
--------------------

fun timedFn f a = let
  val ct = Timer.startRealTimer ()
  val result = f a
in
  (result, Timer.checkRealTimer (ct))
end


 - structure A = struct
     type 'a aggr 
     fun length(a: 'a aggr) = 1
     fun sub(a: 'a aggr, i :int) = 1
   end;
 signature AGGREGATE_TYPE =
   sig
      type 'a aggr 
      val length : 'a aggr -> int
      val sub : 'a aggr * int -> int
   end
 -

ok

"Hello World", part II
-------------------------------------------------

On the other hand, print2 cannot accept anything different than strings::

 - print2("the answer is ", 42);
 1.0-1.28: mismatch on application: expression type
    string * int
 does not match function's argument type
    string * string
 because type
    int
 does not unify with
    string

To print a string and a number, we should define another function::

 - fun print_string_int(s, i)=(print s; print (Int.toString(i)));
 val print_string_int : string * int -> unit = _fn
 - print_string_int("The answer is ", 42);
 The answer is 42val it : unit = ()

This is clearly unpractical, since we can't define an infinite number
of ``print`` functions to be able to print all the potentially
infinite types we can have in our programs.  Fortunately there are
utility library for converting objects in strings (even if not
standard :-(). SML/NJ has the library FormatComb, to be used as
follows (from now on, for concision sake, I will omit to write down
the full output of the REPL)::

 - open FormatComb;
 - print (format (text "The value is " o int o text ".") 42);
 The value is 42

The syntax looks strange (especially the "o" operator) and if you
forget the parenthesis you will get funny error messages. To
understand what is going on, you will need to master SML to a much
more advanced level than this first paper is meant to, so you will
have to wait for "Hello World, Part II" ;) Here I will content myself
to notice that the format utility requires you to specify the types of
the arguments. SML is a *typeful* language: the compiler must know the
types of all your variables *before running the program*.  In a
dynamic language, instead, the types can be introspected at runtime
and there is no need to specify them. This is most of the times an
advantage, however, it also leads to type errors that cannot occur in
a statically typed language such as SML (also called *type safe*
languages). Moreover, SML compilers may perform optimization which are
impossible in a dynamic language (but this is of lesser relevance,
since any user of dynamic languages will use C libraries if speed is
an issue).


Higher order functions can also be used to implement poor man's object
systems; consider for instance this example::

 class Counter(object):
    def __init__(self, initial_value):
         self.initial_value = self.value = 0
    def incr(self):
         self.value += 1
    def show(self):
         print "The value is %d" % self.value 
    def reset(self):
         self.value = self.initial_value

We can get the same effect via a stateful higher order function (a.k.a. a closure)::

 exception MissingMethod

 fun makeCounter initialValue = let
    val value = ref initialValue
 in 
     fn "reset" => value := initialValue
      | "show" => (print The value is "; print (Int.toString (!value)); print "\n")
      | "incr" => value := !value + 1
      | _ => raise MissingMethod
 end

 val counter = makeCounter 0;

 do counter "incr";
 do counter "show"; (* The value is 1 *)
 do counter "reset";
 do counter "show"; (* The value is 0 *)

This example also shows the usage of pattern matching and of exceptions.

You can rewrite it in a functional way as follows:

----

*The venerable master Qc Na was walking with his student, Anton.  Hoping to
prompt the master into a discussion, Anton said "Master, I have heard that
objects are a very good thing - is this true?"  Qc Na looked pityingly at
his student and replied, "Foolish pupil - objects are merely a poor man's
closures."*

*Chastised, Anton took his leave from his master and returned to his cell,
intent on studying closures.  He carefully read the entire "Lambda: The
Ultimate..." series of papers and its cousins, and implemented a small
Scheme interpreter with a closure-based object system.  He learned much, and
looked forward to informing his master of his progress.*

*On his next walk with Qc Na, Anton attempted to impress his master by
saying "Master, I have diligently studied the matter, and now understand
that objects are truly a poor man's closures."  Qc Na responded by hitting
Anton with his stick, saying "When will you learn? Closures are a poor man's
object."  At that moment, Anton became enlightened.*

      -- Anton van Straaten


