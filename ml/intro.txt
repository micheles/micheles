Functional Programming For Dynamic Programmers - Part 1
=======================================================

:author: Michele Simionato
:date: December 2007

This is the first of a series of articles on functional programming in
statically typed languages. It is intended for dynamic programmers, i.e. 
for programmers with a background in dynamically typed languages, such as Perl, 
Python, Ruby, or languages in the Lisp family. The approch is eminently practical
and example-based; the main goal is to see if we can stole some good idea from
statically typed languages. In order to be concrete, I will consider languages
in the ML family, because they are pretty nice and much easier to understand
that Haskell.

Declaration of intents
----------------------

One may rightly wonder why to study functional languages, and in
particular statically-typed ones such as SML and Haskell: after all, 
their relevance in enterprise programming is negligible, they are practically
unknown for system
administration task, and unless you are a computer science researcher
you have no need to know them. All that is true; on the other hand, if
you believed it, you would not be a dynamic programmer, you would have
stick with C and you would not be a reader of my papers.
A dynamic programmer is the kind of person who, when everbody says
"the Earth is flat", will wonder: "is the Earth *really* flat?". So,
even if everybody says that object orientation is good and that
inheritance is the best thing after sliced bread, a dynamic programmer
will be suspicious of these claims and will seek for alternatives.
Exactly in the same way he escaped from the enslaving by static typing
in old fashioned languages, he will escape from the enslaving by
dynamic typing languages, if he finds valid alternatives. A dynamic
programmer has a kind of Casanova complex, and he will never be loyal
to a single language.
In particular, a dynamic programmer will judge academic languages
worth of investigation: he may decided not to use them, but still he may get
some good ideas from them. After all, Python stole the list comprehension
idea from Haskell and iterators from Icon; Ruby stole many ideas from Scheme
and Smalltalk; Perl stole from everybody.
I always wanted to learn a modern statically-typed functional
language, at least to have something intelligent to say in the endless
usenet discussions on dynamic typing vs. static typing; recently, by
accident, I run into Standard ML (SML, ML stands for Meta Language)
and I found out it has a very clean syntax, so I decided to learn it [#]_.

SML is practically unknown outside academia (its cousins Caml and F# are a
little more known, but they are certainly very far away from being
mainstream languages) and I am not interested in advocating it for use
in enterprise programming; after all in enterprise programming the technical
advantages of a language count very little compared to things like the support
you can get, the ability to find skilled programmers,  the interoperability with
your existent codebase and development environment (I mean the tools and
libraries you use, the database, etc). My motivation here is to learn something
from SML, and to try to avoid mistakes in mainstream languages which have
been already fixed in SML. Let me give a concrete example: in the past I have been
using Zope and Twisted, which are enterprise-level Python frameworks. They
share a common implementation of interfaces. I have always had a bad gut
feeling about Zope interfaces: I always thought they were overkill, complex, and
not doing by default what they (In my opinion) should do, i.e. interface checking.
I always thought there should be a better solution (Python 3.0 actually will
have a simpler  implementation of interfaces in the core language)
but until I studied SML I had no idea of how the solution should look like.
I think SML has the better module system I have ever seen; and my goal
here is to popularize it, trying to get some of SML ideas into Python frameworks.

Micro-introduction to functional languages
------------------------------------------------------------

Simply put, functional languages are programming languages that try
very hard to avoid mutation and side effects. There are no pure
functional languages in use, since an absolutely pure language would
have to rule out input and output and it would be pretty much useless;
nevertheless, some functional languages are purer that others. For
instance, there are languages which have some support for functional
programming, but are not considered functional (Python being an
example); others, like Lisp, which is regarded as the grandfather of
functional languages, that are pretty much regarded as impure
nowadays; Scheme is somewhat perceived as more functional than Common
Lisp, but this is debatable, and in any case it is not very pure;
Standard ML (SML) is often perceived as purer than Scheme, but mostly
because of syntactical convenience, not of technical merit; Haskell is
possibly the purest functional language commonly used, but still can
be used in an imperative way. This classification is sloppy and wrong
in more than one way; nevertheless it is useful (in my personal
opinion) in the sense that it gives and indication of how much the
language departs from a mainstream imperative language, and how
difficult it is to learn it.  Functional languages come in two kinds:
dynamically typed (Lisp, Scheme, Erlang ...) and statically typed
(SML, OCaml, Haskell ...).  Programmers used to dynamic typing (i.e
Pythonistas, Rubystas, etc) will have less trouble to understand
dynamically typed functional language, so it is more interesting (in
my opinion) to look at statically typed languages. After all, I think
a programmer should have at least a statically typed language in his
toolbox (C++ and Java do not count). SML is the simplest statically
language out there, so l decided to start with it.

In the following, I will often contrast the functional way with the imperative
way, and I will mostly use Python as an example of imperative language,
because it is a language that I know decently well, and because it is
so readable that the examples will be easy to understand even for
programmers not familiar with Python.

Getting an SML compiler
--------------------------------------------------------

SML is a language with many implementations, so if you want to try it,
you must decide which implementation to use. I have played with some
of them, including SML of New Jersey (http://www.smlnj.org) and MLton
(http://mlton.org) but at the end I have decided to use Alice ML,
since it has a lot of innovative features, an interesting set of libraries, and
some clean syntax extensions.  It is also a very dynamic version of SML,
so that dynamic programmers will not feel too constrained ;-)
On Ubuntu, you can install it with 
``apt-get install alice-runtime`` (having added 
``deb http://www.ps.uni-sb.de/alice/download/debian stable contrib`` to your
``/etc/apt/sources.list``) where on the Mac, you can download the
``.dmg`` installer and add ``/Applications/Alice.app/Contents/Resources/bin`` 
to your PATH. There is also an installer for Windows, but if you are a dynamic
programmer I do not expect you to use Windows, unless you are forced
to ;) 

Having installed Alice you can start the "interpreter"  or REPL 
(read-eval-print-loop) [#]_ as follows::

 $ alice
 Alice 1.4 ("Kraftwerk 'Equaliser' Album") mastered 2007/04/24 
 ### loaded signature from x-alice:/lib/system/Print
 ### loaded signature from x-alice:/lib/tools/Inspector
 ### loaded signature from x-alice:/lib/distribution/Remote

Now you can write your first mandatory "Hello world" program::

 -  print "Hello world\n";
 Hello world
 val it : unit = ()

and you are ready to start. If you are an old timer Emacs user, you
may also want to install (Aqua)Emacs and the sml-mode for Emacs (Alice
has a custom version of it, that you can download from here_ ).

.. _here: http://www.ps.uni-sb.de/alice/download/sml-mode-4.0+alice.zip

.. [#] In principle, one may argue that choosing a language because of
        its syntax is stupid and that one should look at its features,
        libraries, reliability, etc; in practice, many languages are
        more or less equivalent in terms of features, libraries and
        reliability, so that the main factor for the choice of the
        language is it syntax.  Also, when you are a beginner and you
        need to write only simple programs, syntax is all that
        matters.

.. [#] Technically the Alice REPL is not an interpreter: the
         expressions you enter are compiled on the fly and executed
         immediately, not interpreted. However, the overall
         user-experience is the same as if you had an
         interpreter. This approach is commons in ML and Lisp implementations.

It may be useful sometime to contrast Alice with more traditional ML
implementations (especially to see if the error messages are more
understandable with another compiler) so you want to run
``apt-get install smlnj mlton`` as well.
 
Hello world
---------------------------------------

In the previous section I have shown how the traditional "Hello world"
program looks in ML.  ML is a language without statements (as usual in 
functional languages; statements are actually a bad idea IMO, even 
for imperative languages [#]_) so *print* is a  function taking a string in
input and returning an empty tuple in output, as you
can see from the last line of output

``val it: unit = ()``

The empty tuple is of type ``unit`` and it is the sole representative of that 
type (i.e. it is a singleton). In general, any object has a type; 
for instance, if you enter the number 42 at the prompt you will get 

::

 - 42;
 val it: int = 42

The REPL just prints a string representation of the value
you entered, together with its type (in this case, int).

A point to notice in the "Hello world" program
is the lack of parenthesis: we wrote ``print
"Hello world\n";`` and not ``print("Hello world\n")``. This is
possible since the ``print`` function in ML takes only a *single*
argument; actually *all* functions in SML takes a single argument!

You may wonder how is it possible to program anything serious if all
functions take a single argument: the answer is that the single
argument can be of a composite type, for instance a tuple. So you may
define functions like the following

::

 - fun print2 (arg1, arg2)= (print arg1; print arg2);
 val print2 : string * string -> unit = _fn

Here ``print2`` takes a single argument, which is a 2-tuple (a pair),
and returns the null (unit) value. The interesting thing is that the
compiler has been able to figure out by itself that the arguments must
be of string type, since ``print`` expects a string, and that
``print2`` will return an ``unit`` value, since ``print`` does so: we
are seeing here the type -inferencer at work. We also see that a
function is just a value as any other value, i.e. functions are first
class objects, as usual in dynamics languages; its type is 
``string * string -> unit``.

Let us check that ``print2`` works as expected::

 - print2 ("hello ", "world");
 hello world
 val it: unit = ()

If you want to print a generic number of arguments,  you can use a list::

 - fun printList lst = app print lst; 
 val printList : string list -> unit =_fn
 - printList["Hello ", "World", "!", "\n"];
 Hello World!
 val it : unit = ()

The builtin function ``app`` apply the ``print`` function to each element of the
list from left to right.

ML does not have default arguments, so you cannot write the analogous
of this Python function::

  >>> def printUser(user="Michele"):
  ...      print "Hello,", user
  >>> printUser()
  Hello, Michele
  >>> printUser("Mario")
  Hello, Mario

In Python, ``printUser`` can be called with zero or one arguments, but in ML this
is not possible, since functions with different arity are of a different type and
ML does not support function overloading; however, you can however work around 
this feature [#]_ by using  options. ML has a standard *option* type, used for
objects which may have a NONE value; any object can be converted into an option 
by wrapping it with SOME. An example will make it clear. Let me define::

 - fun printUser(userOpt: string option) = 
      printList ["Hello, ", getOpt(userOpt, "Michele"), "\n"];
 val printUser : string option -> unit = _fn

where *getOpt(opt, default)* is a builtin function which returns the
value of the option, or the default if the option have value NONE. We
may call *printUser* as follows::

 - printUser NONE;
 Hello, Michele
 - printUser (SOME "Mario");
 Hello, Mario

The syntax is definitively ugly, and there are actually clever tricks
to implement default arguments in a nicer way, but they are too
advanced for this introduction.  But stay tuned for the next issues ;)

.. [#] Incidentally, in current Python ``print`` is a statement and it
        does not return anything, but in Python 3000 ``print`` will be
        function returning None

.. [#] The lack of function overloading may be seen as a feature or as
        a limitation, depending on the reader.

----

*A long journey starts with the first step*

      -- old Chinese saying
