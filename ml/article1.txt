Functional Programming For Dynamic Programmers - Part 1
=======================================================

:author: Michele Simionato
:date: December 2007

This is the first of a series of articles on functional programming in
statically typed languages. It is intended for dynamic programmers, i.e. 
for programmers with a background in dynamically typed languages, such as Perl, 
Python, Ruby, or languages in the Lisp family. The approch is eminently practical
and example-based; the main goal is to see if we can stole some good idea from
statically typed languages. In order to be concrete, I will consider languages
in the ML family, because they are pretty nice and much easier to understand
that Haskell.

Declaration of intents
----------------------

One may rightly wonder why to study functional languages, in a
particular statically-typed ones [#]: after all, their relevance in
enterprise programming is negligible, they are unknown for system
administration task, and unless you are a computer science researcher
you have no need to know them. All that is true; on the other hand, if
you believed it, you would not be a dynamic programmer, you would have
stick with C and you would not be a reader of my papers.
dynamic programmer is the kind of person who, when everbody says
";the Earth is flat", will wonder: "is the Earth *really* flat?". So,
even if everybody says that object orientation is good and that
inheritance is the best thing after sliced bread, a dynamic programmer
will be suspicious of these claims and will seek for alternatives.
Exactly in the same way he escaped from the enslaving by static typing
in old fashioned languages, he will escape from the enslaving by
dynamic typing languages, if he finds valid alternatives. A dynamic
programmer has a kind of Casanova complex, and he will never be loyal
to a single language.
In particular, a dynamic programmer will judge academic languages
worth of investigation: he may decided not to use them, but still he may get
some good ideas from them. After all, Python stole the list comprehension
idea from Haskell and iterators from Icon; Ruby stole many ideas from Scheme
and Smalltalk; Perl stole from everybody.
I always wanted to learn a modern statically-typed functional
language, at least to have something intelligent to say in the endless
usenet discussions on dynamic typing vs. static typing; recently, by
accident, I run into Standard ML (SML, ML stands for Meta Language)
and I found out it has a very clean syntax, so I decided to learn it
[#].
SML is practically unknown outside academia (its cousins Caml and F# are a
little more known, but they are certainly very far away from being
mainstream languages) and I am not interested in advocating it for use
in enterprise programming; after all in enterprise programming the technical
advantages of a language count very little compared to thing like the support
you can get, the ability to find skilled programmers,  the interoperability with
your existent codebase and development environment (I mean the tools and
libraries you use, the database, etc). My motivation here is to learn something
from SML, and to try to avoid mistakes in mainstream languages which have
been already fixed in SML. Let me give a concrete example: in the past I have been
using Zope and Twisted, which are enterprise-level Python frameworks. They
share a common implementation of interfaces. I have always had a bad gut
feeling about Zope interfaces: I always thought they were overkill, complex, and
not doing by default what they (In my opinion) should do, i.e. interface checking.
I always thought there should be a better solution (Python 3.0 actually will
have a simple  implementation of interfaces in the core language)
but until I studied SML I had no idea of how the solution should look like.
I think SML has the better module system I have ever seen; and my goal
here is to popularize it, trying to get some of SML ideas in Python frameworks.

Micro-introduction to functional languages
------------------------------------------------------------

Simply put, functional languages are programming languages that try very hard to
avoid mutation and side effects. There are no pure functional
languages in use, since an absolutely pure language would have to rule
out input and output and it would be pretty much useless;
nevertheless, some functional languages are purer that others. For
instance, there are languages which have some support for functional
programming, but are not considered functional (i.e. Python); others,
like Lisp, which is regarded as the grandfather of functional
languages, that are pretty much regarded as impure nowadays; Scheme is
somewhat perceived as more functional than Common Lisp, but this is
debatable, and in any case it is not very pure; Standard ML (SML) is
often perceived as purer than Scheme, but mostly because of
syntactical convenience, not of technical merit; Haskell is possibly
the purest functional language commonly used, but still can be used in
an imperative way. This classification is sloppy and wrong in more
than one way; nevertheless it is useful (in my personal opinion) in
the sense that it gives and indication of how much the language
departs from a mainstream imperative language, and how difficult it is
to learn it.  Functional languages come in two kinds: dynamically
typed (Lisp, Scheme, Erlang ...) and statically typed (SML, Haskell
...).  Programmers used to dynamic typing (i.e Pythonistas, Rubystas,
etc) will have less trouble to understand dynamically typed functional
language, so it is more interesting (in my opinion) to look at
statically typed languages. After all, I think a programmer should have at
least a statically typed language in his toolbox (C++ and Java do not
count). SML is the simplest statically language out there, so l decided to
start with it

SML is a language with many implementations, so if you want to try it,
you must decide which implementation to use. I have played with some
of them, including SML of New Jersey (http://www.smlnj.org) and MLton
(http://mlton.org) but at the end I have decided to use Alice ML,
since it has a lot of innovative features, an interesting set of libraries, and
some clean syntax extensions.  It is also a very dynamic version of SML,
so that dynamic programmers will not feel too constrained ;-)
On Ubuntu, you can install it with 
``apt-get install alice-runtime`` (having added 
``deb http://www.ps.uni-sb.de/alice/download/debian stable contrib`` to your
``/etc/apt/sources.list``) where on the Mac, you can download the
``.dmg`` installer and add ``/Applications/Alice.app/Contents/Resources/bin`` 
to your PATH. There is also an installer for Windows, but if you are a dynamic
programmer I do not expect you to use Windows, unless you are forced
to ;) 

Having installed Alice you can start the "interpreter"  or REPL 
(read-eval-print-loop) [#]_ as follows::

 $ alice
 Alice 1.4 ("Kraftwerk 'Equaliser' Album") mastered 2007/04/24 
 ### loaded signature from x-alice:/lib/system/Print
 ### loaded signature from x-alice:/lib/tools/Inspector
 ### loaded signature from x-alice:/lib/distribution/Remote

Now you can write your first mandatory "Hello world" program::

 -  print "Hello world\n";
 Hello world
 val it : unit = ()

and you are ready to start ;) If you are an old timer Emacs user, you
may also want to install (Aqua)Emacs and the sml-mode for Emacs (Alice
has a custom version of it, that you can download from here_ ).

.. _here: http://www.ps.uni-sb.de/alice/download/sml-mode-4.0+alice.zip

.. [#] Modern statically-typed language here means a language with
         type-inference, such as SML and Haskell. We all know that
         there are no good ideas to be extracted from ancient
         statically typed languages such as Java, C and C++ ;)

.. [#] In principle, one may argue that choosing a language because of
        its syntax is stupid and that one should look at its features,
        libraries, reliability, etc; in practice, many languages are
        more or less equivalent in terms of features, libraries and
        reliability, so that the main factor for the choice of the
        language is it syntax.  Also, when you are a beginner and you
        need to write only simple programs, syntax is all that
        matters.

.. [#] Technically the Alice REPL is not an interpreter: the
         expressions you enter are compiled on the fly and executed
         immediately, not interpreted. However, the overall
         user-experience is the same as if you had an
         interpreter. This approach is commons in ML and Lisp implementations.

"Hello world", Part I
---------------------------------------

In the previous section I have shown how the traditional "Hello world"
program looks in ML.  ML is a language without statements (as usual in 
functional languages; statements are actually a bad idea IMO, even 
for imperative languages [#]_) so *print* is a  function taking a string in
input and returning an empty tuple in output, as you
can see from the last line of output

``val it: unit = ()``

The empty tuple is of type ``unit`` and it is the sole representative of that 
type (i.e. it is a singleton). In general, any object has a type; 
for instance, if you enter the number 42 at the prompt you will get 

::

 - 42;
 val it: int = 42

The REPL just prints a string representation of the value
you entered, together with its type (in this case, int).

A point to notice in the "Hello world" program
is the lack of parenthesis: we wrote ``print
"Hello world\n";`` and not ``print("Hello world\n")``. This is
possible since the ``print`` function in ML takes only a *single*
argument; actually *all* functions in SML takes a single argument!

You may wonder how is it possible to program anything serious if all
functions take a single argument: the answer is that the single
argument can be of a composite type, for instance a tuple. So you may
define functions like the following

::

 - fun print2 (arg1, arg2)= (print arg1; print arg2);
 val print2 : string * string -> unit = _fn

Here ``print2`` takes a single argument, which is a 2-tuple (a pair),
and returns the null (unit) value. The interesting thing is that the
compiler has been able to figure out by itself that the arguments must
be of string type, since ``print`` expects a string, and that
``print2`` will return an ``unit`` value, since ``print`` does so: we
are seeing here the type -inferencer at work. We also see that a
function is just a value as any other value, i.e. functions are first
class objects, as usual in dynamics languages; its type is 
``string * string -> unit``.

Let us check that ``print2`` works as expected::

 - print2 ("hello ", "world");
 hello world
 val it: unit = ()

If you want to print a generic number of arguments,  you can use a list::

 - fun printList lst = app print lst; 
 val printList : string list -> unit =_fn
 - printList["Hello ", "World", "!", "\n"];
 Hello World!
 val it : unit = ()

The builtin function ``app`` apply the ``print`` function to each element of the
list from left to right.

ML does not have default arguments, so you cannot write the analogous
of this Python function::

  >>> def printUser(user="Michele"):
  ...      print "Hello,", user
  >>> printUser()
  Hello, Michele
  >>> printUser("Mario")
  Hello, Mario

In Python, ``printUser`` can be called with zero or one arguments, but in ML this
is not possible, since functions with different arity are of a different type and
ML does not support function overloading; however, you can however work around 
this feature [#]_ by using  options. ML has a standard *option* type, used for
objects which may have a NONE value; any object can be converted into an option 
by wrapping it with SOME. An example will make it clear. Let me define::

 - fun printUser(userOpt: string option) = 
      printList ["Hello, ", getOpt(userOpt, "Michele"), "\n"];
 val printUser : string option -> unit = _fn

where *getOpt(opt, default)* is a builtin function which returns the
value of the option, or the default if the option have value NONE. We
may call *printUser* as follows::

 - printUser NONE;
 Hello, Michele
 - printUser (SOME "Mario");
 Hello, Mario

The syntax is definitively ugly, and there are actually clever tricks
to implement default arguments in a nicer way, but they are too
advanced for this introduction.  But stay tuned for the next issues ;)

.. [#] Incidentally, in current Python ``print`` is a statement and it
        does not return anything, but in Python 3000 ``print`` will be
        function returning None

.. [#] The lack of function overloading may be seen as a feature or as
        a limitation, depending on the reader.

Functional programming and Input/Output
-----------------------------------------------------

Input/output is the black ship of functional programming and it is
often relegated at the end of tutorials and sometimes even omitted, as
if shameful. Sometime, it is not even standardized and
implementation-dependent. On the other hand, *all* programs must
perform some kind of input/output, or at least of output, otherwise we
would have no way to see what a program did. Therefore input/output
*must* be explained at the beginning of any tutorial, not at the
end. I always hated books not telling me how to read a file until the
appendix!  In this section I will explain how you can read a file in
SML. Reading a file is for some reason seen as "inpure" since it is
not functional.  Let me explain that a bit more: in mathematics, a
function takes an argument in input, and returns an output; if I call
twice the function with the same argument, I get twice the *same*
output. In programming, a procedure reading a line from a file returns
a *different* line at each invocation, even if called with the same
arguments (the arguments maybe simply the empty tuple), so it is not a
function in the mathematical sense. On the other hand, a procedure
writing a line into a file, is also impure, since it is modifying an
object, the file itself. 
In strict functional programming there is no
mutation, objects are declared once and for all times they do not
change. Functional programming in its purest form is therefore useless:
notice that even the paradigmatic "Hello world" program is not a functional 
program, since the "Hello world" string is printed via an imperative side 
effect. In other words, every functional programming language must find a 
non-functional way to manage input-output. Haskell tries very hard to hide
non-functional constructs into monads; SML just uses traditional
imperative constructs to perform input/output.  We already saw the
``print`` function to write on stdout; to read from stdin, you can
define the following utility::

 - fun input prompt = (print prompt; getOpt(TextIO.inputLine TextIO.stdIn, ""))
 val input : string -> string = _fn

The parenthesis here are needed since the right hand side of a function definition
must be an expression, and the parenthesis (plus the expression separator ";")
allows you to compose expressions in a single expression returning as value
the value of the last expression. ``TextIO`` is a module in the standard library
managing textual I/O and ``TextIO.inputLine inputFile`` is a function
returning a line wrapped into an option object or NONE if we arrived at the
end of the input file. In particular, in the case of standard input,
we arrive at the end when we give CTRL-D (in a Unix-like system); in
this case ``input`` will return the empty string, otherwise it returns the
input line, comprehensive of the newline character.

Here is an example of usage::

 - input "Enter a string: ";
 Enter a string: hello
 val it : string = "hello\n"
 - input "Enter CTRL-D ";
 - Enter CTRL-D 
 val it : string = ""

I we want to read a text file (assuming it fits in memory)
the simplest way is to use ``TextIO.inputAll``::

 - fun fileToString filename = let
     val file = TextIO.openIn filename
   in
     TextIO.inputAll file finally TextIO.closeIn file
   end

Conversely, if we want to write a text on a file we can define::

 - fun saveFile (fname, content) = let
      val out = TextIO.openOut fname
   in
      TextIO.output(out, content) finally TextIO.closeOut out
   end;

The examples here use the standard *let* expression, which has the form::

  let
     <bindings>
  in 
     <expression; .. ; expression>
  end

and returns as value the value of the last expression. Moreover, the examples
here use the *finally* construct, which is an Alice extension to SML, and
works as you would expect:: 

   <expression possibly raising exceptions> finally <cleanup expression>

the finally clause if executed always, even
if there is an exception in the first expression.

The examples here are very simple and do not address the issue or reading
or writing large files which do not fit in memory. But don't worry,
we will address those situations in the next issues, have faith!

----

*A long journey starts with the first step*

      -- old Chinese saying
